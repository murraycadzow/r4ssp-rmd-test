---
title: "Repeating Code"
date: "Semester 1, 2022"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    code_download: true
    code_folding: show
---

```{r setup, include=FALSE}
library(knitr)

knitr::opts_chunk$set(
  comment = "#>",
  fig.path = "figures/08/", # use only for single Rmd files
  collapse = TRUE,
  echo = TRUE
)


```

> #### Associated Material
>
> Zoom Notes: [Zoom Notes 08 - Repeating Code](zoom_notes_08.html)
>
> Readings:
>
> - [R for Data Science - Chapter 21](https://r4ds.had.co.nz/iteration.html)

\

# Introduction

In the previous module we saw how to make our code more **modular** by organising it into functions, each of which encapsulates some logically distinct task. By repeatedly calling a function, we can execute the same code many times, while only having to type it out once. This is **code reuse** and is an important goal in efficient software development.

We can also achieve code reuse through **iteration**. Iterative constructs, more casually called **loops** allow us to write out some commands once, then instruct R to execute them a specified number of times. The number of iterations can be made to vary, depending on the **state**. (Recall that **state** is the set of values of all the variables in the environment when a command is executed.) For example, we can write a loop that iterates as many times as there are rows in a data frame that we read from a file before the loop starts.

In R, as in most modern programming languages, there are different types of loops, with subtle differences in behaviour. See the recommended reading for details. We begin with the most general kind of loop -- the **for loop**.


# Schematic

In R a for loop has this structure:

for (*variable_name* in *some_kind_of_sequence*)
{
  *Code to be repeated. Can be as long as required.*
}


The keywords **for** and **in** are required, as are the round brackets in the **loop header**, and the curly brackets that delineate the code body.

The *some_kind_of sequence* is usually a vector. The code body is executed as many times as there are elements in the vector.

We will discuss the role of the *variable_name* element later in the module.


# Basic loop

A popular cheer in Australian sports is "Aussie!, Aussie!, Aussie!". Assume that (for some inexplicable reason) you wished to print this cheer. That is, you want to print "Aussie!" to the console three times. Using only sequential code you would write:

```{r sequential, eval=FALSE}
print("Aussie!")
print("Aussie!")
print("Aussie!")
```
You are executing the identical line of code three times. Having to type the same line of code many times is boring, and simply multiplies the number of opportunities for typos and bugs to sneak in. (And in this toy example, we are only repeating one line of code three times; in a real computational situation we might need to repeats dozens of lines of code hundreds of times.) Using a for-loop, we can achieve the same output while only typing the command once.

```{r basic loop}
for (cheer in c(1,2,3))
{
  print("Aussie")
}
```

Match the parts of this loop to the schematic, noting the position of the keywords **for** and **in**, the brackets, and the *some_kind_of_sequence* element which is, in this case, the vector created by `c(1,2,3)`. Since there are three elements in the vector, the code body is executed three times. 

## Vector sequences

If we wanted to print "Aussie!" 5 times, we could increase the length of the vector to 5. If we wanted to print it 100 times (could happen) we could increase the length of the vector to 100, but using function `c()` for this is too cumbersome. In R, we have an alternative for generating a sequence of numbers using the `:` operator.

```{r seq }
small_seq <- 1:5
small_seq

big_seq <- 1:50
big_seq
```

There are more powerful functions for generating sequences (see, for example `seq` and `rep`) but for basic for loops, the `:` operator is sufficient. We can extend our cheer-printing for-loop:

```{r long cheer}
for (cheer in 1:15)
{
  print("Aussie")
}
```

# The Loop Driver


Recall the schematic for an R for loop:

for (*variable_name* in *some_kind_of_sequence*)
{
  *Code to be repeated. Can be as long as required.*
}

The *variable_name* element can be any legal R variable name. This element is called the **loop driver**. Inside the code body of the for-loop the loop driver variable is always available. For example, in our "Aussie!, Aussie! Aussie!" example, our loop driver was called *cheer*. In our code body we could have referred to variable `cheer`. 

As discussed above, the for loop code body is executed as many times as there are elements in the sequence in the header. At each pass through the loop, the loop driver automatically takes on **the value of the corresponding element of the sequence**. That is, in the first pass of the loop, the loop driver variable is assigned the value of the first element of the sequence; in the second pass of the loop, the loop driver variable is assigned the value of the second element of the sequence, and so on.

We illustrate this by extending our previous example to print the value of loop driver `cheer` inside the code body:

```{r long cheer 2}
for (cheer in 1:3)
{
  print("Aussie")
  print(cheer)
}
```

Note that you **never assign** a value to the loop driver -- it takes on its values automatically as the for loop runs.

In all our examples so far, the sequence in the for-loop header has been numbers from 1 to *n*. In R, the sequence can be a vector of any type, and the loop driver will take on whatever values the sequence contains. For example, we can drive a for loop with a vector of string:

```{r seq of string}
sports <- c("Rugby", "Cycling", "Ice Skating")
for (current_sport in sports)
{
  # Print the sport name
  print(current_sport)
  
  # Compute the number of characters in the sport name
  print(nchar(current_sport))
}
  
```

## Loop driver as index

Throughout the course we have seen that R relies heavily on managing data in ordered collections (vectors, lists, and data frames). We select elements from those collections using [], providing the ordinal position of the element of interest. Since loop driver variables take on each value in their sequence, we can use a for loop to step through each element of a collection in turn.

For example, assume a data frame containing a student's internal and exam marks for the papers taken in one semester: 

```{r make data frame}

paper_codes <- c("HUBS192", "ECOL212", "STAT260")
internal_marks <- c(87, 85, 62)
exam_marks <- c(93, 84, 85)

marks_df <- data.frame(PaperCode = paper_codes,
                       InternalMark = as.numeric(internal_marks),
                       ExamMark = as.numeric(exam_marks))

```

We know that we can select all columns from a single row in that data frame using the syntax [*row number*, ]

```{r select row}
# Select and print row 2

selected_row <- marks_df[2, ]
print(selected_row)

```
With a for loop we can use the loop driver to iterate over all the rows, processing each in turn:


```{r simple driver as index}
for (index in 1:3)
{
  # Use the loop driver to index into the data frame
  selected_row <- marks_df[index, ]
  print(selected_row)
}

```

Note that if we made our data frame longer than three rows by adding more papers to it, the preceding for loop **would not** print all the rows; the sequence in that exmaple is always `1, 2, 3` so we see only rows 1, 2, and 3. We can make the loop more general by determining the for-loop sequence **dynamically** using function `nrows`, which accepts a data frame as an argument, and returns the number of rows in the data frame:

```{r using nrow}

# Display all rows
for (index in 1:nrow(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_row <- marks_df[index, ]
  print(selected_row)
}

# Add a row to the data frame
marks_df <- rbind(marks_df, data.frame(PaperCode = "ZOOL316", 
                                       InternalMark = 83, 
                                       ExamMark = 90))


# Repeat the loop -- see four rows
for (index in 1:nrow(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_row <- marks_df[index, ]
  print(selected_row)
}
```

## Exercise

1. Write a for-loop that iterates over marks_df printing **each column** in turn.
2. Your final mark in each paper is computed as 40% of your internal mark plus 60% of your exam mark. Using the technique of your choice, add a new column to marks_df
3. Run you for-loop again and confirm that it displays *all* the columns, including the new one.

```{r ex 1 solution}
# Display all columns
for (index in 1:ncol(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_col <- marks_df[ , index]
  print(selected_col)
}


# Add a new column
marks_df$TotalMark <- (0.40 * marks_df$InternalMark) + (0.60 * marks_df$ExamMark) 


# Confirm that we display all four columns
for (index in 1:ncol(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_col <- marks_df[ , index]
  print(selected_col)
}
```

## Nested Loops

In the preceding examples, we have iterated over a data frame processing complete rows, or complete columns. Frequently, it is necessary to iterate over a data frame (or matrix) processing each cell in turn. That is, instead of using the [, col] or [row, ] forms of selection, we need to specify both a row index and a column index (i.e. [row, col]). This is very common processing technique in simulation, computer graphics, artifical intelligence, and other problems requiring matrix algebra.

We iterate over tabular date in an orderly fashion. For example, if we have a 3x3 matrix or data frame we would process the cells in the first row from left to right ([1,1], [1,2], [1,3]), then the cells in the second row ([2,1], [2,2], [2,3]), and finally the cells in the third row ([3,1], [3,1], [3,3]). You can view this pattern as using **two loop drivers**, one for the row index and one for the column index. While the row driver is 1, we want the column driver to loop through values 1, 2, and 3. Then, we want the row driver to take on 2, and again want the column driver to loop through 1, 2, and 3. Finally we want the row driver to be 3, and the column driver to loop again. We can achieve this by **nesting** a for-loop for columns **inside** a for loop for rows, as shown below. Note that each for loop has its own loop driver, its own sequence and its own round and curly brackets. The style of indenting the **inner** is very important for maintaining code readability.

```{r nested for row-wise}

# Outer loop.
for (row_index in 1:nrow(marks_df))
{
  # Inner loop -- makes all iterations for each pass through outer loop
  for (col_index in 1:ncol(marks_df))
  {
    # Use both loop drivers to select
    cell_value <- marks_df[row_index, col_index]
    print(cell_value)
  }
}
```


## Exercise
The preceding example prints *row-wise*. That is, it prints all the values for each row (i.e. for a single paper) before moving to the next row (paper). Modify the code to print *column-wise*. That is, print down the columns: all the paper names, then all the internal marks, then all the exam marks, then all the final marks.

```{r nested for col-wise}

# Outer loop.
for (col_index in 1:ncol(marks_df))
{
  # Inner loop -- makes all iterations for each pass through outer loop
  for (row_index in 1:nrow(marks_df))
  {
    # Use both loop drivers to select
    cell_value <- marks_df[row_index, col_index]
    print(cell_value)
  }
}
```

### CAUTION
Using a nested for-loop to visit every cell in a table is a very common, and very powerful code pattern. However, be aware that it can be computationally expensive (i.e. it can take a long time to run). If your outer loop runs `n` passes and your inner loop runs `m` passes, you make a total of `n * m` passes. When processing a 1000 row x 1000 column table with a nested for-loop, the code body of the inner loop is executed one million times, which may be intractable. If you have large data sets that take a long time to process, you should consider leveraging R's advanced vector processing techniques that provide more efficient processing than an interior for loop. See, for example, https://rstudio-pubs-static.s3.amazonaws.com/72295_692737b667614d369bd87cb0f51c9a4b.html or http://www.john-ros.com/Rcourse/memory.html for discussions.


#########

## While loop

The while loop is a useful loop to use when the length of the input vector is unknown. The situation where this arises often would be in simulations where you want to find out how many times something happened until you got a certain result -- an exit condition.

The skeleton for a `while` loop is as follows:

```{r, eval = FALSE}
while (condition) {
  # loop body
}
```

Here is an example of a `while` loop where we want to find out how many iterations it takes to obtain 3 heads in a row:

```{r, echo = TRUE, eval = TRUE}
## Example from R for Data Science - 21.3.4 ##

# Function to simulate head or tail as the result of a coin flip
flip <- function(){
  sample(c("T", "H"), 1)
}

# variables to keep track of key results
flips <- 0
nheads <- 0

# flip a coin until there are three heads and count how many flips were performed.
while (nheads < 3) {
  if (flip() == "H") {
    nheads <- nheads + 1
  } else {
    nheads <- 0
  }
  flips <- flips + 1
}
flips

```

It's very important to **always make sure your condition will eventually be FALSE before running!** Otherwise you'll be stuck in an 'infinite loop' where your code keeps running and never stopping. If you find yourself in this situation in RStudio, in the top right of the console window you can click the 'stop' sign, or under the `Session` menu click "Interrupt R" to make it stop.



# Map

From the package `purrr` (part of the tidyverse), there are a collection of `map` functions which are a method of iterating over a collection of things applying a function. This is known as _functional programming_, and allows us to extract the code that is in common for a loop, into a function, so rather than being concerned about the set-up of the loop, we can focus on the contents of the loop. This idea of mapping a function onto data is extremely similar to the concept underlying the `for` loop.

## Map and friends

The package `purrr` within the tidyverse provides the `map` functions that take a vector or list as the first argument, and the second argument is the function to be run on each item in the vector or list. The object that is returned back with the results depends on the exact version of `map` that is called, the default `map()` returns the results as items in a list, but there are suffix versions of `map` that will return the results back in a specified data type.

- `map()` makes a list.
- `map_lgl()` makes a logical vector.
- `map_int()` makes an integer vector.
- `map_dbl()` makes a double vector.
- `map_chr()` makes a character vector.

These suffix versions will give an error if the data type of the results doesn't match. This is useful for being able to program with, as it means that you can be sure that you have a particular data type for future code. Some of the base R functions that you will meet in the next section don't provide this guarantee. The arguments to the `map` functions are `.x` which is the vector or list input, and `.f` which is the name of the function. if the supplied function takes multiple arguments these can be passed in as extra arguments to `map`.

We could use the example of converting some temperatures to demonstrate
```{r}
library(purrr)

farenheit_to_celcius <- function(temp_f){
  temp_c <- (temp_f -32) * 5/9
  return(temp_c)
}

my_temps_f <- c(90, 78, 88, 89, 77)

# gives back a list
my_temps_c_list <- map(.x = my_temps_f, .f = farenheit_to_celcius)
my_temps_c_list

# gives back a vector of type numeric/double
my_temps_c_dbl <- map_dbl(.x = my_temps_f, .f = farenheit_to_celcius)
my_temps_c_dbl
```

When using `map` and variants, don't include the `()`'s on the function name, if you do you'll get this error:
```{r, error = TRUE}
map(.x = my_temps_f, .f = farenheit_to_celcius())
```


# Apply

Base R has built in functions for applying a function to a vector, list or data frame. There is `apply` which will apply a function to either columns or rows of a data frame, `lapply` for applying to a list or vector - it's analogous to `map()`, and `vapply` which can takes the return data type as one of the arguments so can be thought of as analogous to the suffix versions of `map`. The `apply()` function is very similar to `map()`


The equivalent example of what we did above with `map()` `and map_dbl()` is as follows:

```{r}
farenheit_to_celcius <- function(temp_f){
  temp_c <- (temp_f -32) * 5/9
  return(temp_c)
}

my_temps_f <- c(90, 78, 88, 89, 77)

# lapply example
lapply_my_temps_c <- lapply(X = my_temps_f, FUN = farenheit_to_celcius)
lapply_my_temps_c

# vapply example. FUN.VALUE defines the type and length size of each of the returned results. 
vapply_my_temps_c <- vapply(X = my_temps_f, FUN = farenheit_to_celcius, FUN.VALUE = numeric(1))
vapply_my_temps_c
```

We can see that there is a difference in the results that R returns between `lapply` and `vapply` by using `str` to look at the structure.

```{r}
str(lapply_my_temps_c)
str(vapply_my_temps_c)
```

`lapply_my_temps_c` is a _list_ with each item being a numeric vector, whereas `sapply_my_temps_c` is single a _numeric_ vector of (the data type that we specified). When we specified the data type for `vapply` we used `numeric(1)` as an argument. What this meant was that each time our function specified for `FUN = ` is run, it was expected to return a vector of length 1 of type numeric. If this wasn't the case, an error would occur. One thing to be aware of is that `vapply` doesn't always return a vector, the data structure that it returns depends on the data going in. This can make it challenging to know beforehand what the output is going to look like - unlike the suffix versions of `map` from `purrr`.



# Conclusion

In this module we covered how repeat tasks efficiently. Combining iteration with part 1 - functions and flow and control - you now have the knowledge to be able to create code that is modular and reusable, and maintainable. This will enable you to be more efficient going forward with your programming and analysis.


## What's Next

Congratulations on finishing the course! This doesn't have to be the end of your learning journey with R though. There are many free online resources to delve further in. If you haven't already, a good place to start is the chapters of [R for Data Science](https://r4ds.had.co.nz) that weren't covered in the course. And if you want to get more in-depth with the R language the online book [Advanced R](https://adv-r.hadley.nz) covers more of the R language and programming.

Please fill in the module feedback form [https://tinyurl.com/r4ssp-module-fb](https://tinyurl.com/r4ssp-module-fb).

 

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Subsetting</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R4SSP Semester 1 2022</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Intro</li>
    <li>
      <a href="01-intro.html">Intro to R and RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Focus</li>
    <li>
      <a href="02-visualise.html">Part 1: Visualising</a>
    </li>
    <li class="dropdown-header">Part 2: Subsetting</li>
    <li class="dropdown-header">Part 3: Transforming</li>
    <li class="dropdown-header">Part 4: Summarising</li>
    <li class="dropdown-header">Part 5: Communicating</li>
    <li class="divider"></li>
    <li class="dropdown-header">Programming focus</li>
    <li class="dropdown-header">Functions and Choices</li>
    <li class="dropdown-header">Repeating Code</li>
    <li class="dropdown-header">Workflows</li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Handouts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="handout1.html">Handout 1</a>
    </li>
    <li>
      <a href="handout2.html">Handout 2</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Subsetting</h1>
<h4 class="date">Semester 1, 2022</h4>

</div>


<p>Handout: <a href="handout3.html">Handout 03 - Selecting and Filtering
Data</a></p>
<p>Associated reading:</p>
<ul>
<li><a href="https://r4ds.had.co.nz/transform.html">R for Data Science -
Chapter 5</a></li>
</ul>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>If you are working through the suggested materials in order, you have
just completed <a
href="https://r4ds.had.co.nz/transform.html"><strong>Chapter 5 - Data
Transformation (https://r4ds.had.co.nz/transform.html)</strong></a> from
the online text <em>R for Data Science</em>. This material demonstrated
how to use the library <strong>dplyr</strong>, one of the libraries in
the <strong>tidyverse</strong> family. You will have learned how to use
the five core transformation functions – <code>filter</code>,
<code>arrange</code>, <code>select</code>, <code>mutate</code> and
<code>summarise</code> (with its helper function <code>group_by</code>).
These functions allow you to modify and perform summaries on data
frames, and to pull out specific portions of data frames for detailed
analysis. Library <code>dplyr</code> is widely used, and you will see
many examples of it in R code you find in the wild.</p>
<p>The functions in <code>dplyr</code> (and in all the other libraries
in the tidyverse) are technically <strong>wrappers</strong> around base
R code. That is, they themselves are written using base R commands. Thus
it is possible to perform all the same transformations <em>without</em>
<code>dplyr</code>, by using only base R. Many programmers and
researchers (including some of your lecturers) prefer to use base R for
these operations, and you will also see it often in R code in the wild.
Therefore, in this supplementary handout, we will illustrate the
equivalent base R syntax for the <code>dplyr</code> functions you just
learned.</p>
<p>People make the choice between <code>dplyr</code> and base R for
several reasons. Many people find <code>dplyr</code> syntax easier to
use, because it is more <strong>uniform</strong>. That is, all the big
five <code>dplyr</code> transformation functions use approximately the
same syntax. In base R, there is more variation. Scientists who work
with very large data sets are often concerned about how fast their code
can be executed. In some cases, <code>dplyr</code> executes more slowly
than base R (because of the extra code required for the wrapping),
leading these researchers to prefer the base R approach. Because
<code>dplyr</code> is a relatively new addition to R, some people prefer
base R because they learned it first, and are happy to continue using
it.</p>
<p>Unless you are required to use a particular approach (check with your
lecturer if you are unsure), you can choose whichever set of commands
you like using. You can even mix and match them – they give the same
results, and R doesn’t care. However, it is very important that you can
<em>understand</em> both styles. One of the great benefits of the R
ecosystem is the wide sharing of code, and you can’t fully participate
in this unless you are comfortable with all the major dialects.</p>
<p><br />
</p>
</div>
<div id="selection" class="section level2">
<h2>Selection</h2>
<p>We will begin with selection, because in base R, it is used by some
of the other transformation techniques. You have already seen how, in
base R, you can select a single column from a data frame using
<code>$</code>. You have seen how to select a subset of rows using
function <code>subset</code>. You can make more detailed selections from
data frames using the <strong>selection operator</strong> [ ].</p>
<p>The general syntax of the selection operator is:</p>
<p><em>name_of_data_frame[row_information, column_information]</em></p>
<p>We place the square brackets right against the name of the data
frame. Inside the square brackets we provide information about the row
or rows we want (we will see the exact format for this in a moment),
then a comma, then information about the column or columns we want.</p>
<p>There are a variety of ways to express row and column information. To
see how they work, let’s first make a very simple data frame by hand,
and then perform some selection operations on it. Enter the following
code into RStudio to create <strong>geography_df</strong>.</p>
<pre class="r"><code>countries &lt;- c(&quot;Austria&quot;, &quot;Brazil&quot;, &quot;Canada&quot;, &quot;Denmark&quot;)
capitals &lt;- c(&quot;Vienna&quot;, &quot;Brasilia&quot;, &quot;Ottawa&quot;, &quot;Copenhagen&quot;)
population_in_millions &lt;- c(9, 211, 38, 6)

geography_df &lt;- data.frame(Country = countries,
                           Capital = capitals,
                           PopulationMillions = population_in_millions)

geography_df
#&gt;   Country    Capital PopulationMillions
#&gt; 1 Austria     Vienna                  9
#&gt; 2  Brazil   Brasilia                211
#&gt; 3  Canada     Ottawa                 38
#&gt; 4 Denmark Copenhagen                  6</code></pre>
<p>In the simplest form of selection, we want just one single value from
a data frame, so we provide the row number and column number of the cell
of interest. For example, imagine we want the population of Vienna. We
know that Vienna is in row 1 and the population is in column 3. To
select that cell we provide 1 for the row information and 3 for the
column information in the square brackets:</p>
<pre class="r"><code>geography_df[1,3]
#&gt; [1] 9</code></pre>
<p>Don’t worry about how you would know the specific row and column of
the cell you are interested in. This particular selection operation is
typically used in situations where your code is computing those values
based on complex criteria. This example is merely illustrative. <a
href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>There are two very useful extensions to this pattern:</p>
<ol style="list-style-type: decimal">
<li>Either the row or column index (or both) may specify a
<strong>range</strong> using the : operator. For example, 1:3 or 6:12
(these are “1 to 3” and “6 to 12” respectively).</li>
</ol>
<pre class="r"><code># For rows 2 to 4 (Brazil, Canada, Denmark), select the population (column 3)
geography_df[2:4, 3]
#&gt; [1] 211  38   6

# For Canada (row 3), select both the capital name and population (cols 2 and 3)
geography_df[3, 2:3]
#&gt;   Capital PopulationMillions
#&gt; 3  Ottawa                 38</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Either the row or column index <strong>may be omitted</strong>. That
is, we can say <code>geography_df[3 , ]</code> or
<code>geography_df[ , 2]</code>. The missing element is interpreted as
<strong>all</strong>. Omit the row number and you want <strong>all
rows</strong> in the supplied column(s). Omit the column number and you
want <strong>all columns</strong> in the supplied row(s).</li>
</ol>
<pre class="r"><code>
# For Denmark (row 4), select all the columns
geography_df[4, ]
#&gt;   Country    Capital PopulationMillions
#&gt; 4 Denmark Copenhagen                  6

# For all rows, select the capital city name (column 2)
geography_df[ , 2]
#&gt; [1] &quot;Vienna&quot;     &quot;Brasilia&quot;   &quot;Ottawa&quot;     &quot;Copenhagen&quot;</code></pre>
<p>You may have been surprised by the output generated by that last
example. Although you have selected a single column, the output is
printed horizontally, as though it were a row. This is a peculiarity of
R. Any collection that has a single dimension (i.e. doesn’t have both
columns and rows) is treated as a plain vector. And vectors are always
printed horizontally. By extension, since a selected column of a data
frame is a vector, you can apply everything you have learned about
vectors to selected data frame columns, which is exactly what we want to
be able to do.</p>
<p>You can combine ranges and the <em>missing index = all</em>
technique:</p>
<pre class="r"><code># For the first three rows, select all the columns
geography_df[1:3 , ]
#&gt;   Country  Capital PopulationMillions
#&gt; 1 Austria   Vienna                  9
#&gt; 2  Brazil Brasilia                211
#&gt; 3  Canada   Ottawa                 38</code></pre>
<p>As an exercise, what do you think <code>geography_df[ , ]</code>
(i.e. where both row and column information are omitted) will do? Try
it. Were you right?</p>
<p>Instead of using column numbers, you can provide column names as the
column information (and row names as the row information if your data
frame has named rows). Use the combine function <code>c()</code> to
provide multiple column names, and be sure to surround each column name
with quotes, because R considers them to be strings in this
situation.</p>
<pre class="r"><code>geography_df[2:4, &quot;Capital&quot;]
#&gt; [1] &quot;Brasilia&quot;   &quot;Ottawa&quot;     &quot;Copenhagen&quot;

geography_df[3:4, c(&quot;Country&quot;, &quot;Capital&quot;)]
#&gt;   Country    Capital
#&gt; 3  Canada     Ottawa
#&gt; 4 Denmark Copenhagen</code></pre>
<hr />
</div>
<div id="perform-descriptive-analyses-on-groups" class="section level2">
<h2>Perform descriptive analyses on groups</h2>
<pre class="r"><code># Load the library before the first time you call read_csv
library(readr)

# Read a csv file into R. Store the result in a named variable
puppy_donations_data &lt;- read_csv(&quot;data/r4ssp_donations_data.csv&quot;)
#&gt; Rows: 50 Columns: 3
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): Condition
#&gt; dbl (2): CollectorNumber, Amount
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

# As always in R, we can display the contents of a variable by simply typing its name.
puppy_donations_data
#&gt; # A tibble: 50 × 3
#&gt;    CollectorNumber Amount Condition
#&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    
#&gt;  1               1   190. Puppy    
#&gt;  2               2   178. Puppy    
#&gt;  3               3   178. Puppy    
#&gt;  4               4   210. Puppy    
#&gt;  5               5   188. Puppy    
#&gt;  6               6   199. Puppy    
#&gt;  7               7   180. Puppy    
#&gt;  8               8   195. Puppy    
#&gt;  9               9   186. Puppy    
#&gt; 10              10   233. Puppy    
#&gt; # … with 40 more rows</code></pre>
<p>We often wish to summarise our dependent variable for all the members
of an experimental group. For example, in this study we might want to
find the mean amount donated for just those collectors in the Puppy
group. To do this, we first take <strong>a subset</strong> of the data
frame. That is, we separate out only those rows that are in the group of
interest. Then we can summarise individual columns exactly as we did
above, operating on our partial data frame.</p>
<p>To take a subset of rows from a data frame, use function
<code>subset</code>. This function takes two arguments: first, the name
of the data frame from from which you are separating out rows; second,
the criterion you wish to use to select your subset. In this example we
wish to select out all the rows for which the Condition column value is
“Puppy”. In R we describe this criterion with
<code>Condition == "Puppy"</code>. Note the double equal sign
<strong>==</strong>. This is very important. A single equal sign here
means something else, and will not work at all. The complete code to
select all the collectors who had puppies is:</p>
<pre class="r"><code>subset(puppy_donations_data, Condition == &quot;Puppy&quot;)
#&gt; # A tibble: 25 × 3
#&gt;    CollectorNumber Amount Condition
#&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    
#&gt;  1               1   190. Puppy    
#&gt;  2               2   178. Puppy    
#&gt;  3               3   178. Puppy    
#&gt;  4               4   210. Puppy    
#&gt;  5               5   188. Puppy    
#&gt;  6               6   199. Puppy    
#&gt;  7               7   180. Puppy    
#&gt;  8               8   195. Puppy    
#&gt;  9               9   186. Puppy    
#&gt; 10              10   233. Puppy    
#&gt; # … with 15 more rows</code></pre>
<p>As always, it will make our code tidier to save the output in a named
variable for later use.</p>
<pre class="r"><code>puppies_only &lt;- subset(puppy_donations_data, Condition == &quot;Puppy&quot;)
puppies_only
#&gt; # A tibble: 25 × 3
#&gt;    CollectorNumber Amount Condition
#&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    
#&gt;  1               1   190. Puppy    
#&gt;  2               2   178. Puppy    
#&gt;  3               3   178. Puppy    
#&gt;  4               4   210. Puppy    
#&gt;  5               5   188. Puppy    
#&gt;  6               6   199. Puppy    
#&gt;  7               7   180. Puppy    
#&gt;  8               8   195. Puppy    
#&gt;  9               9   186. Puppy    
#&gt; 10              10   233. Puppy    
#&gt; # … with 15 more rows</code></pre>
<p>We can select columns from our new partial data frame and compute
summary statistics for a column of interest just as we did above:</p>
<pre class="r"><code>mean(puppies_only$Amount)
#&gt; [1] 197.79
sd(puppies_only$Amount)
#&gt; [1] 16.2079</code></pre>
<p>R has a very rich system for defining selection criteria when using
functions like <code>subset</code>. In addition to checking whether one
value equals another with <code>==</code>, as above, you can use all the
usual logical comparisons like less than, greater than, less than or
equal to, etc.</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>R Symbol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Less than</td>
<td>&lt;</td>
</tr>
<tr class="even">
<td>Less than or equal to</td>
<td>&lt;=</td>
</tr>
<tr class="odd">
<td>Greater than</td>
<td>&gt;</td>
</tr>
<tr class="even">
<td>Greater than or equal to</td>
<td>&gt;=</td>
</tr>
<tr class="odd">
<td>Not equal to</td>
<td>!=</td>
</tr>
</tbody>
</table>
<p>For example, we could use any of the following as the second
condition of our call to <code>subset</code>:</p>
<table>
<colgroup>
<col width="59%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th>R Statement</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Amount &lt; 100</td>
<td>Select all rows that have Amount less than 100</td>
</tr>
<tr class="even">
<td>Amount &gt;= 50</td>
<td>Select all rows that have Amount greater than, or equal to, 50</td>
</tr>
<tr class="odd">
<td>Condition != “Puppy”</td>
<td>Select all rows in which Condition is not equal to “Puppy”</td>
</tr>
</tbody>
</table>
<p>It is also possible to combine these <strong>logical
operations</strong>. You could, for example, ask for only those rows
where Condition was “Alone” and Amount was greater than 100. Google “R
logical operations” to find out more.</p>
<p>In our next module, when we begin the use the
<strong>tidyverse</strong> library, we will learn additional very
efficient techniques for selecting subsets of interest from a large data
set.</p>
<div id="time-to-write-your-own-code" class="section level3">
<h3>Time to Write Your Own Code</h3>
<p>Repeat the analysis above, but summarise only those subjects in the
<em>Alone</em> group (those collectors who had no puppies). Your results
should be as shown below. Do not move ahead in this document until you
can generate these values by using <code>subset</code>, <code>$</code>,
<code>mean</code>, and <code>sd</code>. If you need help, let us
know.</p>
<pre><code>#&gt; [1] &quot;Mean: 102.3016&quot;
#&gt; [1] &quot;Standard deviation: 19.8987&quot;</code></pre>
<hr />
<p>To see how selection with the <code>select</code> function from
<code>dplyr</code> compares to selection with the selection operator [ ]
in base R, let’s load the <strong>flights</strong> data frame and repeat
some of the exercises from <em>R for Data Science</em>.</p>
<pre class="r"><code>
# Load the library that contains the flights data frame
library(nycflights13)

# Load dplyr
library(dplyr)



# Select the year, month, and day columns from the flights data frame

# With dplyr
year_month_day_cols_dplyr &lt;- select(flights, year, month, day)
year_month_day_cols_dplyr
#&gt; # A tibble: 336,776 × 3
#&gt;     year month   day
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;
#&gt;  1  2013     1     1
#&gt;  2  2013     1     1
#&gt;  3  2013     1     1
#&gt;  4  2013     1     1
#&gt;  5  2013     1     1
#&gt;  6  2013     1     1
#&gt;  7  2013     1     1
#&gt;  8  2013     1     1
#&gt;  9  2013     1     1
#&gt; 10  2013     1     1
#&gt; # … with 336,766 more rows

# With base R
year_month_day_cols_base &lt;- flights[ , c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;)]
year_month_day_cols_base
#&gt; # A tibble: 336,776 × 3
#&gt;     year month   day
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;
#&gt;  1  2013     1     1
#&gt;  2  2013     1     1
#&gt;  3  2013     1     1
#&gt;  4  2013     1     1
#&gt;  5  2013     1     1
#&gt;  6  2013     1     1
#&gt;  7  2013     1     1
#&gt;  8  2013     1     1
#&gt;  9  2013     1     1
#&gt; 10  2013     1     1
#&gt; # … with 336,766 more rows</code></pre>
<p><br />
</p>
</div>
</div>
<div id="subsetting" class="section level2">
<h2>Subsetting</h2>
<p>The <code>dplyr</code> function <code>filter</code> is analogous to
the base R function <code>subset</code>. The two functions have
identical syntax. We can see how some of the <code>dplyr</code> filter
operations from the previous section would be written using base R. If
you wish, run this code in RStudio, and inspect the results of each
statement.</p>
<pre class="r"><code>
# In all cases, these pairs of commands produce the same output
# In each pair, the first version is dplyr and the second
# is base R

# All flights with arrival delay &gt;= 120 minutes
late_dplyr &lt;- filter(flights, arr_delay &gt; 120)
late_base &lt;- subset(flights, arr_delay &gt; 120)

# Flew to IAH or HOU
houston_dplyr &lt;- filter(flights, dest == &quot;IAH&quot; | dest == &quot;HOU&quot;)
houston_base &lt;- subset(flights, dest == &quot;IAH&quot; | dest == &quot;HOU&quot;)

# Alternatively, using %in%, which requires less typing
houston_dplyr &lt;- filter(flights, dest %in% c(&quot;IAH&quot;, &quot;HOU&quot;))
houston_base &lt;- subset(flights, dest %in% c(&quot;IAH&quot;, &quot;HOU&quot;))

# Select rows with missing values using is.na() 
missing_dep_time_dplyr &lt;- filter(flights, is.na(dep_time))
missing_dep_time_base &lt;- subset(flights, is.na(dep_time))</code></pre>
<p>Base R does not have the helper function <code>between</code>, but
the same result can be achieved in a number of ways:</p>
<pre class="r"><code># Between

# These four commands all produce the same result

# dplyr
summer_dplyr &lt;- filter(flights, between(month, 7, 9))

# base R
summer_base_01 &lt;- subset(flights, month %in% c(7,8,9))
summer_base_02 &lt;- subset(flights, month %in% 7:9)
summer_base_03 &lt;- subset(flights, month &gt;=7 &amp; month &lt;= 9)</code></pre>
<p>When you have multiple options for performing a computation, the
general goal is to strike a balance between <strong>parsimony</strong>
(not too much typing) and <strong>readability</strong> (your code is
easy <em>for other people</em> to understand). When working on group
projects, or in a professional software development context, readablity
is considered the more critical of the two features.<br />
</p>
</div>
<div id="arranging-sorting" class="section level2">
<h2>Arranging (sorting)</h2>
<p>The <code>dplyr</code> function <code>arrange</code> is analogous to
base R selection using [ ] combined with function <code>order</code>. We
use <code>order</code> as the row information to [ ]. The arguments to
<code>order</code> are a comma separated sequence of the columns on
which we wish to sort. We identify the columns using the $ operator, in
the usual way.</p>
<p>For example, the <code>dplyr</code> statement and the base R
statement below both sort the entire flight data frame on the year,
month, and day columns:</p>
<pre class="r"><code>
# Sort using arrange or order

# dplyr
year_month_day_dplyr &lt;- arrange(flights, year, month, day)

# base R – we omit the column index to get all columns in the result
year_month_day_base &lt;- flights[order(flights$year, flights$month, flights$day), ] 

# Compare the results
year_month_day_dplyr
#&gt; # A tibble: 336,776 × 19
#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
#&gt;  1  2013     1     1      517            515         2      830            819
#&gt;  2  2013     1     1      533            529         4      850            830
#&gt;  3  2013     1     1      542            540         2      923            850
#&gt;  4  2013     1     1      544            545        -1     1004           1022
#&gt;  5  2013     1     1      554            600        -6      812            837
#&gt;  6  2013     1     1      554            558        -4      740            728
#&gt;  7  2013     1     1      555            600        -5      913            854
#&gt;  8  2013     1     1      557            600        -3      709            723
#&gt;  9  2013     1     1      557            600        -3      838            846
#&gt; 10  2013     1     1      558            600        -2      753            745
#&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
#&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
year_month_day_base
#&gt; # A tibble: 336,776 × 19
#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
#&gt;  1  2013     1     1      517            515         2      830            819
#&gt;  2  2013     1     1      533            529         4      850            830
#&gt;  3  2013     1     1      542            540         2      923            850
#&gt;  4  2013     1     1      544            545        -1     1004           1022
#&gt;  5  2013     1     1      554            600        -6      812            837
#&gt;  6  2013     1     1      554            558        -4      740            728
#&gt;  7  2013     1     1      555            600        -5      913            854
#&gt;  8  2013     1     1      557            600        -3      709            723
#&gt;  9  2013     1     1      557            600        -3      838            846
#&gt; 10  2013     1     1      558            600        -2      753            745
#&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
#&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>If you find it tiresome to type the name of the data frame in front
of each column in <code>order</code>, use function <code>attach</code>.
This function accepts a data frame as its argument. In all subsequent
code, you can refer to columns of the data frame without having to
preface them with the data frame name and $:</p>
<pre class="r"><code>
# Call attach
attach(flights)

# Just use the column names; no flights$ needed
year_month_day_base &lt;- flights[order(year, month, day), ]

# Check the result
year_month_day_base
#&gt; # A tibble: 336,776 × 19
#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
#&gt;  1  2013     1     1      517            515         2      830            819
#&gt;  2  2013     1     1      533            529         4      850            830
#&gt;  3  2013     1     1      542            540         2      923            850
#&gt;  4  2013     1     1      544            545        -1     1004           1022
#&gt;  5  2013     1     1      554            600        -6      812            837
#&gt;  6  2013     1     1      554            558        -4      740            728
#&gt;  7  2013     1     1      555            600        -5      913            854
#&gt;  8  2013     1     1      557            600        -3      709            723
#&gt;  9  2013     1     1      557            600        -3      838            846
#&gt; 10  2013     1     1      558            600        -2      753            745
#&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
#&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>To turn off the effect of <code>attach</code>, call function
<code>detach</code>, passing in the name of the data frame. A more
industrial-strength version of the attach-detach behaviour can be
achieved with function <code>with</code>. This function has some
technical advantages, but has a more complicated syntax. Google for
details if you are interested.</p>
<p>By default, <code>order</code> sorts in ascending order (i.e. from
smallest to largest). To sort in descending order, place - (the negative
sign; the hyphen) in front of an argument to <code>order</code>. We can
again compare this operation in <code>dplyr</code> and base R:</p>
<pre class="r"><code># Descending sort

# dplyr
desc_dep_delay_dplyr &lt;- arrange(flights, desc(dep_delay))

# base R
desc_dep_delay_base &lt;- flights[order(-flights$dep_delay),]

# Check dplyr – the data frame is sorted in descending order of dep_delay
desc_dep_delay_dplyr
#&gt; # A tibble: 336,776 × 19
#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
#&gt;  1  2013     1     9      641            900      1301     1242           1530
#&gt;  2  2013     6    15     1432           1935      1137     1607           2120
#&gt;  3  2013     1    10     1121           1635      1126     1239           1810
#&gt;  4  2013     9    20     1139           1845      1014     1457           2210
#&gt;  5  2013     7    22      845           1600      1005     1044           1815
#&gt;  6  2013     4    10     1100           1900       960     1342           2211
#&gt;  7  2013     3    17     2321            810       911      135           1020
#&gt;  8  2013     6    27      959           1900       899     1236           2226
#&gt;  9  2013     7    22     2257            759       898      121           1026
#&gt; 10  2013    12     5      756           1700       896     1058           2020
#&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
#&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;

# Check base – the data frame is sorted in descending order of dep_delay
desc_dep_delay_base
#&gt; # A tibble: 336,776 × 19
#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
#&gt;  1  2013     1     9      641            900      1301     1242           1530
#&gt;  2  2013     6    15     1432           1935      1137     1607           2120
#&gt;  3  2013     1    10     1121           1635      1126     1239           1810
#&gt;  4  2013     9    20     1139           1845      1014     1457           2210
#&gt;  5  2013     7    22      845           1600      1005     1044           1815
#&gt;  6  2013     4    10     1100           1900       960     1342           2211
#&gt;  7  2013     3    17     2321            810       911      135           1020
#&gt;  8  2013     6    27      959           1900       899     1236           2226
#&gt;  9  2013     7    22     2257            759       898      121           1026
#&gt; 10  2013    12     5      756           1700       896     1058           2020
#&gt; # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
#&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
</div>
<div id="creating-new-columns" class="section level2">
<h2>Creating new columns</h2>
<p>In <code>dplyr</code> we use function <code>mutate</code> to create
new columns. In base R, we simply assign the new column directly to the
data frame, using $. Each new column must be created in a separate
statement. In the code below, we will compare the two techniques. In
both approaches we will begin by making a copy of data frame flights,
before we start to modify it. This is common practice so that you always
have a clean copy of your original data.</p>
<pre class="r"><code>
# dplyr

# Make a copy
flights_dplyr &lt;- flights

# Add new columns with mutate
flights_dplyr &lt;- mutate(flights_dplyr, gain=dep_delay - arr_delay, speed = distance / air_time * 60)


# base R

# Make a copy
flights_base &lt;- flights

# Add the new columns
attach(flights_base)
#&gt; The following objects are masked from flights:
#&gt; 
#&gt;     air_time, arr_delay, arr_time, carrier, day, dep_delay, dep_time,
#&gt;     dest, distance, flight, hour, minute, month, origin,
#&gt;     sched_arr_time, sched_dep_time, tailnum, time_hour, year
flights_base$gain &lt;- dep_delay - arr_delay
flights_base$speed &lt;- distance / air_time * 60

# Compare using base R selection
# Ask for columns gain and speed for rows 1 to 15
# They are the same
flights_dplyr[1:5, c(&quot;gain&quot;, &quot;speed&quot;)]
#&gt; # A tibble: 5 × 2
#&gt;    gain speed
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1    -9  370.
#&gt; 2   -16  374.
#&gt; 3   -31  408.
#&gt; 4    17  517.
#&gt; 5    19  394.
flights_base[1:5, c(&quot;gain&quot;, &quot;speed&quot;)]
#&gt; # A tibble: 5 × 2
#&gt;    gain speed
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1    -9  370.
#&gt; 2   -16  374.
#&gt; 3   -31  408.
#&gt; 4    17  517.
#&gt; 5    19  394.</code></pre>
</div>
<div id="grouping-and-summarising" class="section level2">
<h2>Grouping and Summarising</h2>
<p>With <code>dplyr</code> we take group summaries (e.g. getting the
average arrival for all flights in each month) by using
<code>group_by</code> to group the data frame (gather the rows together
by month) and <code>summarise</code> to apply the summary function (take
the average for each month). In base R both of these steps are handled
by the single function <code>aggregate</code>. This function takes four
arguments:</p>
<table>
<thead>
<tr class="header">
<th>Arg name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x</td>
<td>The name of the data frame</td>
</tr>
<tr class="even">
<td>by</td>
<td>A list of columns to group by</td>
</tr>
<tr class="odd">
<td>FUN</td>
<td>The name of the summary function to apply</td>
</tr>
<tr class="even">
<td>na.rm</td>
<td>Set to TRUE is you want to ignore missing values</td>
</tr>
</tbody>
</table>
<p>The only new part is the syntax used to declare a list for argument
<strong>by</strong>. We will first look at an example of how to take
group means in both <code>dplyr</code> and base R, and then discuss the
list in more detail.</p>
<pre class="r"><code># Compute the average arrival delay, collapsed across months

# Using dplyr

# Group by month
by_month &lt;- group_by(flights, month)

# Take the means
mean_delay_by_month_dplyr &lt;- summarise(by_month, MeanDelay = mean(arr_delay, na.rm = TRUE))

# Check the output
mean_delay_by_month_dplyr
#&gt; # A tibble: 12 × 2
#&gt;    month MeanDelay
#&gt;    &lt;int&gt;     &lt;dbl&gt;
#&gt;  1     1     6.13 
#&gt;  2     2     5.61 
#&gt;  3     3     5.81 
#&gt;  4     4    11.2  
#&gt;  5     5     3.52 
#&gt;  6     6    16.5  
#&gt;  7     7    16.7  
#&gt;  8     8     6.04 
#&gt;  9     9    -4.02 
#&gt; 10    10    -0.167
#&gt; 11    11     0.461
#&gt; 12    12    14.9



# Using base R function aggregate
mean_delay_by_month_base &lt;- aggregate(x = flights$arr_delay, 
                                      by = list(Month = flights$month),
                                      FUN = mean,
                                      na.rm = TRUE)


# Check the output
mean_delay_by_month_base
#&gt;    Month          x
#&gt; 1      1  6.1299720
#&gt; 2      2  5.6130194
#&gt; 3      3  5.8075765
#&gt; 4      4 11.1760630
#&gt; 5      5  3.5215088
#&gt; 6      6 16.4813296
#&gt; 7      7 16.7113067
#&gt; 8      8  6.0406524
#&gt; 9      9 -4.0183636
#&gt; 10    10 -0.1670627
#&gt; 11    11  0.4613474
#&gt; 12    12 14.8703553</code></pre>
<p>Use function <code>list</code> to create the value for argument
<code>by</code> . This function is like the combine function for
vectors, except it creates a collection of <em>named elements</em>. We
often see the function in situations like this:</p>
<pre class="r"><code># A list is a collection of named elements
pet_data &lt;- list(PetName = &quot;Snoopy&quot;, PetOwner = &quot;Charlie Brown&quot;, PetBreed = &quot;Beagle&quot;)
pet_data
#&gt; $PetName
#&gt; [1] &quot;Snoopy&quot;
#&gt; 
#&gt; $PetOwner
#&gt; [1] &quot;Charlie Brown&quot;
#&gt; 
#&gt; $PetBreed
#&gt; [1] &quot;Beagle&quot;</code></pre>
<p>When using <code>aggregate</code> you create a list of columns that
you want to group by. The names of the columns will be the column
headers for the output table of summarised results. To group by multiple
columns, add more elements to the list. For example, if we wanted the
average delay by month <em>for each origin airport separately</em> we
would say:</p>
<pre class="r"><code># Compute the average arrival delay, collapsed across months, separately for
# each origin airport. There are 3 airports and 12 months, so we expect to 
# get 36 means.

# Using dplyr

# Group by month and origin
by_month_origin &lt;- group_by(flights, month, origin)

# Take the means
mean_month_origin_dplyr &lt;- summarise(by_month_origin, MeanDelay = mean(arr_delay, na.rm = TRUE))
#&gt; `summarise()` has grouped output by &#39;month&#39;. You can override using the
#&gt; `.groups` argument.

# Check the output
mean_month_origin_dplyr
#&gt; # A tibble: 36 × 3
#&gt; # Groups:   month [12]
#&gt;    month origin MeanDelay
#&gt;    &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt;
#&gt;  1     1 EWR        12.8 
#&gt;  2     1 JFK         1.37
#&gt;  3     1 LGA         3.38
#&gt;  4     2 EWR         8.78
#&gt;  5     2 JFK         4.39
#&gt;  6     2 LGA         3.15
#&gt;  7     3 EWR        10.6 
#&gt;  8     3 JFK         2.58
#&gt;  9     3 LGA         3.74
#&gt; 10     4 EWR        14.1 
#&gt; # … with 26 more rows



# Using base R function aggregate
mean_month_origin_base &lt;- aggregate(x = flights$arr_delay, 
                                      by = list(Month = flights$month, Origin = flights$origin),
                                      FUN = mean,
                                      na.rm = TRUE)


# Check the output. Note that dplyr and base R sort the output in different orders
mean_month_origin_base
#&gt;    Month Origin          x
#&gt; 1      1    EWR 12.8165557
#&gt; 2      2    EWR  8.7751603
#&gt; 3      3    EWR 10.6007988
#&gt; 4      4    EWR 14.1433877
#&gt; 5      5    EWR  5.3819276
#&gt; 6      6    EWR 16.8635990
#&gt; 7      7    EWR 15.4602015
#&gt; 8      8    EWR  6.7123423
#&gt; 9      9    EWR -4.7299722
#&gt; 10    10    EWR  2.6047372
#&gt; 11    11    EWR  0.6724982
#&gt; 12    12    EWR 19.6397450
#&gt; 13     1    JFK  1.3683977
#&gt; 14     2    JFK  4.3910328
#&gt; 15     3    JFK  2.5808150
#&gt; 16     4    JFK  7.0115389
#&gt; 17     5    JFK  2.1229773
#&gt; 18     6    JFK 17.5969288
#&gt; 19     7    JFK 20.1902224
#&gt; 20     8    JFK  5.9108409
#&gt; 21     9    JFK -4.4630178
#&gt; 22    10    JFK -3.5859719
#&gt; 23    11    JFK -0.8728745
#&gt; 24    12    JFK 12.6775748
#&gt; 25     1    LGA  3.3824023
#&gt; 26     2    LGA  3.1473894
#&gt; 27     3    LGA  3.7384982
#&gt; 28     4    LGA 12.0385817
#&gt; 29     5    LGA  2.7963764
#&gt; 30     6    LGA 14.7692779
#&gt; 31     7    LGA 14.1815696
#&gt; 32     8    LGA  5.4078014
#&gt; 33     9    LGA -2.8253950
#&gt; 34    10    LGA  0.1864229
#&gt; 35    11    LGA  1.5511865
#&gt; 36    12    LGA 11.9563716</code></pre>
<p>As before, if you don’t want to type <em>flights$</em> multiple
times, use <code>attach</code>.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>R users are constantly adding new libraries to base R, meaning that
you will probably have several options for doing any job in R. The
various options sometimes have subtle technical differences that will
generate a lot of argument between professional programmers, but are
unlikely to matter much to research scientists. In general, you should
explore the R ecosystem freely and use whatever you like.
<strong>However</strong> on assignments, it is wise to check with the
lecturer before using something that is really different from what is
presented in class. Your lecturer may, for educational reasons, want you
to use specific R tools.</p>
<div id="whats-next" class="section level2">
<h2>What’s Next</h2>
<p>Fill in the module feedback form <a
href="https://tinyurl.com/r4ssp-module-fb"
class="uri">https://tinyurl.com/r4ssp-module-fb</a>.</p>
<p>You may recall that way back in the first module of this mini-course
we said we were going to analyse data. We haven’t really done much of
that yet. So far we have been <em>getting ready</em> to analyse data. In
the next module, we will start really digging into our data with
exploratory analysis and descriptive statistics. Because this is not a
statistics course <em>per se</em> we will only be using common general
analyses in the handouts and readings. If, for a project or assignment,
you need to do something more esoteric, just let us know – someone has
probably written an R library for it.</p>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>If you have programmed before in Java or one of the
C-family of languages, you may expect the first row to be <strong>row
0</strong>, not <strong>row 1</strong>, and the first column to be
<strong>column 0</strong>, not <strong>column 1</strong>. Just let go of
that. In R, row and column numbering starts at 1. Different languages,
different rules.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiU3Vic2V0dGluZyIKZGF0ZTogIlNlbWVzdGVyIDEsIDIwMjIiCm91dHB1dDoKICBodG1sX2RvY3VtZW50OgogICAgdG9jOiB0cnVlCiAgICB0b2NfZmxvYXQ6IHRydWUKICAgIHRvY19kZXB0aDogMwogICAgY29kZV9kb3dubG9hZDogdHJ1ZQogICAgY29kZV9mb2xkaW5nOiBzaG93Ci0tLQoKYGBge3Igc2V0dXAsIGluY2x1ZGU9RkFMU0V9CmxpYnJhcnkoa25pdHIpCgprbml0cjo6b3B0c19jaHVuayRzZXQoCiAgY29tbWVudCA9ICIjPiIsCiAgZmlnLnBhdGggPSAiZmlndXJlcy8iLCAjIHVzZSBvbmx5IGZvciBzaW5nbGUgUm1kIGZpbGVzCiAgY29sbGFwc2UgPSBUUlVFLAogIGVjaG8gPSBUUlVFCikKYGBgCgpIYW5kb3V0OiBbSGFuZG91dCAwMyAtIFNlbGVjdGluZyBhbmQgRmlsdGVyaW5nIERhdGFdKGhhbmRvdXQzLmh0bWwpCgpBc3NvY2lhdGVkIHJlYWRpbmc6CgotICAgW1IgZm9yIERhdGEgU2NpZW5jZSAtIENoYXB0ZXIgNV0oaHR0cHM6Ly9yNGRzLmhhZC5jby5uei90cmFuc2Zvcm0uaHRtbCkKCiMjIEludHJvZHVjdGlvbgoKSWYgeW91IGFyZSB3b3JraW5nIHRocm91Z2ggdGhlIHN1Z2dlc3RlZCBtYXRlcmlhbHMgaW4gb3JkZXIsIHlvdSBoYXZlIGp1c3QgY29tcGxldGVkIFsqKkNoYXB0ZXIgNSAtIERhdGEgVHJhbnNmb3JtYXRpb24gKGh0dHBzOi8vcjRkcy5oYWQuY28ubnovdHJhbnNmb3JtLmh0bWwpKipdKGh0dHBzOi8vcjRkcy5oYWQuY28ubnovdHJhbnNmb3JtLmh0bWwpIGZyb20gdGhlIG9ubGluZSB0ZXh0ICpSIGZvciBEYXRhIFNjaWVuY2UqLiBUaGlzIG1hdGVyaWFsIGRlbW9uc3RyYXRlZCBob3cgdG8gdXNlIHRoZSBsaWJyYXJ5ICoqZHBseXIqKiwgb25lIG9mIHRoZSBsaWJyYXJpZXMgaW4gdGhlICoqdGlkeXZlcnNlKiogZmFtaWx5LiBZb3Ugd2lsbCBoYXZlIGxlYXJuZWQgaG93IHRvIHVzZSB0aGUgZml2ZSBjb3JlIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyAtLSBgZmlsdGVyYCwgYGFycmFuZ2VgLCBgc2VsZWN0YCwgYG11dGF0ZWAgYW5kIGBzdW1tYXJpc2VgICh3aXRoIGl0cyBoZWxwZXIgZnVuY3Rpb24gYGdyb3VwX2J5YCkuIFRoZXNlIGZ1bmN0aW9ucyBhbGxvdyB5b3UgdG8gbW9kaWZ5IGFuZCBwZXJmb3JtIHN1bW1hcmllcyBvbiBkYXRhIGZyYW1lcywgYW5kIHRvIHB1bGwgb3V0IHNwZWNpZmljIHBvcnRpb25zIG9mIGRhdGEgZnJhbWVzIGZvciBkZXRhaWxlZCBhbmFseXNpcy4gTGlicmFyeSBgZHBseXJgIGlzIHdpZGVseSB1c2VkLCBhbmQgeW91IHdpbGwgc2VlIG1hbnkgZXhhbXBsZXMgb2YgaXQgaW4gUiBjb2RlIHlvdSBmaW5kIGluIHRoZSB3aWxkLgoKVGhlIGZ1bmN0aW9ucyBpbiBgZHBseXJgIChhbmQgaW4gYWxsIHRoZSBvdGhlciBsaWJyYXJpZXMgaW4gdGhlIHRpZHl2ZXJzZSkgYXJlIHRlY2huaWNhbGx5ICoqd3JhcHBlcnMqKiBhcm91bmQgYmFzZSBSIGNvZGUuIFRoYXQgaXMsIHRoZXkgdGhlbXNlbHZlcyBhcmUgd3JpdHRlbiB1c2luZyBiYXNlIFIgY29tbWFuZHMuIFRodXMgaXQgaXMgcG9zc2libGUgdG8gcGVyZm9ybSBhbGwgdGhlIHNhbWUgdHJhbnNmb3JtYXRpb25zICp3aXRob3V0KiBgZHBseXJgLCBieSB1c2luZyBvbmx5IGJhc2UgUi4gTWFueSBwcm9ncmFtbWVycyBhbmQgcmVzZWFyY2hlcnMgKGluY2x1ZGluZyBzb21lIG9mIHlvdXIgbGVjdHVyZXJzKSBwcmVmZXIgdG8gdXNlIGJhc2UgUiBmb3IgdGhlc2Ugb3BlcmF0aW9ucywgYW5kIHlvdSB3aWxsIGFsc28gc2VlIGl0IG9mdGVuIGluIFIgY29kZSBpbiB0aGUgd2lsZC4gVGhlcmVmb3JlLCBpbiB0aGlzIHN1cHBsZW1lbnRhcnkgaGFuZG91dCwgd2Ugd2lsbCBpbGx1c3RyYXRlIHRoZSBlcXVpdmFsZW50IGJhc2UgUiBzeW50YXggZm9yIHRoZSBgZHBseXJgIGZ1bmN0aW9ucyB5b3UganVzdCBsZWFybmVkLgoKUGVvcGxlIG1ha2UgdGhlIGNob2ljZSBiZXR3ZWVuIGBkcGx5cmAgYW5kIGJhc2UgUiBmb3Igc2V2ZXJhbCByZWFzb25zLiBNYW55IHBlb3BsZSBmaW5kIGBkcGx5cmAgc3ludGF4IGVhc2llciB0byB1c2UsIGJlY2F1c2UgaXQgaXMgbW9yZSAqKnVuaWZvcm0qKi4gVGhhdCBpcywgYWxsIHRoZSBiaWcgZml2ZSBgZHBseXJgIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB1c2UgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBzeW50YXguIEluIGJhc2UgUiwgdGhlcmUgaXMgbW9yZSB2YXJpYXRpb24uIFNjaWVudGlzdHMgd2hvIHdvcmsgd2l0aCB2ZXJ5IGxhcmdlIGRhdGEgc2V0cyBhcmUgb2Z0ZW4gY29uY2VybmVkIGFib3V0IGhvdyBmYXN0IHRoZWlyIGNvZGUgY2FuIGJlIGV4ZWN1dGVkLiBJbiBzb21lIGNhc2VzLCBgZHBseXJgIGV4ZWN1dGVzIG1vcmUgc2xvd2x5IHRoYW4gYmFzZSBSIChiZWNhdXNlIG9mIHRoZSBleHRyYSBjb2RlIHJlcXVpcmVkIGZvciB0aGUgd3JhcHBpbmcpLCBsZWFkaW5nIHRoZXNlIHJlc2VhcmNoZXJzIHRvIHByZWZlciB0aGUgYmFzZSBSIGFwcHJvYWNoLiBCZWNhdXNlIGBkcGx5cmAgaXMgYSByZWxhdGl2ZWx5IG5ldyBhZGRpdGlvbiB0byBSLCBzb21lIHBlb3BsZSBwcmVmZXIgYmFzZSBSIGJlY2F1c2UgdGhleSBsZWFybmVkIGl0IGZpcnN0LCBhbmQgYXJlIGhhcHB5IHRvIGNvbnRpbnVlIHVzaW5nIGl0LgoKVW5sZXNzIHlvdSBhcmUgcmVxdWlyZWQgdG8gdXNlIGEgcGFydGljdWxhciBhcHByb2FjaCAoY2hlY2sgd2l0aCB5b3VyIGxlY3R1cmVyIGlmIHlvdSBhcmUgdW5zdXJlKSwgeW91IGNhbiBjaG9vc2Ugd2hpY2hldmVyIHNldCBvZiBjb21tYW5kcyB5b3UgbGlrZSB1c2luZy4gWW91IGNhbiBldmVuIG1peCBhbmQgbWF0Y2ggdGhlbSAtLSB0aGV5IGdpdmUgdGhlIHNhbWUgcmVzdWx0cywgYW5kIFIgZG9lc24ndCBjYXJlLiBIb3dldmVyLCBpdCBpcyB2ZXJ5IGltcG9ydGFudCB0aGF0IHlvdSBjYW4gKnVuZGVyc3RhbmQqIGJvdGggc3R5bGVzLiBPbmUgb2YgdGhlIGdyZWF0IGJlbmVmaXRzIG9mIHRoZSBSIGVjb3N5c3RlbSBpcyB0aGUgd2lkZSBzaGFyaW5nIG9mIGNvZGUsIGFuZCB5b3UgY2FuJ3QgZnVsbHkgcGFydGljaXBhdGUgaW4gdGhpcyB1bmxlc3MgeW91IGFyZSBjb21mb3J0YWJsZSB3aXRoIGFsbCB0aGUgbWFqb3IgZGlhbGVjdHMuCgpcCgojIyBTZWxlY3Rpb24KCldlIHdpbGwgYmVnaW4gd2l0aCBzZWxlY3Rpb24sIGJlY2F1c2UgaW4gYmFzZSBSLCBpdCBpcyB1c2VkIGJ5IHNvbWUgb2YgdGhlIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRlY2huaXF1ZXMuIFlvdSBoYXZlIGFscmVhZHkgc2VlbiBob3csIGluIGJhc2UgUiwgeW91IGNhbiBzZWxlY3QgYSBzaW5nbGUgY29sdW1uIGZyb20gYSBkYXRhIGZyYW1lIHVzaW5nIGAkYC4gWW91IGhhdmUgc2VlbiBob3cgdG8gc2VsZWN0IGEgc3Vic2V0IG9mIHJvd3MgdXNpbmcgZnVuY3Rpb24gYHN1YnNldGAuIFlvdSBjYW4gbWFrZSBtb3JlIGRldGFpbGVkIHNlbGVjdGlvbnMgZnJvbSBkYXRhIGZyYW1lcyB1c2luZyB0aGUgKipzZWxlY3Rpb24gb3BlcmF0b3IqKiBbIF0uCgpUaGUgZ2VuZXJhbCBzeW50YXggb2YgdGhlIHNlbGVjdGlvbiBvcGVyYXRvciBpczoKCipuYW1lX29mX2RhdGFfZnJhbWVbcm93X2luZm9ybWF0aW9uLCBjb2x1bW5faW5mb3JtYXRpb25dKgoKV2UgcGxhY2UgdGhlIHNxdWFyZSBicmFja2V0cyByaWdodCBhZ2FpbnN0IHRoZSBuYW1lIG9mIHRoZSBkYXRhIGZyYW1lLiBJbnNpZGUgdGhlIHNxdWFyZSBicmFja2V0cyB3ZSBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb3cgb3Igcm93cyB3ZSB3YW50ICh3ZSB3aWxsIHNlZSB0aGUgZXhhY3QgZm9ybWF0IGZvciB0aGlzIGluIGEgbW9tZW50KSwgdGhlbiBhIGNvbW1hLCB0aGVuIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2x1bW4gb3IgY29sdW1ucyB3ZSB3YW50LgoKVGhlcmUgYXJlIGEgdmFyaWV0eSBvZiB3YXlzIHRvIGV4cHJlc3Mgcm93IGFuZCBjb2x1bW4gaW5mb3JtYXRpb24uIFRvIHNlZSBob3cgdGhleSB3b3JrLCBsZXQncyBmaXJzdCBtYWtlIGEgdmVyeSBzaW1wbGUgZGF0YSBmcmFtZSBieSBoYW5kLCBhbmQgdGhlbiBwZXJmb3JtIHNvbWUgc2VsZWN0aW9uIG9wZXJhdGlvbnMgb24gaXQuIEVudGVyIHRoZSBmb2xsb3dpbmcgY29kZSBpbnRvIFJTdHVkaW8gdG8gY3JlYXRlICoqZ2VvZ3JhcGh5X2RmKiouCgpgYGB7ciBtYW51YWwgZGF0YSAxfQpjb3VudHJpZXMgPC0gYygiQXVzdHJpYSIsICJCcmF6aWwiLCAiQ2FuYWRhIiwgIkRlbm1hcmsiKQpjYXBpdGFscyA8LSBjKCJWaWVubmEiLCAiQnJhc2lsaWEiLCAiT3R0YXdhIiwgIkNvcGVuaGFnZW4iKQpwb3B1bGF0aW9uX2luX21pbGxpb25zIDwtIGMoOSwgMjExLCAzOCwgNikKCmdlb2dyYXBoeV9kZiA8LSBkYXRhLmZyYW1lKENvdW50cnkgPSBjb3VudHJpZXMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIENhcGl0YWwgPSBjYXBpdGFscywKICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9wdWxhdGlvbk1pbGxpb25zID0gcG9wdWxhdGlvbl9pbl9taWxsaW9ucykKCmdlb2dyYXBoeV9kZgpgYGAKCkluIHRoZSBzaW1wbGVzdCBmb3JtIG9mIHNlbGVjdGlvbiwgd2Ugd2FudCBqdXN0IG9uZSBzaW5nbGUgdmFsdWUgZnJvbSBhIGRhdGEgZnJhbWUsIHNvIHdlIHByb3ZpZGUgdGhlIHJvdyBudW1iZXIgYW5kIGNvbHVtbiBudW1iZXIgb2YgdGhlIGNlbGwgb2YgaW50ZXJlc3QuIEZvciBleGFtcGxlLCBpbWFnaW5lIHdlIHdhbnQgdGhlIHBvcHVsYXRpb24gb2YgVmllbm5hLiBXZSBrbm93IHRoYXQgVmllbm5hIGlzIGluIHJvdyAxIGFuZCB0aGUgcG9wdWxhdGlvbiBpcyBpbiBjb2x1bW4gMy4gVG8gc2VsZWN0IHRoYXQgY2VsbCB3ZSBwcm92aWRlIDEgZm9yIHRoZSByb3cgaW5mb3JtYXRpb24gYW5kIDMgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gaW4gdGhlIHNxdWFyZSBicmFja2V0czoKCmBgYHtyIHNpbmdsZSBzZWxlY3Rpb259Cmdlb2dyYXBoeV9kZlsxLDNdCmBgYAoKRG9uJ3Qgd29ycnkgYWJvdXQgaG93IHlvdSB3b3VsZCBrbm93IHRoZSBzcGVjaWZpYyByb3cgYW5kIGNvbHVtbiBvZiB0aGUgY2VsbCB5b3UgYXJlIGludGVyZXN0ZWQgaW4uIFRoaXMgcGFydGljdWxhciBzZWxlY3Rpb24gb3BlcmF0aW9uIGlzIHR5cGljYWxseSB1c2VkIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91ciBjb2RlIGlzIGNvbXB1dGluZyB0aG9zZSB2YWx1ZXMgYmFzZWQgb24gY29tcGxleCBjcml0ZXJpYS4gVGhpcyBleGFtcGxlIGlzIG1lcmVseSBpbGx1c3RyYXRpdmUuIFteMV0KClteMV06IElmIHlvdSBoYXZlIHByb2dyYW1tZWQgYmVmb3JlIGluIEphdmEgb3Igb25lIG9mIHRoZSBDLWZhbWlseSBvZiBsYW5ndWFnZXMsIHlvdSBtYXkgZXhwZWN0IHRoZSBmaXJzdCByb3cgdG8gYmUgKipyb3cgMCoqLCBub3QgKipyb3cgMSoqLCBhbmQgdGhlIGZpcnN0IGNvbHVtbiB0byBiZSAqKmNvbHVtbiAwKiosIG5vdCAqKmNvbHVtbiAxKiouIEp1c3QgbGV0IGdvIG9mIHRoYXQuIEluIFIsIHJvdyBhbmQgY29sdW1uIG51bWJlcmluZyBzdGFydHMgYXQgMS4gRGlmZmVyZW50IGxhbmd1YWdlcywgZGlmZmVyZW50IHJ1bGVzLgoKVGhlcmUgYXJlIHR3byB2ZXJ5IHVzZWZ1bCBleHRlbnNpb25zIHRvIHRoaXMgcGF0dGVybjoKCjEuICBFaXRoZXIgdGhlIHJvdyBvciBjb2x1bW4gaW5kZXggKG9yIGJvdGgpIG1heSBzcGVjaWZ5IGEgKipyYW5nZSoqIHVzaW5nIHRoZSA6IG9wZXJhdG9yLiBGb3IgZXhhbXBsZSwgMTozIG9yIDY6MTIgKHRoZXNlIGFyZSAiMSB0byAzIiBhbmQgIjYgdG8gMTIiIHJlc3BlY3RpdmVseSkuCgpgYGB7ciByYW5nZX0KIyBGb3Igcm93cyAyIHRvIDQgKEJyYXppbCwgQ2FuYWRhLCBEZW5tYXJrKSwgc2VsZWN0IHRoZSBwb3B1bGF0aW9uIChjb2x1bW4gMykKZ2VvZ3JhcGh5X2RmWzI6NCwgM10KCiMgRm9yIENhbmFkYSAocm93IDMpLCBzZWxlY3QgYm90aCB0aGUgY2FwaXRhbCBuYW1lIGFuZCBwb3B1bGF0aW9uIChjb2xzIDIgYW5kIDMpCmdlb2dyYXBoeV9kZlszLCAyOjNdCgpgYGAKCjIuICBFaXRoZXIgdGhlIHJvdyBvciBjb2x1bW4gaW5kZXggKiptYXkgYmUgb21pdHRlZCoqLiBUaGF0IGlzLCB3ZSBjYW4gc2F5IGBnZW9ncmFwaHlfZGZbMyAsIF1gIG9yIGBnZW9ncmFwaHlfZGZbICwgMl1gLiBUaGUgbWlzc2luZyBlbGVtZW50IGlzIGludGVycHJldGVkIGFzICoqYWxsKiouIE9taXQgdGhlIHJvdyBudW1iZXIgYW5kIHlvdSB3YW50ICoqYWxsIHJvd3MqKiBpbiB0aGUgc3VwcGxpZWQgY29sdW1uKHMpLiBPbWl0IHRoZSBjb2x1bW4gbnVtYmVyIGFuZCB5b3Ugd2FudCAqKmFsbCBjb2x1bW5zKiogaW4gdGhlIHN1cHBsaWVkIHJvdyhzKS4KCmBgYHtyIG9taXR0ZWQgaW5kZXh9CgojIEZvciBEZW5tYXJrIChyb3cgNCksIHNlbGVjdCBhbGwgdGhlIGNvbHVtbnMKZ2VvZ3JhcGh5X2RmWzQsIF0KCiMgRm9yIGFsbCByb3dzLCBzZWxlY3QgdGhlIGNhcGl0YWwgY2l0eSBuYW1lIChjb2x1bW4gMikKZ2VvZ3JhcGh5X2RmWyAsIDJdCgpgYGAKCllvdSBtYXkgaGF2ZSBiZWVuIHN1cnByaXNlZCBieSB0aGUgb3V0cHV0IGdlbmVyYXRlZCBieSB0aGF0IGxhc3QgZXhhbXBsZS4gQWx0aG91Z2ggeW91IGhhdmUgc2VsZWN0ZWQgYSBzaW5nbGUgY29sdW1uLCB0aGUgb3V0cHV0IGlzIHByaW50ZWQgaG9yaXpvbnRhbGx5LCBhcyB0aG91Z2ggaXQgd2VyZSBhIHJvdy4gVGhpcyBpcyBhIHBlY3VsaWFyaXR5IG9mIFIuIEFueSBjb2xsZWN0aW9uIHRoYXQgaGFzIGEgc2luZ2xlIGRpbWVuc2lvbiAoaS5lLiBkb2Vzbid0IGhhdmUgYm90aCBjb2x1bW5zIGFuZCByb3dzKSBpcyB0cmVhdGVkIGFzIGEgcGxhaW4gdmVjdG9yLiBBbmQgdmVjdG9ycyBhcmUgYWx3YXlzIHByaW50ZWQgaG9yaXpvbnRhbGx5LiBCeSBleHRlbnNpb24sIHNpbmNlIGEgc2VsZWN0ZWQgY29sdW1uIG9mIGEgZGF0YSBmcmFtZSBpcyBhIHZlY3RvciwgeW91IGNhbiBhcHBseSBldmVyeXRoaW5nIHlvdSBoYXZlIGxlYXJuZWQgYWJvdXQgdmVjdG9ycyB0byBzZWxlY3RlZCBkYXRhIGZyYW1lIGNvbHVtbnMsIHdoaWNoIGlzIGV4YWN0bHkgd2hhdCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gZG8uCgpZb3UgY2FuIGNvbWJpbmUgcmFuZ2VzIGFuZCB0aGUgKm1pc3NpbmcgaW5kZXggPSBhbGwqIHRlY2huaXF1ZToKCmBgYHtyIHRvZ2V0aGVyfQojIEZvciB0aGUgZmlyc3QgdGhyZWUgcm93cywgc2VsZWN0IGFsbCB0aGUgY29sdW1ucwpnZW9ncmFwaHlfZGZbMTozICwgXQoKYGBgCgpBcyBhbiBleGVyY2lzZSwgd2hhdCBkbyB5b3UgdGhpbmsgYGdlb2dyYXBoeV9kZlsgLCBdYCAoaS5lLiB3aGVyZSBib3RoIHJvdyBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGFyZSBvbWl0dGVkKSB3aWxsIGRvPyBUcnkgaXQuIFdlcmUgeW91IHJpZ2h0PwoKSW5zdGVhZCBvZiB1c2luZyBjb2x1bW4gbnVtYmVycywgeW91IGNhbiBwcm92aWRlIGNvbHVtbiBuYW1lcyBhcyB0aGUgY29sdW1uIGluZm9ybWF0aW9uIChhbmQgcm93IG5hbWVzIGFzIHRoZSByb3cgaW5mb3JtYXRpb24gaWYgeW91ciBkYXRhIGZyYW1lIGhhcyBuYW1lZCByb3dzKS4gVXNlIHRoZSBjb21iaW5lIGZ1bmN0aW9uIGBjKClgIHRvIHByb3ZpZGUgbXVsdGlwbGUgY29sdW1uIG5hbWVzLCBhbmQgYmUgc3VyZSB0byBzdXJyb3VuZCBlYWNoIGNvbHVtbiBuYW1lIHdpdGggcXVvdGVzLCBiZWNhdXNlIFIgY29uc2lkZXJzIHRoZW0gdG8gYmUgc3RyaW5ncyBpbiB0aGlzIHNpdHVhdGlvbi4KCmBgYHtyIG5hbWVkIGNvbHVtbnN9Cmdlb2dyYXBoeV9kZlsyOjQsICJDYXBpdGFsIl0KCmdlb2dyYXBoeV9kZlszOjQsIGMoIkNvdW50cnkiLCAiQ2FwaXRhbCIpXQpgYGAKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgUGVyZm9ybSBkZXNjcmlwdGl2ZSBhbmFseXNlcyBvbiBncm91cHMKCmBgYHtyIGxvYWRfZGF0YX0KIyBMb2FkIHRoZSBsaWJyYXJ5IGJlZm9yZSB0aGUgZmlyc3QgdGltZSB5b3UgY2FsbCByZWFkX2NzdgpsaWJyYXJ5KHJlYWRyKQoKIyBSZWFkIGEgY3N2IGZpbGUgaW50byBSLiBTdG9yZSB0aGUgcmVzdWx0IGluIGEgbmFtZWQgdmFyaWFibGUKcHVwcHlfZG9uYXRpb25zX2RhdGEgPC0gcmVhZF9jc3YoImRhdGEvcjRzc3BfZG9uYXRpb25zX2RhdGEuY3N2IikKCiMgQXMgYWx3YXlzIGluIFIsIHdlIGNhbiBkaXNwbGF5IHRoZSBjb250ZW50cyBvZiBhIHZhcmlhYmxlIGJ5IHNpbXBseSB0eXBpbmcgaXRzIG5hbWUuCnB1cHB5X2RvbmF0aW9uc19kYXRhCgpgYGAKCldlIG9mdGVuIHdpc2ggdG8gc3VtbWFyaXNlIG91ciBkZXBlbmRlbnQgdmFyaWFibGUgZm9yIGFsbCB0aGUgbWVtYmVycyBvZiBhbiBleHBlcmltZW50YWwgZ3JvdXAuIEZvciBleGFtcGxlLCBpbiB0aGlzIHN0dWR5IHdlIG1pZ2h0IHdhbnQgdG8gZmluZCB0aGUgbWVhbiBhbW91bnQgZG9uYXRlZCBmb3IganVzdCB0aG9zZSBjb2xsZWN0b3JzIGluIHRoZSBQdXBweSBncm91cC4gVG8gZG8gdGhpcywgd2UgZmlyc3QgdGFrZSAqKmEgc3Vic2V0Kiogb2YgdGhlIGRhdGEgZnJhbWUuIFRoYXQgaXMsIHdlIHNlcGFyYXRlIG91dCBvbmx5IHRob3NlIHJvd3MgdGhhdCBhcmUgaW4gdGhlIGdyb3VwIG9mIGludGVyZXN0LiBUaGVuIHdlIGNhbiBzdW1tYXJpc2UgaW5kaXZpZHVhbCBjb2x1bW5zIGV4YWN0bHkgYXMgd2UgZGlkIGFib3ZlLCBvcGVyYXRpbmcgb24gb3VyIHBhcnRpYWwgZGF0YSBmcmFtZS4KClRvIHRha2UgYSBzdWJzZXQgb2Ygcm93cyBmcm9tIGEgZGF0YSBmcmFtZSwgdXNlIGZ1bmN0aW9uIGBzdWJzZXRgLiBUaGlzIGZ1bmN0aW9uIHRha2VzIHR3byBhcmd1bWVudHM6IGZpcnN0LCB0aGUgbmFtZSBvZiB0aGUgZGF0YSBmcmFtZSBmcm9tIGZyb20gd2hpY2ggeW91IGFyZSBzZXBhcmF0aW5nIG91dCByb3dzOyBzZWNvbmQsIHRoZSBjcml0ZXJpb24geW91IHdpc2ggdG8gdXNlIHRvIHNlbGVjdCB5b3VyIHN1YnNldC4gSW4gdGhpcyBleGFtcGxlIHdlIHdpc2ggdG8gc2VsZWN0IG91dCBhbGwgdGhlIHJvd3MgZm9yIHdoaWNoIHRoZSBDb25kaXRpb24gY29sdW1uIHZhbHVlIGlzICJQdXBweSIuIEluIFIgd2UgZGVzY3JpYmUgdGhpcyBjcml0ZXJpb24gd2l0aCBgQ29uZGl0aW9uID09ICJQdXBweSJgLiBOb3RlIHRoZSBkb3VibGUgZXF1YWwgc2lnbiAqKj09KiouIFRoaXMgaXMgdmVyeSBpbXBvcnRhbnQuIEEgc2luZ2xlIGVxdWFsIHNpZ24gaGVyZSBtZWFucyBzb21ldGhpbmcgZWxzZSwgYW5kIHdpbGwgbm90IHdvcmsgYXQgYWxsLiBUaGUgY29tcGxldGUgY29kZSB0byBzZWxlY3QgYWxsIHRoZSBjb2xsZWN0b3JzIHdobyBoYWQgcHVwcGllcyBpczoKCmBgYHtyIHNlbGVjdEdyb3VwfQpzdWJzZXQocHVwcHlfZG9uYXRpb25zX2RhdGEsIENvbmRpdGlvbiA9PSAiUHVwcHkiKQpgYGAKCkFzIGFsd2F5cywgaXQgd2lsbCBtYWtlIG91ciBjb2RlIHRpZGllciB0byBzYXZlIHRoZSBvdXRwdXQgaW4gYSBuYW1lZCB2YXJpYWJsZSBmb3IgbGF0ZXIgdXNlLgoKYGBge3Igc2F2ZUdyb3VwfQpwdXBwaWVzX29ubHkgPC0gc3Vic2V0KHB1cHB5X2RvbmF0aW9uc19kYXRhLCBDb25kaXRpb24gPT0gIlB1cHB5IikKcHVwcGllc19vbmx5CmBgYAoKV2UgY2FuIHNlbGVjdCBjb2x1bW5zIGZyb20gb3VyIG5ldyBwYXJ0aWFsIGRhdGEgZnJhbWUgYW5kIGNvbXB1dGUgc3VtbWFyeSBzdGF0aXN0aWNzIGZvciBhIGNvbHVtbiBvZiBpbnRlcmVzdCBqdXN0IGFzIHdlIGRpZCBhYm92ZToKCmBgYHtyIHN1YnNldFN1bW1hcnl9Cm1lYW4ocHVwcGllc19vbmx5JEFtb3VudCkKc2QocHVwcGllc19vbmx5JEFtb3VudCkKYGBgCgpSIGhhcyBhIHZlcnkgcmljaCBzeXN0ZW0gZm9yIGRlZmluaW5nIHNlbGVjdGlvbiBjcml0ZXJpYSB3aGVuIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBzdWJzZXRgLiBJbiBhZGRpdGlvbiB0byBjaGVja2luZyB3aGV0aGVyIG9uZSB2YWx1ZSBlcXVhbHMgYW5vdGhlciB3aXRoIGA9PWAsIGFzIGFib3ZlLCB5b3UgY2FuIHVzZSBhbGwgdGhlIHVzdWFsIGxvZ2ljYWwgY29tcGFyaXNvbnMgbGlrZSBsZXNzIHRoYW4sIGdyZWF0ZXIgdGhhbiwgbGVzcyB0aGFuIG9yIGVxdWFsIHRvLCBldGMuCgp8IE9wZXJhdGlvbiAgICAgICAgICAgICAgICB8IFIgU3ltYm9sIHwKfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS18CnwgTGVzcyB0aGFuICAgICAgICAgICAgICAgIHwgXDwgICAgICAgfAp8IExlc3MgdGhhbiBvciBlcXVhbCB0byAgICB8IFw8PSAgICAgIHwKfCBHcmVhdGVyIHRoYW4gICAgICAgICAgICAgfCBcPiAgICAgICB8CnwgR3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHwgXD49ICAgICAgfAp8IE5vdCBlcXVhbCB0byAgICAgICAgICAgICB8ICE9ICAgICAgIHwKCkZvciBleGFtcGxlLCB3ZSBjb3VsZCB1c2UgYW55IG9mIHRoZSBmb2xsb3dpbmcgYXMgdGhlIHNlY29uZCBjb25kaXRpb24gb2Ygb3VyIGNhbGwgdG8gYHN1YnNldGA6Cgp8IFIgU3RhdGVtZW50ICAgICAgICAgIHwgTWVhbmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfAp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwKfCBBbW91bnQgXDwgMTAwICAgICAgICB8IFNlbGVjdCBhbGwgcm93cyB0aGF0IGhhdmUgQW1vdW50IGxlc3MgdGhhbiAxMDAgICAgICAgICAgICAgICAgIHwKfCBBbW91bnQgXD49IDUwICAgICAgICB8IFNlbGVjdCBhbGwgcm93cyB0aGF0IGhhdmUgQW1vdW50IGdyZWF0ZXIgdGhhbiwgb3IgZXF1YWwgdG8sIDUwIHwKfCBDb25kaXRpb24gIT0gIlB1cHB5IiB8IFNlbGVjdCBhbGwgcm93cyBpbiB3aGljaCBDb25kaXRpb24gaXMgbm90IGVxdWFsIHRvICJQdXBweSIgICAgIHwKCkl0IGlzIGFsc28gcG9zc2libGUgdG8gY29tYmluZSB0aGVzZSAqKmxvZ2ljYWwgb3BlcmF0aW9ucyoqLiBZb3UgY291bGQsIGZvciBleGFtcGxlLCBhc2sgZm9yIG9ubHkgdGhvc2Ugcm93cyB3aGVyZSBDb25kaXRpb24gd2FzICJBbG9uZSIgYW5kIEFtb3VudCB3YXMgZ3JlYXRlciB0aGFuIDEwMC4gR29vZ2xlICJSIGxvZ2ljYWwgb3BlcmF0aW9ucyIgdG8gZmluZCBvdXQgbW9yZS4KCkluIG91ciBuZXh0IG1vZHVsZSwgd2hlbiB3ZSBiZWdpbiB0aGUgdXNlIHRoZSAqKnRpZHl2ZXJzZSoqIGxpYnJhcnksIHdlIHdpbGwgbGVhcm4gYWRkaXRpb25hbCB2ZXJ5IGVmZmljaWVudCB0ZWNobmlxdWVzIGZvciBzZWxlY3Rpbmcgc3Vic2V0cyBvZiBpbnRlcmVzdCBmcm9tIGEgbGFyZ2UgZGF0YSBzZXQuCgojIyMgVGltZSB0byBXcml0ZSBZb3VyIE93biBDb2RlCgpSZXBlYXQgdGhlIGFuYWx5c2lzIGFib3ZlLCBidXQgc3VtbWFyaXNlIG9ubHkgdGhvc2Ugc3ViamVjdHMgaW4gdGhlICpBbG9uZSogZ3JvdXAgKHRob3NlIGNvbGxlY3RvcnMgd2hvIGhhZCBubyBwdXBwaWVzKS4gWW91ciByZXN1bHRzIHNob3VsZCBiZSBhcyBzaG93biBiZWxvdy4gRG8gbm90IG1vdmUgYWhlYWQgaW4gdGhpcyBkb2N1bWVudCB1bnRpbCB5b3UgY2FuIGdlbmVyYXRlIHRoZXNlIHZhbHVlcyBieSB1c2luZyBgc3Vic2V0YCwgYCRgLCBgbWVhbmAsIGFuZCBgc2RgLiBJZiB5b3UgbmVlZCBoZWxwLCBsZXQgdXMga25vdy4KCmBgYHtyIEFsb25lLCBlY2hvPUZBTFNFfQoKYWxvbmVfb25seSA8LSBzdWJzZXQocHVwcHlfZG9uYXRpb25zX2RhdGEsIENvbmRpdGlvbiA9PSAiQWxvbmUiKQpwYXN0ZSgiTWVhbjoiLCByb3VuZChtZWFuKGFsb25lX29ubHkkQW1vdW50KSw0KSkKcGFzdGUoIlN0YW5kYXJkIGRldmlhdGlvbjoiLCByb3VuZChzZChhbG9uZV9vbmx5JEFtb3VudCksNCkpCmBgYAoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpUbyBzZWUgaG93IHNlbGVjdGlvbiB3aXRoIHRoZSBgc2VsZWN0YCBmdW5jdGlvbiBmcm9tIGBkcGx5cmAgY29tcGFyZXMgdG8gc2VsZWN0aW9uIHdpdGggdGhlIHNlbGVjdGlvbiBvcGVyYXRvciBbIF0gaW4gYmFzZSBSLCBsZXQncyBsb2FkIHRoZSAqKmZsaWdodHMqKiBkYXRhIGZyYW1lIGFuZCByZXBlYXQgc29tZSBvZiB0aGUgZXhlcmNpc2VzIGZyb20gKlIgZm9yIERhdGEgU2NpZW5jZSouCgpgYGB7ciBsb2FkIGZsaWdodHMsIHdhcm5pbmc9RkFMU0V9CgojIExvYWQgdGhlIGxpYnJhcnkgdGhhdCBjb250YWlucyB0aGUgZmxpZ2h0cyBkYXRhIGZyYW1lCmxpYnJhcnkobnljZmxpZ2h0czEzKQoKIyBMb2FkIGRwbHlyCmxpYnJhcnkoZHBseXIpCgoKCiMgU2VsZWN0IHRoZSB5ZWFyLCBtb250aCwgYW5kIGRheSBjb2x1bW5zIGZyb20gdGhlIGZsaWdodHMgZGF0YSBmcmFtZQoKIyBXaXRoIGRwbHlyCnllYXJfbW9udGhfZGF5X2NvbHNfZHBseXIgPC0gc2VsZWN0KGZsaWdodHMsIHllYXIsIG1vbnRoLCBkYXkpCnllYXJfbW9udGhfZGF5X2NvbHNfZHBseXIKCiMgV2l0aCBiYXNlIFIKeWVhcl9tb250aF9kYXlfY29sc19iYXNlIDwtIGZsaWdodHNbICwgYygieWVhciIsICJtb250aCIsICJkYXkiKV0KeWVhcl9tb250aF9kYXlfY29sc19iYXNlCmBgYAoKXAoKIyMgU3Vic2V0dGluZwoKVGhlIGBkcGx5cmAgZnVuY3Rpb24gYGZpbHRlcmAgaXMgYW5hbG9nb3VzIHRvIHRoZSBiYXNlIFIgZnVuY3Rpb24gYHN1YnNldGAuIFRoZSB0d28gZnVuY3Rpb25zIGhhdmUgaWRlbnRpY2FsIHN5bnRheC4gV2UgY2FuIHNlZSBob3cgc29tZSBvZiB0aGUgYGRwbHlyYCBmaWx0ZXIgb3BlcmF0aW9ucyBmcm9tIHRoZSBwcmV2aW91cyBzZWN0aW9uIHdvdWxkIGJlIHdyaXR0ZW4gdXNpbmcgYmFzZSBSLiBJZiB5b3Ugd2lzaCwgcnVuIHRoaXMgY29kZSBpbiBSU3R1ZGlvLCBhbmQgaW5zcGVjdCB0aGUgcmVzdWx0cyBvZiBlYWNoIHN0YXRlbWVudC4KCmBgYHtyIGZpbHRlciBhbmQgc3Vic2V0fQoKIyBJbiBhbGwgY2FzZXMsIHRoZXNlIHBhaXJzIG9mIGNvbW1hbmRzIHByb2R1Y2UgdGhlIHNhbWUgb3V0cHV0CiMgSW4gZWFjaCBwYWlyLCB0aGUgZmlyc3QgdmVyc2lvbiBpcyBkcGx5ciBhbmQgdGhlIHNlY29uZAojIGlzIGJhc2UgUgoKIyBBbGwgZmxpZ2h0cyB3aXRoIGFycml2YWwgZGVsYXkgPj0gMTIwIG1pbnV0ZXMKbGF0ZV9kcGx5ciA8LSBmaWx0ZXIoZmxpZ2h0cywgYXJyX2RlbGF5ID4gMTIwKQpsYXRlX2Jhc2UgPC0gc3Vic2V0KGZsaWdodHMsIGFycl9kZWxheSA+IDEyMCkKCiMgRmxldyB0byBJQUggb3IgSE9VCmhvdXN0b25fZHBseXIgPC0gZmlsdGVyKGZsaWdodHMsIGRlc3QgPT0gIklBSCIgfCBkZXN0ID09ICJIT1UiKQpob3VzdG9uX2Jhc2UgPC0gc3Vic2V0KGZsaWdodHMsIGRlc3QgPT0gIklBSCIgfCBkZXN0ID09ICJIT1UiKQoKIyBBbHRlcm5hdGl2ZWx5LCB1c2luZyAlaW4lLCB3aGljaCByZXF1aXJlcyBsZXNzIHR5cGluZwpob3VzdG9uX2RwbHlyIDwtIGZpbHRlcihmbGlnaHRzLCBkZXN0ICVpbiUgYygiSUFIIiwgIkhPVSIpKQpob3VzdG9uX2Jhc2UgPC0gc3Vic2V0KGZsaWdodHMsIGRlc3QgJWluJSBjKCJJQUgiLCAiSE9VIikpCgojIFNlbGVjdCByb3dzIHdpdGggbWlzc2luZyB2YWx1ZXMgdXNpbmcgaXMubmEoKSAKbWlzc2luZ19kZXBfdGltZV9kcGx5ciA8LSBmaWx0ZXIoZmxpZ2h0cywgaXMubmEoZGVwX3RpbWUpKQptaXNzaW5nX2RlcF90aW1lX2Jhc2UgPC0gc3Vic2V0KGZsaWdodHMsIGlzLm5hKGRlcF90aW1lKSkKYGBgCgpCYXNlIFIgZG9lcyBub3QgaGF2ZSB0aGUgaGVscGVyIGZ1bmN0aW9uIGBiZXR3ZWVuYCwgYnV0IHRoZSBzYW1lIHJlc3VsdCBjYW4gYmUgYWNoaWV2ZWQgaW4gYSBudW1iZXIgb2Ygd2F5czoKCmBgYHtyIGJldHdlZW59CiMgQmV0d2VlbgoKIyBUaGVzZSBmb3VyIGNvbW1hbmRzIGFsbCBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdAoKIyBkcGx5cgpzdW1tZXJfZHBseXIgPC0gZmlsdGVyKGZsaWdodHMsIGJldHdlZW4obW9udGgsIDcsIDkpKQoKIyBiYXNlIFIKc3VtbWVyX2Jhc2VfMDEgPC0gc3Vic2V0KGZsaWdodHMsIG1vbnRoICVpbiUgYyg3LDgsOSkpCnN1bW1lcl9iYXNlXzAyIDwtIHN1YnNldChmbGlnaHRzLCBtb250aCAlaW4lIDc6OSkKc3VtbWVyX2Jhc2VfMDMgPC0gc3Vic2V0KGZsaWdodHMsIG1vbnRoID49NyAmIG1vbnRoIDw9IDkpCmBgYAoKV2hlbiB5b3UgaGF2ZSBtdWx0aXBsZSBvcHRpb25zIGZvciBwZXJmb3JtaW5nIGEgY29tcHV0YXRpb24sIHRoZSBnZW5lcmFsIGdvYWwgaXMgdG8gc3RyaWtlIGEgYmFsYW5jZSBiZXR3ZWVuICoqcGFyc2ltb255KiogKG5vdCB0b28gbXVjaCB0eXBpbmcpIGFuZCAqKnJlYWRhYmlsaXR5KiogKHlvdXIgY29kZSBpcyBlYXN5ICpmb3Igb3RoZXIgcGVvcGxlKiB0byB1bmRlcnN0YW5kKS4gV2hlbiB3b3JraW5nIG9uIGdyb3VwIHByb2plY3RzLCBvciBpbiBhIHByb2Zlc3Npb25hbCBzb2Z0d2FyZSBkZXZlbG9wbWVudCBjb250ZXh0LCByZWFkYWJsaXR5IGlzIGNvbnNpZGVyZWQgdGhlIG1vcmUgY3JpdGljYWwgb2YgdGhlIHR3byBmZWF0dXJlcy5cCgojIyBBcnJhbmdpbmcgKHNvcnRpbmcpCgpUaGUgYGRwbHlyYCBmdW5jdGlvbiBgYXJyYW5nZWAgaXMgYW5hbG9nb3VzIHRvIGJhc2UgUiBzZWxlY3Rpb24gdXNpbmcgWyBdIGNvbWJpbmVkIHdpdGggZnVuY3Rpb24gYG9yZGVyYC4gV2UgdXNlIGBvcmRlcmAgYXMgdGhlIHJvdyBpbmZvcm1hdGlvbiB0byBbIF0uIFRoZSBhcmd1bWVudHMgdG8gYG9yZGVyYCBhcmUgYSBjb21tYSBzZXBhcmF0ZWQgc2VxdWVuY2Ugb2YgdGhlIGNvbHVtbnMgb24gd2hpY2ggd2Ugd2lzaCB0byBzb3J0LiBXZSBpZGVudGlmeSB0aGUgY29sdW1ucyB1c2luZyB0aGUgXCQgb3BlcmF0b3IsIGluIHRoZSB1c3VhbCB3YXkuCgpGb3IgZXhhbXBsZSwgdGhlIGBkcGx5cmAgc3RhdGVtZW50IGFuZCB0aGUgYmFzZSBSIHN0YXRlbWVudCBiZWxvdyBib3RoIHNvcnQgdGhlIGVudGlyZSBmbGlnaHQgZGF0YSBmcmFtZSBvbiB0aGUgeWVhciwgbW9udGgsIGFuZCBkYXkgY29sdW1uczoKCmBgYHtyIG9yZGVyfQoKIyBTb3J0IHVzaW5nIGFycmFuZ2Ugb3Igb3JkZXIKCiMgZHBseXIKeWVhcl9tb250aF9kYXlfZHBseXIgPC0gYXJyYW5nZShmbGlnaHRzLCB5ZWFyLCBtb250aCwgZGF5KQoKIyBiYXNlIFIg4oCTIHdlIG9taXQgdGhlIGNvbHVtbiBpbmRleCB0byBnZXQgYWxsIGNvbHVtbnMgaW4gdGhlIHJlc3VsdAp5ZWFyX21vbnRoX2RheV9iYXNlIDwtIGZsaWdodHNbb3JkZXIoZmxpZ2h0cyR5ZWFyLCBmbGlnaHRzJG1vbnRoLCBmbGlnaHRzJGRheSksIF0gCgojIENvbXBhcmUgdGhlIHJlc3VsdHMKeWVhcl9tb250aF9kYXlfZHBseXIKeWVhcl9tb250aF9kYXlfYmFzZQoKYGBgCgpJZiB5b3UgZmluZCBpdCB0aXJlc29tZSB0byB0eXBlIHRoZSBuYW1lIG9mIHRoZSBkYXRhIGZyYW1lIGluIGZyb250IG9mIGVhY2ggY29sdW1uIGluIGBvcmRlcmAsIHVzZSBmdW5jdGlvbiBgYXR0YWNoYC4gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgZGF0YSBmcmFtZSBhcyBpdHMgYXJndW1lbnQuIEluIGFsbCBzdWJzZXF1ZW50IGNvZGUsIHlvdSBjYW4gcmVmZXIgdG8gY29sdW1ucyBvZiB0aGUgZGF0YSBmcmFtZSB3aXRob3V0IGhhdmluZyB0byBwcmVmYWNlIHRoZW0gd2l0aCB0aGUgZGF0YSBmcmFtZSBuYW1lIGFuZCBcJDoKCmBgYHtyIGF0dGFjaH0KCiMgQ2FsbCBhdHRhY2gKYXR0YWNoKGZsaWdodHMpCgojIEp1c3QgdXNlIHRoZSBjb2x1bW4gbmFtZXM7IG5vIGZsaWdodHMkIG5lZWRlZAp5ZWFyX21vbnRoX2RheV9iYXNlIDwtIGZsaWdodHNbb3JkZXIoeWVhciwgbW9udGgsIGRheSksIF0KCiMgQ2hlY2sgdGhlIHJlc3VsdAp5ZWFyX21vbnRoX2RheV9iYXNlCmBgYAoKVG8gdHVybiBvZmYgdGhlIGVmZmVjdCBvZiBgYXR0YWNoYCwgY2FsbCBmdW5jdGlvbiBgZGV0YWNoYCwgcGFzc2luZyBpbiB0aGUgbmFtZSBvZiB0aGUgZGF0YSBmcmFtZS4gQSBtb3JlIGluZHVzdHJpYWwtc3RyZW5ndGggdmVyc2lvbiBvZiB0aGUgYXR0YWNoLWRldGFjaCBiZWhhdmlvdXIgY2FuIGJlIGFjaGlldmVkIHdpdGggZnVuY3Rpb24gYHdpdGhgLiBUaGlzIGZ1bmN0aW9uIGhhcyBzb21lIHRlY2huaWNhbCBhZHZhbnRhZ2VzLCBidXQgaGFzIGEgbW9yZSBjb21wbGljYXRlZCBzeW50YXguIEdvb2dsZSBmb3IgZGV0YWlscyBpZiB5b3UgYXJlIGludGVyZXN0ZWQuCgpCeSBkZWZhdWx0LCBgb3JkZXJgIHNvcnRzIGluIGFzY2VuZGluZyBvcmRlciAoaS5lLiBmcm9tIHNtYWxsZXN0IHRvIGxhcmdlc3QpLiBUbyBzb3J0IGluIGRlc2NlbmRpbmcgb3JkZXIsIHBsYWNlIC0gKHRoZSBuZWdhdGl2ZSBzaWduOyB0aGUgaHlwaGVuKSBpbiBmcm9udCBvZiBhbiBhcmd1bWVudCB0byBgb3JkZXJgLiBXZSBjYW4gYWdhaW4gY29tcGFyZSB0aGlzIG9wZXJhdGlvbiBpbiBgZHBseXJgIGFuZCBiYXNlIFI6CgpgYGB7ciBkZXNjZW5kaW5nfQojIERlc2NlbmRpbmcgc29ydAoKIyBkcGx5cgpkZXNjX2RlcF9kZWxheV9kcGx5ciA8LSBhcnJhbmdlKGZsaWdodHMsIGRlc2MoZGVwX2RlbGF5KSkKCiMgYmFzZSBSCmRlc2NfZGVwX2RlbGF5X2Jhc2UgPC0gZmxpZ2h0c1tvcmRlcigtZmxpZ2h0cyRkZXBfZGVsYXkpLF0KCiMgQ2hlY2sgZHBseXIg4oCTIHRoZSBkYXRhIGZyYW1lIGlzIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIGRlcF9kZWxheQpkZXNjX2RlcF9kZWxheV9kcGx5cgoKIyBDaGVjayBiYXNlIOKAkyB0aGUgZGF0YSBmcmFtZSBpcyBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBkZXBfZGVsYXkKZGVzY19kZXBfZGVsYXlfYmFzZQoKYGBgCgojIyBDcmVhdGluZyBuZXcgY29sdW1ucwoKSW4gYGRwbHlyYCB3ZSB1c2UgZnVuY3Rpb24gYG11dGF0ZWAgdG8gY3JlYXRlIG5ldyBjb2x1bW5zLiBJbiBiYXNlIFIsIHdlIHNpbXBseSBhc3NpZ24gdGhlIG5ldyBjb2x1bW4gZGlyZWN0bHkgdG8gdGhlIGRhdGEgZnJhbWUsIHVzaW5nIFwkLiBFYWNoIG5ldyBjb2x1bW4gbXVzdCBiZSBjcmVhdGVkIGluIGEgc2VwYXJhdGUgc3RhdGVtZW50LiBJbiB0aGUgY29kZSBiZWxvdywgd2Ugd2lsbCBjb21wYXJlIHRoZSB0d28gdGVjaG5pcXVlcy4gSW4gYm90aCBhcHByb2FjaGVzIHdlIHdpbGwgYmVnaW4gYnkgbWFraW5nIGEgY29weSBvZiBkYXRhIGZyYW1lIGZsaWdodHMsIGJlZm9yZSB3ZSBzdGFydCB0byBtb2RpZnkgaXQuIFRoaXMgaXMgY29tbW9uIHByYWN0aWNlIHNvIHRoYXQgeW91IGFsd2F5cyBoYXZlIGEgY2xlYW4gY29weSBvZiB5b3VyIG9yaWdpbmFsIGRhdGEuCgpgYGB7ciBtdXRhdGUsIHdhcm5pbmc9RkFMU0V9CgojIGRwbHlyCgojIE1ha2UgYSBjb3B5CmZsaWdodHNfZHBseXIgPC0gZmxpZ2h0cwoKIyBBZGQgbmV3IGNvbHVtbnMgd2l0aCBtdXRhdGUKZmxpZ2h0c19kcGx5ciA8LSBtdXRhdGUoZmxpZ2h0c19kcGx5ciwgZ2Fpbj1kZXBfZGVsYXkgLSBhcnJfZGVsYXksIHNwZWVkID0gZGlzdGFuY2UgLyBhaXJfdGltZSAqIDYwKQoKCiMgYmFzZSBSCgojIE1ha2UgYSBjb3B5CmZsaWdodHNfYmFzZSA8LSBmbGlnaHRzCgojIEFkZCB0aGUgbmV3IGNvbHVtbnMKYXR0YWNoKGZsaWdodHNfYmFzZSkKZmxpZ2h0c19iYXNlJGdhaW4gPC0gZGVwX2RlbGF5IC0gYXJyX2RlbGF5CmZsaWdodHNfYmFzZSRzcGVlZCA8LSBkaXN0YW5jZSAvIGFpcl90aW1lICogNjAKCiMgQ29tcGFyZSB1c2luZyBiYXNlIFIgc2VsZWN0aW9uCiMgQXNrIGZvciBjb2x1bW5zIGdhaW4gYW5kIHNwZWVkIGZvciByb3dzIDEgdG8gMTUKIyBUaGV5IGFyZSB0aGUgc2FtZQpmbGlnaHRzX2RwbHlyWzE6NSwgYygiZ2FpbiIsICJzcGVlZCIpXQpmbGlnaHRzX2Jhc2VbMTo1LCBjKCJnYWluIiwgInNwZWVkIildCmBgYAoKIyMgR3JvdXBpbmcgYW5kIFN1bW1hcmlzaW5nCgpXaXRoIGBkcGx5cmAgd2UgdGFrZSBncm91cCBzdW1tYXJpZXMgKGUuZy4gZ2V0dGluZyB0aGUgYXZlcmFnZSBhcnJpdmFsIGZvciBhbGwgZmxpZ2h0cyBpbiBlYWNoIG1vbnRoKSBieSB1c2luZyBgZ3JvdXBfYnlgIHRvIGdyb3VwIHRoZSBkYXRhIGZyYW1lIChnYXRoZXIgdGhlIHJvd3MgdG9nZXRoZXIgYnkgbW9udGgpIGFuZCBgc3VtbWFyaXNlYCB0byBhcHBseSB0aGUgc3VtbWFyeSBmdW5jdGlvbiAodGFrZSB0aGUgYXZlcmFnZSBmb3IgZWFjaCBtb250aCkuIEluIGJhc2UgUiBib3RoIG9mIHRoZXNlIHN0ZXBzIGFyZSBoYW5kbGVkIGJ5IHRoZSBzaW5nbGUgZnVuY3Rpb24gYGFnZ3JlZ2F0ZWAuIFRoaXMgZnVuY3Rpb24gdGFrZXMgZm91ciBhcmd1bWVudHM6Cgp8IEFyZyBuYW1lIHwgTWVhbmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwKfC0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18CnwgeCAgICAgICAgfCBUaGUgbmFtZSBvZiB0aGUgZGF0YSBmcmFtZSAgICAgICAgICAgICAgICAgICAgICAgfAp8IGJ5ICAgICAgIHwgQSBsaXN0IG9mIGNvbHVtbnMgdG8gZ3JvdXAgYnkgICAgICAgICAgICAgICAgICAgIHwKfCBGVU4gICAgICB8IFRoZSBuYW1lIG9mIHRoZSBzdW1tYXJ5IGZ1bmN0aW9uIHRvIGFwcGx5ICAgICAgICB8CnwgbmEucm0gICAgfCBTZXQgdG8gVFJVRSBpcyB5b3Ugd2FudCB0byBpZ25vcmUgbWlzc2luZyB2YWx1ZXMgfAoKVGhlIG9ubHkgbmV3IHBhcnQgaXMgdGhlIHN5bnRheCB1c2VkIHRvIGRlY2xhcmUgYSBsaXN0IGZvciBhcmd1bWVudCAqKmJ5KiouIFdlIHdpbGwgZmlyc3QgbG9vayBhdCBhbiBleGFtcGxlIG9mIGhvdyB0byB0YWtlIGdyb3VwIG1lYW5zIGluIGJvdGggYGRwbHlyYCBhbmQgYmFzZSBSLCBhbmQgdGhlbiBkaXNjdXNzIHRoZSBsaXN0IGluIG1vcmUgZGV0YWlsLgoKYGBge3IgZ3JvdXAgbWVhbnMgMDEsIHdhcm5pbmc9RkFMU0V9CiMgQ29tcHV0ZSB0aGUgYXZlcmFnZSBhcnJpdmFsIGRlbGF5LCBjb2xsYXBzZWQgYWNyb3NzIG1vbnRocwoKIyBVc2luZyBkcGx5cgoKIyBHcm91cCBieSBtb250aApieV9tb250aCA8LSBncm91cF9ieShmbGlnaHRzLCBtb250aCkKCiMgVGFrZSB0aGUgbWVhbnMKbWVhbl9kZWxheV9ieV9tb250aF9kcGx5ciA8LSBzdW1tYXJpc2UoYnlfbW9udGgsIE1lYW5EZWxheSA9IG1lYW4oYXJyX2RlbGF5LCBuYS5ybSA9IFRSVUUpKQoKIyBDaGVjayB0aGUgb3V0cHV0Cm1lYW5fZGVsYXlfYnlfbW9udGhfZHBseXIKCgoKIyBVc2luZyBiYXNlIFIgZnVuY3Rpb24gYWdncmVnYXRlCm1lYW5fZGVsYXlfYnlfbW9udGhfYmFzZSA8LSBhZ2dyZWdhdGUoeCA9IGZsaWdodHMkYXJyX2RlbGF5LCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IGxpc3QoTW9udGggPSBmbGlnaHRzJG1vbnRoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGVU4gPSBtZWFuLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hLnJtID0gVFJVRSkKCgojIENoZWNrIHRoZSBvdXRwdXQKbWVhbl9kZWxheV9ieV9tb250aF9iYXNlCmBgYAoKVXNlIGZ1bmN0aW9uIGBsaXN0YCB0byBjcmVhdGUgdGhlIHZhbHVlIGZvciBhcmd1bWVudCBgYnlgIC4gVGhpcyBmdW5jdGlvbiBpcyBsaWtlIHRoZSBjb21iaW5lIGZ1bmN0aW9uIGZvciB2ZWN0b3JzLCBleGNlcHQgaXQgY3JlYXRlcyBhIGNvbGxlY3Rpb24gb2YgKm5hbWVkIGVsZW1lbnRzKi4gV2Ugb2Z0ZW4gc2VlIHRoZSBmdW5jdGlvbiBpbiBzaXR1YXRpb25zIGxpa2UgdGhpczoKCmBgYHtyIGxpc3R9CiMgQSBsaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBuYW1lZCBlbGVtZW50cwpwZXRfZGF0YSA8LSBsaXN0KFBldE5hbWUgPSAiU25vb3B5IiwgUGV0T3duZXIgPSAiQ2hhcmxpZSBCcm93biIsIFBldEJyZWVkID0gIkJlYWdsZSIpCnBldF9kYXRhCmBgYAoKV2hlbiB1c2luZyBgYWdncmVnYXRlYCB5b3UgY3JlYXRlIGEgbGlzdCBvZiBjb2x1bW5zIHRoYXQgeW91IHdhbnQgdG8gZ3JvdXAgYnkuIFRoZSBuYW1lcyBvZiB0aGUgY29sdW1ucyB3aWxsIGJlIHRoZSBjb2x1bW4gaGVhZGVycyBmb3IgdGhlIG91dHB1dCB0YWJsZSBvZiBzdW1tYXJpc2VkIHJlc3VsdHMuIFRvIGdyb3VwIGJ5IG11bHRpcGxlIGNvbHVtbnMsIGFkZCBtb3JlIGVsZW1lbnRzIHRvIHRoZSBsaXN0LiBGb3IgZXhhbXBsZSwgaWYgd2Ugd2FudGVkIHRoZSBhdmVyYWdlIGRlbGF5IGJ5IG1vbnRoICpmb3IgZWFjaCBvcmlnaW4gYWlycG9ydCBzZXBhcmF0ZWx5KiB3ZSB3b3VsZCBzYXk6CgpgYGB7ciBncm91cCBtZWFucyAwMiwgd2FybmluZz1GQUxTRX0KIyBDb21wdXRlIHRoZSBhdmVyYWdlIGFycml2YWwgZGVsYXksIGNvbGxhcHNlZCBhY3Jvc3MgbW9udGhzLCBzZXBhcmF0ZWx5IGZvcgojIGVhY2ggb3JpZ2luIGFpcnBvcnQuIFRoZXJlIGFyZSAzIGFpcnBvcnRzIGFuZCAxMiBtb250aHMsIHNvIHdlIGV4cGVjdCB0byAKIyBnZXQgMzYgbWVhbnMuCgojIFVzaW5nIGRwbHlyCgojIEdyb3VwIGJ5IG1vbnRoIGFuZCBvcmlnaW4KYnlfbW9udGhfb3JpZ2luIDwtIGdyb3VwX2J5KGZsaWdodHMsIG1vbnRoLCBvcmlnaW4pCgojIFRha2UgdGhlIG1lYW5zCm1lYW5fbW9udGhfb3JpZ2luX2RwbHlyIDwtIHN1bW1hcmlzZShieV9tb250aF9vcmlnaW4sIE1lYW5EZWxheSA9IG1lYW4oYXJyX2RlbGF5LCBuYS5ybSA9IFRSVUUpKQoKIyBDaGVjayB0aGUgb3V0cHV0Cm1lYW5fbW9udGhfb3JpZ2luX2RwbHlyCgoKCiMgVXNpbmcgYmFzZSBSIGZ1bmN0aW9uIGFnZ3JlZ2F0ZQptZWFuX21vbnRoX29yaWdpbl9iYXNlIDwtIGFnZ3JlZ2F0ZSh4ID0gZmxpZ2h0cyRhcnJfZGVsYXksIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gbGlzdChNb250aCA9IGZsaWdodHMkbW9udGgsIE9yaWdpbiA9IGZsaWdodHMkb3JpZ2luKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGVU4gPSBtZWFuLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hLnJtID0gVFJVRSkKCgojIENoZWNrIHRoZSBvdXRwdXQuIE5vdGUgdGhhdCBkcGx5ciBhbmQgYmFzZSBSIHNvcnQgdGhlIG91dHB1dCBpbiBkaWZmZXJlbnQgb3JkZXJzCm1lYW5fbW9udGhfb3JpZ2luX2Jhc2UKYGBgCgpBcyBiZWZvcmUsIGlmIHlvdSBkb24ndCB3YW50IHRvIHR5cGUgKmZsaWdodHNcJCogbXVsdGlwbGUgdGltZXMsIHVzZSBgYXR0YWNoYC4KCiMgQ29uY2x1c2lvbgoKUiB1c2VycyBhcmUgY29uc3RhbnRseSBhZGRpbmcgbmV3IGxpYnJhcmllcyB0byBiYXNlIFIsIG1lYW5pbmcgdGhhdCB5b3Ugd2lsbCBwcm9iYWJseSBoYXZlIHNldmVyYWwgb3B0aW9ucyBmb3IgZG9pbmcgYW55IGpvYiBpbiBSLiBUaGUgdmFyaW91cyBvcHRpb25zIHNvbWV0aW1lcyBoYXZlIHN1YnRsZSB0ZWNobmljYWwgZGlmZmVyZW5jZXMgdGhhdCB3aWxsIGdlbmVyYXRlIGEgbG90IG9mIGFyZ3VtZW50IGJldHdlZW4gcHJvZmVzc2lvbmFsIHByb2dyYW1tZXJzLCBidXQgYXJlIHVubGlrZWx5IHRvIG1hdHRlciBtdWNoIHRvIHJlc2VhcmNoIHNjaWVudGlzdHMuIEluIGdlbmVyYWwsIHlvdSBzaG91bGQgZXhwbG9yZSB0aGUgUiBlY29zeXN0ZW0gZnJlZWx5IGFuZCB1c2Ugd2hhdGV2ZXIgeW91IGxpa2UuICoqSG93ZXZlcioqIG9uIGFzc2lnbm1lbnRzLCBpdCBpcyB3aXNlIHRvIGNoZWNrIHdpdGggdGhlIGxlY3R1cmVyIGJlZm9yZSB1c2luZyBzb21ldGhpbmcgdGhhdCBpcyByZWFsbHkgZGlmZmVyZW50IGZyb20gd2hhdCBpcyBwcmVzZW50ZWQgaW4gY2xhc3MuIFlvdXIgbGVjdHVyZXIgbWF5LCBmb3IgZWR1Y2F0aW9uYWwgcmVhc29ucywgd2FudCB5b3UgdG8gdXNlIHNwZWNpZmljIFIgdG9vbHMuCgojIyBXaGF0J3MgTmV4dAoKRmlsbCBpbiB0aGUgbW9kdWxlIGZlZWRiYWNrIGZvcm0gPGh0dHBzOi8vdGlueXVybC5jb20vcjRzc3AtbW9kdWxlLWZiPi4KCllvdSBtYXkgcmVjYWxsIHRoYXQgd2F5IGJhY2sgaW4gdGhlIGZpcnN0IG1vZHVsZSBvZiB0aGlzIG1pbmktY291cnNlIHdlIHNhaWQgd2Ugd2VyZSBnb2luZyB0byBhbmFseXNlIGRhdGEuIFdlIGhhdmVuJ3QgcmVhbGx5IGRvbmUgbXVjaCBvZiB0aGF0IHlldC4gU28gZmFyIHdlIGhhdmUgYmVlbiAqZ2V0dGluZyByZWFkeSogdG8gYW5hbHlzZSBkYXRhLiBJbiB0aGUgbmV4dCBtb2R1bGUsIHdlIHdpbGwgc3RhcnQgcmVhbGx5IGRpZ2dpbmcgaW50byBvdXIgZGF0YSB3aXRoIGV4cGxvcmF0b3J5IGFuYWx5c2lzIGFuZCBkZXNjcmlwdGl2ZSBzdGF0aXN0aWNzLiBCZWNhdXNlIHRoaXMgaXMgbm90IGEgc3RhdGlzdGljcyBjb3Vyc2UgKnBlciBzZSogd2Ugd2lsbCBvbmx5IGJlIHVzaW5nIGNvbW1vbiBnZW5lcmFsIGFuYWx5c2VzIGluIHRoZSBoYW5kb3V0cyBhbmQgcmVhZGluZ3MuIElmLCBmb3IgYSBwcm9qZWN0IG9yIGFzc2lnbm1lbnQsIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZyBtb3JlIGVzb3RlcmljLCBqdXN0IGxldCB1cyBrbm93IC0tIHNvbWVvbmUgaGFzIHByb2JhYmx5IHdyaXR0ZW4gYW4gUiBsaWJyYXJ5IGZvciBpdC4K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("03-subset.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

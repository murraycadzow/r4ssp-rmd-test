<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Summarising</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R4SSP Semester 1 2022</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Intro</li>
    <li>
      <a href="01-intro.html">Intro to R and RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Focus</li>
    <li>
      <a href="02-visualise.html">Part 1: Visualising</a>
    </li>
    <li>
      <a href="03-subset.html">Part 2: Subsetting</a>
    </li>
    <li>
      <a href="04-summarise.html">Part 3: Summarising</a>
    </li>
    <li>
      <a href="05-transform.html">Part 4: Transforming</a>
    </li>
    <li>
      <a href="06-communicate.html">Part 5: Communicating</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Programming focus</li>
    <li>
      <a href="07-functions.html">Functions and Choices</a>
    </li>
    <li>
      <a href="08-iterate.html">Repeating Code</a>
    </li>
    <li>
      <a href="09-workflows.html">Workflows</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Zoom Notes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="zoom_notes_01.html">01 - Introducing R and RStudio</a>
    </li>
    <li>
      <a href="zoom_notes_02.html">02 - Visualising data</a>
    </li>
    <li>
      <a href="zoom_notes_03.html">03 - Subsetting data</a>
    </li>
    <li>
      <a href="zoom_notes_04.html">04 - Summarising data</a>
    </li>
    <li>
      <a href="zoom_notes_05.html">05 - Transforming data</a>
    </li>
    <li>
      <a href="zoom_notes_06.html">06 - Communicating data</a>
    </li>
    <li>
      <a href="zoom_notes_07.html">07 - Functions and choices</a>
    </li>
    <li>
      <a href="zoom_notes_08.html">08 - Repeating code</a>
    </li>
    <li>
      <a href="zoom_notes_09.html">09 - Workflows</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Summarising</h1>
<h4 class="date">Semester 1, 2022</h4>

</div>


<blockquote>
<h4 id="associated-material">Associated Material</h4>
<p>Zoom notes: <a href="zoom_notes_04.html">Zoom Notes 04 - Summarising data</a></p>
<p>Readings</p>
<ul>
<li><a href="https://r4ds.had.co.nz/exploratory-data-analysis.html">R for Data Science - Chapter 7</a></li>
</ul>
</blockquote>
<p><br />
</p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>We do scientific research to test hypotheses, answer questions, or just learn something about the world. After the often labourious process of data collection, we may have hundreds (or even thousands) of data points, but we haven’t actually learned anything. To squeeze the knowledge out of our raw data, we must use statistics.</p>
<p>The formal topic of statistics is large and complex, and we do not attempt to teach it here (there are papers for that, and we recommend you take as many of them as possible). We concentrate on how to use R to perform common statistical analyses. R is especially useful for such tasks because of its extensive set of statistical libraries and efficient data handling facilities.</p>
<p>There are two general types of statistical analyses – descriptive statistics, which allow us to summarise and describe our raw data, and inferential statistics, which allow us to generalise our results beyond our observed data. We will only cover descriptive statistics in R4SSP.</p>
<p>For this module, we will use two data sets – the Palmers Penguins data we have seen previously, and a data set containing Chlorophyll A (ChlA) readings from three New Zealand lakes (data provided by the local Regional Councils). ChlA levels are an indicator of phytoplankton biomass, and provide a general measure of lake health – more ChlA indicates poorer health. The “toxic algal blooms” that occur occasionally in New Zealand lakes are accompanied by a dramatic spike in measured ChlA.</p>
</div>
<div id="loading-the-data" class="section level2">
<h2>Loading the data</h2>
<pre class="r"><code>
# Install palmerpenguins once on any computer
# install.packages(&quot;palmerspenguins&quot;)

# After loading the library, a tibble
# called &#39;penguins&#39; will be initialised
library(palmerpenguins)

# Check the structure
str(penguins)
#&gt; tibble [344 x 8] (S3: tbl_df/tbl/data.frame)
#&gt;  $ species          : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ island           : Factor w/ 3 levels &quot;Biscoe&quot;,&quot;Dream&quot;,..: 3 3 3 3 3 3 3 3 3 3 ...
#&gt;  $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...
#&gt;  $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...
#&gt;  $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...
#&gt;  $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...
#&gt;  $ sex              : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 1 1 NA 1 2 1 2 NA NA ...
#&gt;  $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...

# Read in the lakes data file, parsing the lake 
# name column as a factor
lakes &lt;- read.csv(&quot;data/NZ_lake_chla_data.csv&quot;, stringsAsFactors = TRUE)

# Since they are conceptually categorical in this data set, 
# you may wish to cast Year and Month to factors as well, for completeness...
lakes$Year &lt;- as.factor(lakes$Year)
lakes$Month &lt;- as.factor(lakes$Month)  

# Check the structure
str(lakes)
#&gt; &#39;data.frame&#39;:    408 obs. of  4 variables:
#&gt;  $ LakeName: Factor w/ 3 levels &quot;Lake Ellesmere&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ Year    : Factor w/ 13 levels &quot;2001&quot;,&quot;2002&quot;,..: 4 4 4 4 4 4 4 4 4 4 ...
#&gt;  $ Month   : Factor w/ 12 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
#&gt;  $ ChlA    : num  66.9 79.9 95 82.4 59.6 69 62.1 96.3 135 102 ...</code></pre>
</div>
<div id="visualise-the-data-revision" class="section level2">
<h2>Visualise the data (revision)</h2>
<p>When faced with a new data set, my first step is invariably to start making graphs. These “pictures” of your data provide an easy way to see large-scale patterns that will help guide your further analysis. They also help you to catch any problems in your data (see the skewness exercise in the Zoom Notes for this module) that must be addressed before proceeding to more complex analyses.</p>
<p>An excellent first graph for continuous (i.e. not categorical) data is the <strong>frequency distribution</strong>, or <strong>histogram</strong>, which has data value on the x-axis and frequency (i.e. count or proportion) on the y-axis. This shows you, in a single picture, how your data are distributed. We met the histogram in Module 02.</p>
<p>The <code>penguins</code> data set contains values for 344 different penguins. We can begin by looking at how the penguins’ body weights are distributed.</p>
<div id="with-base-r" class="section level3">
<h3>With Base R</h3>
<pre class="r"><code># The &#39;breaks&#39; argument controls the number of bars drawn
hist(penguins$body_mass_g, 
     breaks = 100,
     main=&quot;Distribution of Penguin Body Mass&quot;, xlab = &quot;Body mass (g)&quot;, ylab = &quot;Frequency&quot;)</code></pre>
<p><img src="figures/04/04-histograms-1.png" width="672" /></p>
</div>
<div id="with-ggplot" class="section level3">
<h3>With ggplot</h3>
<pre class="r"><code># Load the library before your first call to ggplot
library(ggplot2)

# The values provided to &#39;colour&#39; and &#39;fill&#39; are hexidecimal colour codes. Note the 
# hash mark prefix. It is required.
# The &#39;labs&#39; layer controls graph title and axis labels
ggplot(data = penguins, mapping = aes(x = body_mass_g)) +
  geom_histogram(colour = &quot;#7133ff&quot;, fill=&quot;#bbbbff&quot;) +
  labs(title = &quot;Distribution of Penguin Body Mass&quot;, x = &quot;Body Mass (g)&quot;, y = &quot;Frequency&quot;) + theme_bw()</code></pre>
<p><img src="figures/04/ggplot%20histo,%20-1.png" width="672" /></p>
</div>
<div id="illustrating-groups" class="section level3">
<h3>Illustrating Groups</h3>
<p>Using ggplot, we can illustrate group effects in histograms by defining a mapping from a grouping (i.e. categorical) variable to the <code>fill</code> property of function <code>geom_histogram</code>. For example, the code below will make histograms of all the ChlA values in data frame <code>lakes</code>, with each lake in a different colour</p>
<p>By default, geom_histogram produces a stacked plot – that is, the different groups are shown stacked up in a single bar, separated by their colour. To make the plot with side-by-side bars, set geom_histogram’s <code>position</code> argument to <code>dodge</code>. Note that this is not a mapping, it is simply an argument to function geom_histogram. What does this simple graph tell you about the health of these three lakes?</p>
<pre class="r"><code># Stacked grouped histogram
ggplot(data = lakes, mapping = aes(x = ChlA)) +
  geom_histogram(aes(fill=LakeName), colour = &#39;black&#39;)</code></pre>
<p><img src="figures/04/04-lake_hists-1.png" width="672" /></p>
<pre class="r"><code>
# Side-by-side grouped histogram
ggplot(data = lakes, mapping = aes(x = ChlA)) +
  geom_histogram(aes(fill=LakeName), colour = &#39;black&#39;, position=&quot;dodge&quot;)</code></pre>
<p><img src="figures/04/04-lake_hists-2.png" width="672" /></p>
</div>
</div>
<div id="distribution-graphs-for-categorical-data" class="section level2">
<h2>Distribution graphs for categorical data</h2>
<p>The functions <code>hist</code> and <code>geom_histogram</code> are appropriate for <strong>continuous</strong> (numerical) data. For <strong>categorical</strong> variables (e.g. Species and Island in the penguin data set) one often uses the more general <code>geom_bar</code> function (geom_histogram is a special case of geom_bar). The example code below shows how to generate a bar graph in ggplot, modifying the default ggplot colour palette to something more accessible to viewers with atypical colour vision:</p>
<pre class="r"><code># &quot;Colour-blind friendly&quot; palette from #https://personal.sron.nl/~pault/
# These are hexadecimal colour codes. The # is required.
customPalette &lt;- c(&quot;#DDAA33&quot;, &quot;#BB5566&quot;, &quot;#004488&quot;)

# Generate a stacked bar plot, and use our custom colour palette
ggplot(data = penguins) +
  geom_bar(aes(x = island, fill=species), position = &quot;stack&quot;) +
  scale_fill_manual(values = customPalette)</code></pre>
<p><img src="figures/04/04-categorical_distribution-1.png" width="672" /></p>
<p>Even a simple graph like this helps you to get to know your data. Just by inspection we see that Biscoe island has the largest population, Torgersen has only Adelie penguins, Dream Island has nearly equal numbers of Chinstrap and Gentoo, etc. When first approaching a big data set, always think about starting with some graphs.</p>
<div id="exercise-2" class="section level3">
<h3>Exercise 2</h3>
<p>The bar graph above is in “stacked” format. Some people prefer bar graphs to have separate bars for each group, as shown below. Write the code needed to generate this graph. Hint: This requires changing only the value of one argument in the code above.</p>
<p><img src="figures/04/04-categorical_distribution_dodge-1.png" width="672" /></p>
</div>
</div>
<div id="measures-of-central-tendency" class="section level2">
<h2>Measures of Central Tendency</h2>
<p>Look at the graph you made earlier showing the distributions of ChlA for the three lakes. You might describe the Lake Ellesmere ChlA readings as “mostly between 50 and 100” and the Lake Rotorua readings as “mostly around 10”. Statements like this are attempts to describe a <strong>typical</strong> score from a large data set. They allow us to capture the fact that, for example, <em>overall</em>, Lake Ellesmere has higher ChlA readings than Lake Rotorua. It is not the case that <em>every</em> Ellesmere reading is higher than <em>every</em> Rotorua reading, but <strong>typically</strong> this is the case.</p>
<p>In statistics, a precise measure of such typicality is called a <strong>Measure of Central Tendency</strong> (MCT). The most common MCTs are the <strong>mean</strong>, the <strong>median</strong> and the <strong>mode</strong>. These are, respectively, the mathematical average, the middle score, and the most frequent score (or scores) in a data set. There are some subtle statistical issues around which of the three MCT is appropriate for any given data analysis situation (ask your lecturer for details), but they are all easy to compute in R (we have, in fact, already met function <code>mean</code> in earlier modules), and we show example code below for computing these descriptive statistics on a single column of data from the penguins data set.</p>
<p>Note that the penguins data has some missing some values (cf. Module 03 - Subsetting), The functions for mean and median will not work if the input data have any <code>NA</code> (missing) values. The most common solution is to omit those scores from the computation by setting the <code>na.rm</code> argument to <code>TRUE</code> as shown:</p>
<div id="mean" class="section level3">
<h3>Mean</h3>
<pre class="r"><code># We have seen this code before... We pass the column of interest
# to function mean
mean(penguins$body_mass_g, na.rm=TRUE)
#&gt; [1] 4201.754</code></pre>
</div>
<div id="median" class="section level3">
<h3>Median</h3>
<pre class="r"><code># The familiar pattern....
median(penguins$body_mass_g, na.rm = TRUE)
#&gt; [1] 4050</code></pre>
</div>
<div id="mode" class="section level3">
<h3>Mode</h3>
<p>Base R has no built-in function for mode. After Module 08 you will be able to write your own Mode function. Or you can use one of several available in auxiliary libraries. The DescTools library is a good one.</p>
<pre class="r"><code>
# Install the package once on each machine
# install.packages(&quot;DescTools&quot;)

# Load the library once each session
library(DescTools)

#Call the function
Mode(penguins$body_mass_g, na.rm=TRUE)
#&gt; [1] 3800
#&gt; attr(,&quot;freq&quot;)
#&gt; [1] 12</code></pre>
<p>Note that DescTools::Mode returns the modal (i.e. most common value) with an attached <strong>attribute</strong> called “freq” equal to the number of occurences.</p>
</div>
</div>
<div id="using-function-summary" class="section level2">
<h2>Using function <code>summary</code></h2>
<p>When you have a very large number of data measures, you may wish to compute MCTs for individual columns as shown above. An efficient alternative for smaller data sets is to use function <code>summary</code>, which accepts a data frame and summarises <em>all</em> its columns at once. Function <code>summary</code> computes frequencies for categorical variables, and measures of central tendency for continuous variables. It also reports the numbers of NA values in each column. Function <code>summary</code> provides some additional measures (minimum, 1st quartile, 3rd quartile, and maximum) that we will discuss in more detail later.</p>
<pre class="r"><code>summary(penguins)
#&gt;       species          island    bill_length_mm  bill_depth_mm  
#&gt;  Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  
#&gt;  Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  
#&gt;  Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  
#&gt;                                  Mean   :43.92   Mean   :17.15  
#&gt;                                  3rd Qu.:48.50   3rd Qu.:18.70  
#&gt;                                  Max.   :59.60   Max.   :21.50  
#&gt;                                  NA&#39;s   :2       NA&#39;s   :2      
#&gt;  flipper_length_mm  body_mass_g       sex           year     
#&gt;  Min.   :172.0     Min.   :2700   female:165   Min.   :2007  
#&gt;  1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  
#&gt;  Median :197.0     Median :4050   NA&#39;s  : 11   Median :2008  
#&gt;  Mean   :200.9     Mean   :4202                Mean   :2008  
#&gt;  3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  
#&gt;  Max.   :231.0     Max.   :6300                Max.   :2009  
#&gt;  NA&#39;s   :2         NA&#39;s   :2</code></pre>
<div id="exercise-3" class="section level3">
<h3>Exercise 3</h3>
<p>The results for column <code>year</code> may not be what you expected. Function <code>summary</code> has computed an <em>average value</em> for <code>year</code>. Does this seem like the appropriate analysis? (Answer =&gt; No.) Modify <code>penguins</code> to make <code>summary</code> treat the <code>year</code> data correctly, and rerun <code>summary</code>.</p>
</div>
</div>
<div id="measures-of-variability" class="section level2">
<h2>Measures of Variability</h2>
<p>In the histograms for ChlA from each of three New Zealand lakes, the three groups of scores did not overlap completely, indicating that the typical values – the central tendencies – were different for the three lakes. We can confirm this observation by comparing the means. We can use function <code>aggregate</code> in base R, or <code>group_by</code> and <code>summarise</code>, from library dplyr.</p>
<pre class="r"><code># Using aggregate. compute the group means
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=mean)
#&gt;             Lake         x
#&gt; 1 Lake Ellesmere 80.566667
#&gt; 2   Lake Rotorua 18.419015
#&gt; 3     Lake Taupo  1.030606


# Using group_by and summarise
library(dplyr)
#&gt; 
#&gt; Attaching package: &#39;dplyr&#39;
#&gt; The following objects are masked from &#39;package:stats&#39;:
#&gt; 
#&gt;     filter, lag
#&gt; The following objects are masked from &#39;package:base&#39;:
#&gt; 
#&gt;     intersect, setdiff, setequal, union

lakes %&gt;% 
  group_by(LakeName) %&gt;%
  summarise(MeanChlA = mean(ChlA))
#&gt; # A tibble: 3 x 2
#&gt;   LakeName       MeanChlA
#&gt;   &lt;fct&gt;             &lt;dbl&gt;
#&gt; 1 Lake Ellesmere    80.6 
#&gt; 2 Lake Rotorua      18.4 
#&gt; 3 Lake Taupo         1.03</code></pre>
<p>However, not only do the central points of the three lakes’ distributions differ, so do the amounts of “spread”. Lake Taupo’s distribution is very “skinny”; all its readings are similar. Lake Ellesmere is squashed and spread out; its readings vary a lot. Lake Rotorua is intermediate. To illustrate this more clearly, we can use ggplot to make separate graphs for each lake, using function <code>facet_grid</code>.</p>
<p>Note the <code>scales</code> argument to <code>facet_grid</code>. This allows each graph to adjust its y-axis to its data domain, which makes the comparison visually easier; this should be mentioned in the discussion of the figure in a manuscript.</p>
<pre class="r"><code>ggplot(data = lakes) +
  geom_histogram(aes(x = ChlA, fill=LakeName), color=&quot;black&quot;) +
  facet_grid(rows = vars(LakeName), scales=&quot;free_y&quot;)</code></pre>
<p><img src="figures/04/facet_graphs-1.png" width="672" /></p>
<p>Statistically, the “spread out” quality of a distribution reflects its <strong>variability</strong>.</p>
<p>We can capture variability more precisely with measures of the <strong>range</strong> of the data set. These are typically the smallest and largest scores (minimum and maximum) and the scores at the 25th and 75th percentiles (also called <strong>1st quartile</strong> and <strong>3rd quartile</strong>). Earlier, we saw that function <code>summary</code> computes these measures of range. However, if we simply pass the entire <code>lakes</code> data frame to function <code>summary</code>, it will combine the data from all three lakes – to compare the lakes we need the values from each lake separately.</p>
<p>In earlier modules we have seen two techniques for selecting out just the rows from one lake (using [] or using <code>filter</code>). To run function <code>summary</code> on each lake separately, we could select the subset for each lake in turn, and pass each subset to <code>summary</code>. However, we can achieve the same result more parsimoniously by using function <code>aggregate</code>. Above we used aggregate with <code>FUN = mean</code> to get the mean ChlA for each lake. We can use <code>FUN = summary</code> to call function <code>summary</code> separately for the records of each lake.</p>
<pre class="r"><code>
# Using aggregate
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=summary)
#&gt;             Lake     x.Min.  x.1st Qu.   x.Median     x.Mean  x.3rd Qu.
#&gt; 1 Lake Ellesmere   1.300000  44.000000  67.950000  80.566667  97.087500
#&gt; 2   Lake Rotorua   2.500000  10.825000  15.950000  18.419015  23.625000
#&gt; 3     Lake Taupo   0.200000   0.600000   0.900000   1.030606   1.400000
#&gt;       x.Max.
#&gt; 1 521.300000
#&gt; 2  77.100000
#&gt; 3   2.900000</code></pre>
<p>We can also measure the variablity in a data set with the <strong>standard deviation</strong>. The standard deviation is the most commonly used measure of variability, and it plays an important mathematical role in inferential statistics (ask your stats lecturer for details – it’s very interesting). Conceptually, the standard deviation is <em>almost</em> equal to the average distance from the mean across all the values in a data set – it doesn’t equal <em>exactly</em> that value, because of how it is computed, but it is close, and it can be helpful to think of it with this approximation. Big standard deviation shows that scores are spread far from their mean; small standard deviation shows that scores tend to huddle close to their mean. Compute standard deviation with function <code>sd</code>.</p>
<pre class="r"><code>
# Using aggregate. compute the group sds
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=sd)
#&gt;             Lake          x
#&gt; 1 Lake Ellesmere 63.5217194
#&gt; 2   Lake Rotorua 11.6637583
#&gt; 3     Lake Taupo  0.5627233


# Using group_by and summarise

lakes %&gt;% 
  group_by(LakeName) %&gt;%
  summarise(StdDev = sd(ChlA))
#&gt; # A tibble: 3 x 2
#&gt;   LakeName       StdDev
#&gt;   &lt;fct&gt;           &lt;dbl&gt;
#&gt; 1 Lake Ellesmere 63.5  
#&gt; 2 Lake Rotorua   11.7  
#&gt; 3 Lake Taupo      0.563</code></pre>
<p>The histograms, the measures of range, and the standard deviations all indicate that Taupo has very stable ChlA measures, Rotorua is a little noisier, and Ellesmere is all over the place. This phytoplankton biomass stability is an important indicator of lake health – a stable lake is at much lower risk of a toxic algal bloom.</p>
</div>
<div id="efficient-code-for-descriptive-statistics" class="section level2">
<h2>Efficient code for descriptive statistics</h2>
<p>The function <code>describeBy</code> in package <code>psych</code> will compute all the descriptive summaries we have seen (and a few more) in one statement. When you are exploring a single data column and a single grouping column (so the output doesn’t get too large), this is a very useful function.</p>
<pre class="r"><code># Install once on any computer
#install.packages(&quot;psych&quot;)

# Call once each R session
library(psych)
#&gt; 
#&gt; Attaching package: &#39;psych&#39;
#&gt; The following objects are masked from &#39;package:DescTools&#39;:
#&gt; 
#&gt;     AUC, ICC, SD
#&gt; The following objects are masked from &#39;package:ggplot2&#39;:
#&gt; 
#&gt;     %+%, alpha

# Pass in the data column and the grouping column
describeBy(lakes$ChlA, lakes$LakeName)
#&gt; 
#&gt;  Descriptive statistics by group 
#&gt; group: Lake Ellesmere
#&gt;    vars   n  mean    sd median trimmed  mad min   max range skew kurtosis  se
#&gt; X1    1 120 80.57 63.52  67.95   72.45 40.7 1.3 521.3   520 3.12     17.5 5.8
#&gt; ------------------------------------------------------------ 
#&gt; group: Lake Rotorua
#&gt;    vars   n  mean    sd median trimmed  mad min  max range skew kurtosis   se
#&gt; X1    1 132 18.42 11.66  15.95   16.97 9.12 2.5 77.1  74.6 1.71     4.75 1.02
#&gt; ------------------------------------------------------------ 
#&gt; group: Lake Taupo
#&gt;    vars   n mean   sd median trimmed  mad min max range skew kurtosis   se
#&gt; X1    1 156 1.03 0.56    0.9    0.97 0.56 0.2 2.9   2.7 0.97      0.5 0.05</code></pre>
<p>Package <code>psych</code> contains many other interesting statistical tools, especially for multivariate data sets commonly found in psychological and ecological research. Ask Google or your lecturer for details.</p>
</div>
<div id="exploring-the-relationship-between-two-variables" class="section level2">
<h2>Exploring the relationship between two variables</h2>
<p>The preceding descriptive statistics all looked at data measures – ChlA, bill length, body weight, etc. – individually, summarising their distribution, central tendency and variability. Often, however, we are interested in describing <strong>the relationship between data measures</strong>. For example, we might want to know if heavier penguins also tend to have longer bills. This type of relationship is called a <strong>correlation</strong>. When we have more than one measure for each experimental participant (or each penguin, or each lake) we can explore correlations between pairs of measures graphically with a <strong>scatterplot</strong>. A scatterplot has one measure on each axis, and one point for each participant’s pair of scores.</p>
<p>In the code example below we make a scatterplot with ggplot (cf. Module 02), and show how to add a <strong>linear trend line</strong>. Conceptually, this is the line that runs through the center of the scatterplot points, and it helps us to see the direction of the relationship. Mathematically, trend lines are actually very complicated things, and we generate them with the powerful function <code>lm</code>,(for <strong>linear model</strong>). You will learn about the many fascinating things you can do with linear modeling if you take advanced statistics papers.</p>
<pre class="r"><code># geom_point plots the points of the scatterplot 

# geom_smooth plots the linear trend line computed with function lm

# The se argument determines whether error bars are shown 
# around the trend line.

ggplot(data = penguins, mapping = aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point() +
  geom_smooth(method = &quot;lm&quot;, se=FALSE)</code></pre>
<p><img src="figures/04/04-scatterplot-1.png" width="672" /></p>
<p>The scatterplot gives us a very clear picture: those penguins with higher body weights tend to also have longer bills, and this is reflected in the positive slope of the trendline. Note however that this is not an absolute rule. Is it easy to find pairs of points such that the lighter of two penguins has the longer bill. This is typical of correlational data.</p>
<p>There are various statistical measures that capture the strength of a correlation (i.e. how close it is to being an absolute rule). For continuous, numerical data (such as bill length and body weight) use the R function <code>cor</code> to compute the numerical correlation value. As with means and medians, we must tell <code>cor</code> how to cope with missing data (NA scores). Unfortunately the syntax is not consistent across the functions. For function <code>mean</code> we set argument <code>na.rm = TRUE</code>. For function <code>cor</code> we must set argument <code>use = "complete.obs"</code>, meaning that we want the function to use only those rows that are complete (i.e. have both values). These idiosyncracies occur from time to time in R; you just have to learn them.</p>
<pre class="r"><code>
# Pass the two data columns into function cor
cor(penguins$bill_length_mm, penguins$body_mass_g, use=&quot;complete.obs&quot;)
#&gt; [1] 0.5951098</code></pre>
<p>Function <code>cor</code> returns a value between -1 and 1. Correlations that trend downward (i.e. if one score is high, the other tends to be low) will have a negative correlation value. Correlations that trend upward (i.e. if one score is high the other also tends to be high) will have a positive correlation value. The closer the absolute value of <code>cor</code> is to 1, the stronger the correlation (you know who to talk to for more detail, don’t you?).</p>
<p>For example, consider these two scatterplots:</p>
<p><img src="figures/04/04-comparing-1.png" width="672" /></p>
<div id="exercise-4" class="section level3">
<h3>Exercise 4</h3>
<p>For one of the scatterplots above, the computed correlation score is 0.60. For the other, it is 0.87. First, predict which is which. Second, write the necessary R code to confirm your prediction.</p>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlN1bW1hcmlzaW5nIg0KZGF0ZTogIlNlbWVzdGVyIDEsIDIwMjIiDQpvdXRwdXQ6DQogIGh0bWxfZG9jdW1lbnQ6DQogICAgdG9jOiB0cnVlDQogICAgdG9jX2Zsb2F0OiB0cnVlDQogICAgdG9jX2RlcHRoOiAzDQogICAgY29kZV9kb3dubG9hZDogdHJ1ZQ0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KLS0tDQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0KbGlicmFyeShrbml0cikNCg0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KA0KICBjb21tZW50ID0gIiM+IiwNCiAgZmlnLnBhdGggPSAiZmlndXJlcy8wNC8iLCAjIHVzZSBvbmx5IGZvciBzaW5nbGUgUm1kIGZpbGVzDQogIGNvbGxhcHNlID0gVFJVRSwNCiAgZWNobyA9IFRSVUUNCikNCg0KDQpgYGANCg0KPiAjIyMjIEFzc29jaWF0ZWQgTWF0ZXJpYWwNCj4NCj4gWm9vbSBub3RlczogW1pvb20gTm90ZXMgMDQgLSBTdW1tYXJpc2luZyBkYXRhXSh6b29tX25vdGVzXzA0Lmh0bWwpDQo+DQo+IFJlYWRpbmdzDQo+DQo+IC0gW1IgZm9yIERhdGEgU2NpZW5jZSAtIENoYXB0ZXIgN10oaHR0cHM6Ly9yNGRzLmhhZC5jby5uei9leHBsb3JhdG9yeS1kYXRhLWFuYWx5c2lzLmh0bWwpDQoNClwNCg0KIyMgSW50cm9kdWN0aW9uDQoNCldlIGRvIHNjaWVudGlmaWMgcmVzZWFyY2ggdG8gdGVzdCBoeXBvdGhlc2VzLCBhbnN3ZXIgcXVlc3Rpb25zLCBvciBqdXN0IGxlYXJuIHNvbWV0aGluZyBhYm91dCB0aGUgd29ybGQuIEFmdGVyIHRoZSBvZnRlbiBsYWJvdXJpb3VzIHByb2Nlc3Mgb2YgZGF0YSBjb2xsZWN0aW9uLCB3ZSBtYXkgaGF2ZSBodW5kcmVkcyAob3IgZXZlbiB0aG91c2FuZHMpIG9mIGRhdGEgcG9pbnRzLCBidXQgd2UgaGF2ZW4ndCBhY3R1YWxseSBsZWFybmVkIGFueXRoaW5nLiBUbyBzcXVlZXplIHRoZSBrbm93bGVkZ2Ugb3V0IG9mIG91ciByYXcgZGF0YSwgd2UgbXVzdCB1c2Ugc3RhdGlzdGljcy4NCg0KVGhlIGZvcm1hbCB0b3BpYyBvZiBzdGF0aXN0aWNzIGlzIGxhcmdlIGFuZCBjb21wbGV4LCBhbmQgd2UgZG8gbm90IGF0dGVtcHQgdG8gdGVhY2ggaXQgaGVyZSAodGhlcmUgYXJlIHBhcGVycyBmb3IgdGhhdCwgYW5kIHdlIHJlY29tbWVuZCB5b3UgdGFrZSBhcyBtYW55IG9mIHRoZW0gYXMgcG9zc2libGUpLiBXZSBjb25jZW50cmF0ZSBvbiBob3cgdG8gdXNlIFIgdG8gcGVyZm9ybSBjb21tb24gc3RhdGlzdGljYWwgYW5hbHlzZXMuIFIgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIHN1Y2ggdGFza3MgYmVjYXVzZSBvZiBpdHMgZXh0ZW5zaXZlIHNldCBvZiBzdGF0aXN0aWNhbCBsaWJyYXJpZXMgYW5kIGVmZmljaWVudCBkYXRhIGhhbmRsaW5nIGZhY2lsaXRpZXMuIA0KDQpUaGVyZSBhcmUgdHdvIGdlbmVyYWwgdHlwZXMgb2Ygc3RhdGlzdGljYWwgYW5hbHlzZXMgLS0gZGVzY3JpcHRpdmUgc3RhdGlzdGljcywgd2hpY2ggYWxsb3cgdXMgdG8gc3VtbWFyaXNlIGFuZCBkZXNjcmliZSBvdXIgcmF3IGRhdGEsIGFuZCBpbmZlcmVudGlhbCBzdGF0aXN0aWNzLCB3aGljaCBhbGxvdyB1cyB0byBnZW5lcmFsaXNlIG91ciByZXN1bHRzIGJleW9uZCBvdXIgb2JzZXJ2ZWQgZGF0YS4gV2Ugd2lsbCBvbmx5IGNvdmVyIGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MgaW4gUjRTU1AuDQoNCkZvciB0aGlzIG1vZHVsZSwgd2Ugd2lsbCB1c2UgdHdvIGRhdGEgc2V0cyAtLSB0aGUgUGFsbWVycyBQZW5ndWlucyBkYXRhIHdlIGhhdmUgc2VlbiBwcmV2aW91c2x5LCBhbmQgYSBkYXRhIHNldCBjb250YWluaW5nIENobG9yb3BoeWxsIEEgKENobEEpIHJlYWRpbmdzIGZyb20gdGhyZWUgTmV3IFplYWxhbmQgbGFrZXMgKGRhdGEgcHJvdmlkZWQgYnkgdGhlIGxvY2FsIFJlZ2lvbmFsIENvdW5jaWxzKS4gQ2hsQSBsZXZlbHMgYXJlIGFuIGluZGljYXRvciBvZiBwaHl0b3BsYW5rdG9uIGJpb21hc3MsIGFuZCBwcm92aWRlIGEgZ2VuZXJhbCBtZWFzdXJlIG9mIGxha2UgaGVhbHRoIC0tIG1vcmUgQ2hsQSBpbmRpY2F0ZXMgcG9vcmVyIGhlYWx0aC4gVGhlICJ0b3hpYyBhbGdhbCBibG9vbXMiIHRoYXQgb2NjdXIgb2NjYXNpb25hbGx5IGluIE5ldyBaZWFsYW5kIGxha2VzIGFyZSBhY2NvbXBhbmllZCBieSBhIGRyYW1hdGljIHNwaWtlIGluIG1lYXN1cmVkIENobEEuDQoNCiMjIExvYWRpbmcgdGhlIGRhdGENCg0KYGBge3IgbG9hZCB0aGUgZGF0YSwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0NCg0KIyBJbnN0YWxsIHBhbG1lcnBlbmd1aW5zIG9uY2Ugb24gYW55IGNvbXB1dGVyDQojIGluc3RhbGwucGFja2FnZXMoInBhbG1lcnNwZW5ndWlucyIpDQoNCiMgQWZ0ZXIgbG9hZGluZyB0aGUgbGlicmFyeSwgYSB0aWJibGUNCiMgY2FsbGVkICdwZW5ndWlucycgd2lsbCBiZSBpbml0aWFsaXNlZA0KbGlicmFyeShwYWxtZXJwZW5ndWlucykNCg0KIyBDaGVjayB0aGUgc3RydWN0dXJlDQpzdHIocGVuZ3VpbnMpDQoNCiMgUmVhZCBpbiB0aGUgbGFrZXMgZGF0YSBmaWxlLCBwYXJzaW5nIHRoZSBsYWtlIA0KIyBuYW1lIGNvbHVtbiBhcyBhIGZhY3Rvcg0KbGFrZXMgPC0gcmVhZC5jc3YoImRhdGEvTlpfbGFrZV9jaGxhX2RhdGEuY3N2Iiwgc3RyaW5nc0FzRmFjdG9ycyA9IFRSVUUpDQoNCiMgU2luY2UgdGhleSBhcmUgY29uY2VwdHVhbGx5IGNhdGVnb3JpY2FsIGluIHRoaXMgZGF0YSBzZXQsIA0KIyB5b3UgbWF5IHdpc2ggdG8gY2FzdCBZZWFyIGFuZCBNb250aCB0byBmYWN0b3JzIGFzIHdlbGwsIGZvciBjb21wbGV0ZW5lc3MuLi4NCmxha2VzJFllYXIgPC0gYXMuZmFjdG9yKGxha2VzJFllYXIpDQpsYWtlcyRNb250aCA8LSBhcy5mYWN0b3IobGFrZXMkTW9udGgpICANCg0KIyBDaGVjayB0aGUgc3RydWN0dXJlDQpzdHIobGFrZXMpDQpgYGANCg0KDQojIyBWaXN1YWxpc2UgdGhlIGRhdGEgKHJldmlzaW9uKQ0KDQpXaGVuIGZhY2VkIHdpdGggYSBuZXcgZGF0YSBzZXQsIG15IGZpcnN0IHN0ZXAgaXMgaW52YXJpYWJseSB0byBzdGFydCBtYWtpbmcgZ3JhcGhzLiBUaGVzZSAicGljdHVyZXMiIG9mIHlvdXIgZGF0YSBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIHNlZSBsYXJnZS1zY2FsZSBwYXR0ZXJucyB0aGF0IHdpbGwgaGVscCBndWlkZSB5b3VyIGZ1cnRoZXIgYW5hbHlzaXMuIFRoZXkgYWxzbyBoZWxwIHlvdSB0byBjYXRjaCBhbnkgcHJvYmxlbXMgaW4geW91ciBkYXRhIChzZWUgdGhlIHNrZXduZXNzIGV4ZXJjaXNlIGluIHRoZSBab29tIE5vdGVzIGZvciB0aGlzIG1vZHVsZSkgdGhhdCBtdXN0IGJlIGFkZHJlc3NlZCBiZWZvcmUgcHJvY2VlZGluZyB0byBtb3JlIGNvbXBsZXggYW5hbHlzZXMuDQoNCkFuIGV4Y2VsbGVudCBmaXJzdCBncmFwaCBmb3IgY29udGludW91cyAoaS5lLiBub3QgY2F0ZWdvcmljYWwpIGRhdGEgaXMgdGhlICoqZnJlcXVlbmN5IGRpc3RyaWJ1dGlvbioqLCAgb3IgKipoaXN0b2dyYW0qKiwgd2hpY2ggaGFzIGRhdGEgdmFsdWUgb24gdGhlIHgtYXhpcyBhbmQgZnJlcXVlbmN5IChpLmUuIGNvdW50IG9yIHByb3BvcnRpb24pIG9uIHRoZSB5LWF4aXMuIFRoaXMgc2hvd3MgeW91LCBpbiBhIHNpbmdsZSBwaWN0dXJlLCBob3cgeW91ciBkYXRhIGFyZSBkaXN0cmlidXRlZC4gV2UgbWV0IHRoZSBoaXN0b2dyYW0gaW4gTW9kdWxlIDAyLiANCg0KVGhlIGBwZW5ndWluc2AgZGF0YSBzZXQgY29udGFpbnMgdmFsdWVzIGZvciAzNDQgZGlmZmVyZW50IHBlbmd1aW5zLiBXZSBjYW4gYmVnaW4gYnkgbG9va2luZyBhdCBob3cgdGhlIHBlbmd1aW5zJyBib2R5IHdlaWdodHMgYXJlIGRpc3RyaWJ1dGVkLiANCg0KIyMjIFdpdGggQmFzZSBSDQoNCmBgYHtyIDA0LWhpc3RvZ3JhbXMsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9DQojIFRoZSAnYnJlYWtzJyBhcmd1bWVudCBjb250cm9scyB0aGUgbnVtYmVyIG9mIGJhcnMgZHJhd24NCmhpc3QocGVuZ3VpbnMkYm9keV9tYXNzX2csIA0KICAgICBicmVha3MgPSAxMDAsDQogICAgIG1haW49IkRpc3RyaWJ1dGlvbiBvZiBQZW5ndWluIEJvZHkgTWFzcyIsIHhsYWIgPSAiQm9keSBtYXNzIChnKSIsIHlsYWIgPSAiRnJlcXVlbmN5IikNCmBgYA0KDQojIyMgV2l0aCBnZ3Bsb3QNCg0KYGBge3IgZ2dwbG90IGhpc3RvLCAsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9DQojIExvYWQgdGhlIGxpYnJhcnkgYmVmb3JlIHlvdXIgZmlyc3QgY2FsbCB0byBnZ3Bsb3QNCmxpYnJhcnkoZ2dwbG90MikNCg0KIyBUaGUgdmFsdWVzIHByb3ZpZGVkIHRvICdjb2xvdXInIGFuZCAnZmlsbCcgYXJlIGhleGlkZWNpbWFsIGNvbG91ciBjb2Rlcy4gTm90ZSB0aGUgDQojIGhhc2ggbWFyayBwcmVmaXguIEl0IGlzIHJlcXVpcmVkLg0KIyBUaGUgJ2xhYnMnIGxheWVyIGNvbnRyb2xzIGdyYXBoIHRpdGxlIGFuZCBheGlzIGxhYmVscw0KZ2dwbG90KGRhdGEgPSBwZW5ndWlucywgbWFwcGluZyA9IGFlcyh4ID0gYm9keV9tYXNzX2cpKSArDQogIGdlb21faGlzdG9ncmFtKGNvbG91ciA9ICIjNzEzM2ZmIiwgZmlsbD0iI2JiYmJmZiIpICsNCiAgbGFicyh0aXRsZSA9ICJEaXN0cmlidXRpb24gb2YgUGVuZ3VpbiBCb2R5IE1hc3MiLCB4ID0gIkJvZHkgTWFzcyAoZykiLCB5ID0gIkZyZXF1ZW5jeSIpICsgdGhlbWVfYncoKQ0KYGBgDQoNCiMjIyBJbGx1c3RyYXRpbmcgR3JvdXBzDQoNClVzaW5nIGdncGxvdCwgd2UgY2FuIGlsbHVzdHJhdGUgZ3JvdXAgZWZmZWN0cyBpbiBoaXN0b2dyYW1zIGJ5IGRlZmluaW5nIGEgbWFwcGluZyBmcm9tIGEgZ3JvdXBpbmcgKGkuZS4gY2F0ZWdvcmljYWwpIHZhcmlhYmxlIHRvIHRoZSBgZmlsbGAgcHJvcGVydHkgb2YgZnVuY3Rpb24gYGdlb21faGlzdG9ncmFtYC4gRm9yIGV4YW1wbGUsIHRoZSBjb2RlIGJlbG93IHdpbGwgbWFrZSBoaXN0b2dyYW1zIG9mIGFsbCB0aGUgQ2hsQSB2YWx1ZXMgaW4gZGF0YSBmcmFtZSBgbGFrZXNgLCB3aXRoIGVhY2ggbGFrZSBpbiBhIGRpZmZlcmVudCBjb2xvdXINCg0KQnkgZGVmYXVsdCwgZ2VvbV9oaXN0b2dyYW0gcHJvZHVjZXMgYSBzdGFja2VkIHBsb3QgLS0gdGhhdCBpcywgdGhlIGRpZmZlcmVudCBncm91cHMgYXJlIHNob3duIHN0YWNrZWQgdXAgaW4gYSBzaW5nbGUgYmFyLCBzZXBhcmF0ZWQgYnkgdGhlaXIgY29sb3VyLiBUbyBtYWtlIHRoZSBwbG90IHdpdGggc2lkZS1ieS1zaWRlIGJhcnMsIHNldCBnZW9tX2hpc3RvZ3JhbSdzIGBwb3NpdGlvbmAgYXJndW1lbnQgdG8gYGRvZGdlYC4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IGEgbWFwcGluZywgaXQgaXMgc2ltcGx5IGFuIGFyZ3VtZW50IHRvIGZ1bmN0aW9uIGdlb21faGlzdG9ncmFtLiBXaGF0IGRvZXMgdGhpcyBzaW1wbGUgZ3JhcGggdGVsbCB5b3UgYWJvdXQgdGhlIGhlYWx0aCBvZiB0aGVzZSB0aHJlZSBsYWtlcz8NCg0KYGBge3IgMDQtbGFrZV9oaXN0cywgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0NCiMgU3RhY2tlZCBncm91cGVkIGhpc3RvZ3JhbQ0KZ2dwbG90KGRhdGEgPSBsYWtlcywgbWFwcGluZyA9IGFlcyh4ID0gQ2hsQSkpICsNCiAgZ2VvbV9oaXN0b2dyYW0oYWVzKGZpbGw9TGFrZU5hbWUpLCBjb2xvdXIgPSAnYmxhY2snKQ0KDQojIFNpZGUtYnktc2lkZSBncm91cGVkIGhpc3RvZ3JhbQ0KZ2dwbG90KGRhdGEgPSBsYWtlcywgbWFwcGluZyA9IGFlcyh4ID0gQ2hsQSkpICsNCiAgZ2VvbV9oaXN0b2dyYW0oYWVzKGZpbGw9TGFrZU5hbWUpLCBjb2xvdXIgPSAnYmxhY2snLCBwb3NpdGlvbj0iZG9kZ2UiKQ0KDQpgYGANCg0KDQojIyBEaXN0cmlidXRpb24gZ3JhcGhzIGZvciBjYXRlZ29yaWNhbCBkYXRhDQoNClRoZSBmdW5jdGlvbnMgYGhpc3RgIGFuZCBgZ2VvbV9oaXN0b2dyYW1gIGFyZSBhcHByb3ByaWF0ZSBmb3IgKipjb250aW51b3VzKiogKG51bWVyaWNhbCkgZGF0YS4gRm9yICoqY2F0ZWdvcmljYWwqKiB2YXJpYWJsZXMgKGUuZy4gU3BlY2llcyBhbmQgSXNsYW5kIGluIHRoZSBwZW5ndWluIGRhdGEgc2V0KSBvbmUgb2Z0ZW4gdXNlcyB0aGUgbW9yZSBnZW5lcmFsIGBnZW9tX2JhcmAgZnVuY3Rpb24gKGdlb21faGlzdG9ncmFtIGlzIGEgc3BlY2lhbCBjYXNlIG9mIGdlb21fYmFyKS4gVGhlIGV4YW1wbGUgY29kZSBiZWxvdyBzaG93cyBob3cgdG8gZ2VuZXJhdGUgYSBiYXIgZ3JhcGggaW4gZ2dwbG90LCBtb2RpZnlpbmcgdGhlIGRlZmF1bHQgZ2dwbG90IGNvbG91ciBwYWxldHRlIHRvIHNvbWV0aGluZyBtb3JlIGFjY2Vzc2libGUgdG8gdmlld2VycyB3aXRoIGF0eXBpY2FsIGNvbG91ciB2aXNpb246DQoNCg0KYGBge3IgMDQtY2F0ZWdvcmljYWxfZGlzdHJpYnV0aW9ufQ0KIyAiQ29sb3VyLWJsaW5kIGZyaWVuZGx5IiBwYWxldHRlIGZyb20gI2h0dHBzOi8vcGVyc29uYWwuc3Jvbi5ubC9+cGF1bHQvDQojIFRoZXNlIGFyZSBoZXhhZGVjaW1hbCBjb2xvdXIgY29kZXMuIFRoZSAjIGlzIHJlcXVpcmVkLg0KY3VzdG9tUGFsZXR0ZSA8LSBjKCIjRERBQTMzIiwgIiNCQjU1NjYiLCAiIzAwNDQ4OCIpDQoNCiMgR2VuZXJhdGUgYSBzdGFja2VkIGJhciBwbG90LCBhbmQgdXNlIG91ciBjdXN0b20gY29sb3VyIHBhbGV0dGUNCmdncGxvdChkYXRhID0gcGVuZ3VpbnMpICsNCiAgZ2VvbV9iYXIoYWVzKHggPSBpc2xhbmQsIGZpbGw9c3BlY2llcyksIHBvc2l0aW9uID0gInN0YWNrIikgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21QYWxldHRlKQ0KYGBgDQoNCkV2ZW4gYSBzaW1wbGUgZ3JhcGggbGlrZSB0aGlzIGhlbHBzIHlvdSB0byBnZXQgdG8ga25vdyB5b3VyIGRhdGEuIEp1c3QgYnkgaW5zcGVjdGlvbiB3ZSBzZWUgdGhhdCBCaXNjb2UgaXNsYW5kIGhhcyB0aGUgbGFyZ2VzdCBwb3B1bGF0aW9uLCBUb3JnZXJzZW4gaGFzIG9ubHkgQWRlbGllIHBlbmd1aW5zLCBEcmVhbSBJc2xhbmQgaGFzIG5lYXJseSBlcXVhbCBudW1iZXJzIG9mIENoaW5zdHJhcCBhbmQgR2VudG9vLCBldGMuIFdoZW4gZmlyc3QgYXBwcm9hY2hpbmcgYSBiaWcgZGF0YSBzZXQsIGFsd2F5cyB0aGluayBhYm91dCBzdGFydGluZyB3aXRoIHNvbWUgZ3JhcGhzLg0KDQoNCiMjIyBFeGVyY2lzZSAyDQoNClRoZSBiYXIgZ3JhcGggYWJvdmUgaXMgaW4gInN0YWNrZWQiIGZvcm1hdC4gU29tZSBwZW9wbGUgcHJlZmVyIGJhciBncmFwaHMgdG8gaGF2ZSBzZXBhcmF0ZSBiYXJzIGZvciBlYWNoIGdyb3VwLCBhcyBzaG93biBiZWxvdy4gV3JpdGUgdGhlIGNvZGUgbmVlZGVkIHRvIGdlbmVyYXRlIHRoaXMgZ3JhcGguIEhpbnQ6IFRoaXMgcmVxdWlyZXMgY2hhbmdpbmcgb25seSB0aGUgdmFsdWUgb2Ygb25lIGFyZ3VtZW50IGluIHRoZSBjb2RlIGFib3ZlLg0KDQoNCmBgYHtyIDA0LWNhdGVnb3JpY2FsX2Rpc3RyaWJ1dGlvbl9kb2RnZSwgZWNobz1GQUxTRSwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0NCg0KIyAiQ29sb3VyLWJsaW5kIGZyaWVuZGx5IiBwYWxldHRlIGZyb20gI2h0dHBzOi8vcGVyc29uYWwuc3Jvbi5ubC9+cGF1bHQvDQojIFRoZXNlIGFyZSBoZXhhZGVjaW1hbCBjb2xvdXIgY29kZXMuIFRoZSAjIGlzIHJlcXVpcmVkLg0KY3VzdG9tUGFsZXR0ZSA8LSBjKCIjRERBQTMzIiwgIiNCQjU1NjYiLCAiIzAwNDQ4OCIpDQoNCiMgR2VuZXJhdGUgYSBzdGFja2VkIGJhciBwbG90LCBhbmQgdXNlIG91ciBjdXN0b20gY29sb3VyIHBhbGV0dGUNCmdncGxvdChkYXRhID0gcGVuZ3VpbnMpICsNCiAgZ2VvbV9iYXIoYWVzKHggPSBpc2xhbmQsIGZpbGw9c3BlY2llcyksIHBvc2l0aW9uID0gImRvZGdlIiwgY29sb3IgPSAiYmxhY2siKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbVBhbGV0dGUpDQpgYGANCg0KIyMgTWVhc3VyZXMgb2YgQ2VudHJhbCBUZW5kZW5jeQ0KDQpMb29rIGF0IHRoZSBncmFwaCB5b3UgbWFkZSBlYXJsaWVyIHNob3dpbmcgdGhlIGRpc3RyaWJ1dGlvbnMgb2YgQ2hsQSBmb3IgdGhlIHRocmVlIGxha2VzLiBZb3UgbWlnaHQgZGVzY3JpYmUgdGhlIExha2UgRWxsZXNtZXJlIENobEEgcmVhZGluZ3MgYXMgIm1vc3RseSBiZXR3ZWVuIDUwIGFuZCAxMDAiIGFuZCB0aGUgTGFrZSBSb3RvcnVhIHJlYWRpbmdzIGFzICJtb3N0bHkgYXJvdW5kIDEwIi4gIFN0YXRlbWVudHMgbGlrZSB0aGlzIGFyZSBhdHRlbXB0cyB0byBkZXNjcmliZSBhICoqdHlwaWNhbCoqIHNjb3JlIGZyb20gYSBsYXJnZSBkYXRhIHNldC4gVGhleSBhbGxvdyB1cyB0byBjYXB0dXJlIHRoZSBmYWN0IHRoYXQsIGZvciBleGFtcGxlLCAqb3ZlcmFsbCosIExha2UgRWxsZXNtZXJlIGhhcyBoaWdoZXIgQ2hsQSByZWFkaW5ncyB0aGFuIExha2UgUm90b3J1YS4gSXQgaXMgbm90IHRoZSBjYXNlIHRoYXQgKmV2ZXJ5KiBFbGxlc21lcmUgcmVhZGluZyBpcyBoaWdoZXIgdGhhbiAqZXZlcnkqIFJvdG9ydWEgcmVhZGluZywgYnV0ICoqdHlwaWNhbGx5KiogdGhpcyBpcyB0aGUgY2FzZS4gDQoNCkluIHN0YXRpc3RpY3MsIGEgcHJlY2lzZSBtZWFzdXJlIG9mIHN1Y2ggdHlwaWNhbGl0eSBpcyBjYWxsZWQgYSAqKk1lYXN1cmUgb2YgQ2VudHJhbCBUZW5kZW5jeSoqIChNQ1QpLiBUaGUgbW9zdCBjb21tb24gTUNUcyBhcmUgdGhlICoqbWVhbioqLCB0aGUgKiptZWRpYW4qKiBhbmQgdGhlICoqbW9kZSoqLiBUaGVzZSBhcmUsIHJlc3BlY3RpdmVseSwgdGhlIG1hdGhlbWF0aWNhbCBhdmVyYWdlLCB0aGUgbWlkZGxlIHNjb3JlLCBhbmQgdGhlIG1vc3QgZnJlcXVlbnQgc2NvcmUgKG9yIHNjb3JlcykgaW4gYSBkYXRhIHNldC4gVGhlcmUgYXJlIHNvbWUgc3VidGxlIHN0YXRpc3RpY2FsIGlzc3VlcyBhcm91bmQgd2hpY2ggb2YgdGhlIHRocmVlIE1DVCBpcyBhcHByb3ByaWF0ZSBmb3IgYW55IGdpdmVuIGRhdGEgYW5hbHlzaXMgc2l0dWF0aW9uIChhc2sgeW91ciBsZWN0dXJlciBmb3IgZGV0YWlscyksIGJ1dCB0aGV5IGFyZSBhbGwgZWFzeSB0byBjb21wdXRlIGluIFIgKHdlIGhhdmUsIGluIGZhY3QsIGFscmVhZHkgbWV0IGZ1bmN0aW9uIGBtZWFuYCBpbiBlYXJsaWVyIG1vZHVsZXMpLCBhbmQgd2Ugc2hvdyBleGFtcGxlIGNvZGUgYmVsb3cgZm9yIGNvbXB1dGluZyB0aGVzZSBkZXNjcmlwdGl2ZSBzdGF0aXN0aWNzIG9uIGEgc2luZ2xlIGNvbHVtbiBvZiBkYXRhIGZyb20gdGhlIHBlbmd1aW5zIGRhdGEgc2V0Lg0KDQpOb3RlIHRoYXQgdGhlIHBlbmd1aW5zIGRhdGEgaGFzIHNvbWUgbWlzc2luZyBzb21lIHZhbHVlcyAoY2YuIE1vZHVsZSAwMyAtIFN1YnNldHRpbmcpLCBUaGUgZnVuY3Rpb25zIGZvciBtZWFuIGFuZCBtZWRpYW4gd2lsbCBub3Qgd29yayBpZiB0aGUgaW5wdXQgZGF0YSBoYXZlIGFueSBgTkFgIChtaXNzaW5nKSB2YWx1ZXMuIFRoZSBtb3N0IGNvbW1vbiBzb2x1dGlvbiBpcyB0byBvbWl0IHRob3NlIHNjb3JlcyBmcm9tIHRoZSBjb21wdXRhdGlvbiBieSBzZXR0aW5nIHRoZSBgbmEucm1gIGFyZ3VtZW50IHRvIGBUUlVFYCBhcyBzaG93bjoNCg0KDQojIyMgTWVhbg0KDQpgYGB7ciBtZWFuLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQ0KIyBXZSBoYXZlIHNlZW4gdGhpcyBjb2RlIGJlZm9yZS4uLiBXZSBwYXNzIHRoZSBjb2x1bW4gb2YgaW50ZXJlc3QNCiMgdG8gZnVuY3Rpb24gbWVhbg0KbWVhbihwZW5ndWlucyRib2R5X21hc3NfZywgbmEucm09VFJVRSkNCmBgYA0KDQojIyMgTWVkaWFuDQoNCmBgYHtyIG1lZGlhbiwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0NCiMgVGhlIGZhbWlsaWFyIHBhdHRlcm4uLi4uDQptZWRpYW4ocGVuZ3VpbnMkYm9keV9tYXNzX2csIG5hLnJtID0gVFJVRSkNCmBgYA0KDQojIyMgTW9kZQ0KDQpCYXNlIFIgaGFzIG5vIGJ1aWx0LWluIGZ1bmN0aW9uIGZvciBtb2RlLiBBZnRlciBNb2R1bGUgMDggeW91IHdpbGwgYmUgYWJsZSB0byB3cml0ZSB5b3VyIG93biBNb2RlIGZ1bmN0aW9uLiBPciB5b3UgY2FuIHVzZSBvbmUgb2Ygc2V2ZXJhbCBhdmFpbGFibGUgaW4gYXV4aWxpYXJ5IGxpYnJhcmllcy4gVGhlIERlc2NUb29scyBsaWJyYXJ5IGlzIGEgZ29vZCBvbmUuDQoNCmBgYHtyIG1vZGUsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9DQoNCiMgSW5zdGFsbCB0aGUgcGFja2FnZSBvbmNlIG9uIGVhY2ggbWFjaGluZQ0KIyBpbnN0YWxsLnBhY2thZ2VzKCJEZXNjVG9vbHMiKQ0KDQojIExvYWQgdGhlIGxpYnJhcnkgb25jZSBlYWNoIHNlc3Npb24NCmxpYnJhcnkoRGVzY1Rvb2xzKQ0KDQojQ2FsbCB0aGUgZnVuY3Rpb24NCk1vZGUocGVuZ3VpbnMkYm9keV9tYXNzX2csIG5hLnJtPVRSVUUpDQoNCmBgYA0KDQpOb3RlIHRoYXQgRGVzY1Rvb2xzOjpNb2RlIHJldHVybnMgdGhlIG1vZGFsIChpLmUuIG1vc3QgY29tbW9uIHZhbHVlKSB3aXRoIGFuIGF0dGFjaGVkICoqYXR0cmlidXRlKiogY2FsbGVkICJmcmVxIiBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIG9jY3VyZW5jZXMuDQoNCiMjIFVzaW5nIGZ1bmN0aW9uIGBzdW1tYXJ5YA0KDQpXaGVuIHlvdSBoYXZlIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgZGF0YSBtZWFzdXJlcywgeW91IG1heSB3aXNoIHRvIGNvbXB1dGUgTUNUcyBmb3IgaW5kaXZpZHVhbCBjb2x1bW5zIGFzIHNob3duIGFib3ZlLiBBbiBlZmZpY2llbnQgYWx0ZXJuYXRpdmUgZm9yIHNtYWxsZXIgZGF0YSBzZXRzIGlzIHRvIHVzZSBmdW5jdGlvbiBgc3VtbWFyeWAsIHdoaWNoIGFjY2VwdHMgYSBkYXRhIGZyYW1lIGFuZCBzdW1tYXJpc2VzICphbGwqIGl0cyBjb2x1bW5zIGF0IG9uY2UuIEZ1bmN0aW9uIGBzdW1tYXJ5YCBjb21wdXRlcyBmcmVxdWVuY2llcyBmb3IgY2F0ZWdvcmljYWwgdmFyaWFibGVzLCBhbmQgbWVhc3VyZXMgb2YgY2VudHJhbCB0ZW5kZW5jeSBmb3IgY29udGludW91cyB2YXJpYWJsZXMuIEl0IGFsc28gcmVwb3J0cyB0aGUgbnVtYmVycyBvZiBOQSB2YWx1ZXMgaW4gZWFjaCBjb2x1bW4uIEZ1bmN0aW9uIGBzdW1tYXJ5YCBwcm92aWRlcyBzb21lIGFkZGl0aW9uYWwgbWVhc3VyZXMgKG1pbmltdW0sIDFzdCBxdWFydGlsZSwgM3JkIHF1YXJ0aWxlLCBhbmQgbWF4aW11bSkgdGhhdCB3ZSB3aWxsIGRpc2N1c3MgaW4gbW9yZSBkZXRhaWwgbGF0ZXIuDQoNCmBgYHtyIHN1bW1hcnl9DQpzdW1tYXJ5KHBlbmd1aW5zKQ0KYGBgDQoNCiMjIyBFeGVyY2lzZSAzDQoNClRoZSByZXN1bHRzIGZvciBjb2x1bW4gYHllYXJgIG1heSBub3QgYmUgd2hhdCB5b3UgZXhwZWN0ZWQuIEZ1bmN0aW9uIGBzdW1tYXJ5YCBoYXMgY29tcHV0ZWQgYW4gKmF2ZXJhZ2UgdmFsdWUqIGZvciBgeWVhcmAuIERvZXMgdGhpcyBzZWVtIGxpa2UgdGhlIGFwcHJvcHJpYXRlIGFuYWx5c2lzPyAoQW5zd2VyID0+IE5vLikgTW9kaWZ5IGBwZW5ndWluc2AgdG8gbWFrZSBgc3VtbWFyeWAgdHJlYXQgdGhlIGB5ZWFyYCBkYXRhIGNvcnJlY3RseSwgYW5kIHJlcnVuIGBzdW1tYXJ5YC4NCg0KDQojIyBNZWFzdXJlcyBvZiBWYXJpYWJpbGl0eQ0KDQpJbiB0aGUgaGlzdG9ncmFtcyBmb3IgQ2hsQSBmcm9tIGVhY2ggb2YgdGhyZWUgTmV3IFplYWxhbmQgbGFrZXMsIHRoZSB0aHJlZSBncm91cHMgb2Ygc2NvcmVzIGRpZCBub3Qgb3ZlcmxhcCBjb21wbGV0ZWx5LCBpbmRpY2F0aW5nIHRoYXQgdGhlIHR5cGljYWwgdmFsdWVzIC0tIHRoZSBjZW50cmFsIHRlbmRlbmNpZXMgLS0gd2VyZSBkaWZmZXJlbnQgZm9yIHRoZSB0aHJlZSBsYWtlcy4gV2UgY2FuIGNvbmZpcm0gdGhpcyBvYnNlcnZhdGlvbiBieSBjb21wYXJpbmcgdGhlIG1lYW5zLiBXZSBjYW4gdXNlIGZ1bmN0aW9uIGBhZ2dyZWdhdGVgIGluIGJhc2UgUiwgb3IgYGdyb3VwX2J5YCBhbmQgYHN1bW1hcmlzZWAsIGZyb20gbGlicmFyeSBkcGx5ci4NCg0KYGBge3IgbGFrZSBtZWFuc30NCiMgVXNpbmcgYWdncmVnYXRlLiBjb21wdXRlIHRoZSBncm91cCBtZWFucw0KYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU49bWVhbikNCg0KDQojIFVzaW5nIGdyb3VwX2J5IGFuZCBzdW1tYXJpc2UNCmxpYnJhcnkoZHBseXIpDQoNCmxha2VzICU+JSANCiAgZ3JvdXBfYnkoTGFrZU5hbWUpICU+JQ0KICBzdW1tYXJpc2UoTWVhbkNobEEgPSBtZWFuKENobEEpKQ0KDQoNCmBgYA0KDQpIb3dldmVyLCBub3Qgb25seSBkbyB0aGUgY2VudHJhbCBwb2ludHMgb2YgdGhlIHRocmVlIGxha2VzJyBkaXN0cmlidXRpb25zIGRpZmZlciwgc28gZG8gdGhlIGFtb3VudHMgb2YgInNwcmVhZCIuIExha2UgVGF1cG8ncyBkaXN0cmlidXRpb24gaXMgdmVyeSAic2tpbm55IjsgYWxsIGl0cyByZWFkaW5ncyBhcmUgc2ltaWxhci4gTGFrZSBFbGxlc21lcmUgaXMgc3F1YXNoZWQgYW5kIHNwcmVhZCBvdXQ7IGl0cyByZWFkaW5ncyB2YXJ5IGEgbG90LiBMYWtlIFJvdG9ydWEgaXMgaW50ZXJtZWRpYXRlLiBUbyBpbGx1c3RyYXRlIHRoaXMgbW9yZSBjbGVhcmx5LCB3ZSBjYW4gdXNlIGdncGxvdCB0byBtYWtlIHNlcGFyYXRlIGdyYXBocyBmb3IgZWFjaCBsYWtlLCB1c2luZyBmdW5jdGlvbiBgZmFjZXRfZ3JpZGAuIA0KDQpOb3RlIHRoZSBgc2NhbGVzYCBhcmd1bWVudCB0byBgZmFjZXRfZ3JpZGAuIFRoaXMgYWxsb3dzIGVhY2ggZ3JhcGggdG8gYWRqdXN0IGl0cyB5LWF4aXMgdG8gaXRzIGRhdGEgZG9tYWluLCB3aGljaCBtYWtlcyB0aGUgY29tcGFyaXNvbiB2aXN1YWxseSBlYXNpZXI7IHRoaXMgc2hvdWxkIGJlIG1lbnRpb25lZCBpbiB0aGUgZGlzY3Vzc2lvbiBvZiB0aGUgZmlndXJlIGluIGEgbWFudXNjcmlwdC4NCg0KYGBge3IgZmFjZXRfZ3JhcGhzLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQ0KZ2dwbG90KGRhdGEgPSBsYWtlcykgKw0KICBnZW9tX2hpc3RvZ3JhbShhZXMoeCA9IENobEEsIGZpbGw9TGFrZU5hbWUpLCBjb2xvcj0iYmxhY2siKSArDQogIGZhY2V0X2dyaWQocm93cyA9IHZhcnMoTGFrZU5hbWUpLCBzY2FsZXM9ImZyZWVfeSIpDQpgYGANCg0KU3RhdGlzdGljYWxseSwgdGhlICJzcHJlYWQgb3V0IiBxdWFsaXR5IG9mIGEgZGlzdHJpYnV0aW9uIHJlZmxlY3RzIGl0cyAqKnZhcmlhYmlsaXR5KiouDQoNCldlIGNhbiBjYXB0dXJlIHZhcmlhYmlsaXR5IG1vcmUgcHJlY2lzZWx5IHdpdGggbWVhc3VyZXMgb2YgdGhlICoqcmFuZ2UqKiBvZiB0aGUgZGF0YSBzZXQuIFRoZXNlIGFyZSB0eXBpY2FsbHkgdGhlIHNtYWxsZXN0IGFuZCBsYXJnZXN0IHNjb3JlcyAobWluaW11bSBhbmQgbWF4aW11bSkgYW5kIHRoZSBzY29yZXMgYXQgdGhlIDI1dGggYW5kIDc1dGggcGVyY2VudGlsZXMgKGFsc28gY2FsbGVkICoqMXN0IHF1YXJ0aWxlKiogYW5kICoqM3JkIHF1YXJ0aWxlKiopLiBFYXJsaWVyLCB3ZSBzYXcgdGhhdCBmdW5jdGlvbiBgc3VtbWFyeWAgY29tcHV0ZXMgdGhlc2UgbWVhc3VyZXMgb2YgcmFuZ2UuIEhvd2V2ZXIsIGlmIHdlIHNpbXBseSBwYXNzIHRoZSBlbnRpcmUgYGxha2VzYCBkYXRhIGZyYW1lIHRvIGZ1bmN0aW9uIGBzdW1tYXJ5YCwgaXQgd2lsbCBjb21iaW5lIHRoZSBkYXRhIGZyb20gYWxsIHRocmVlIGxha2VzIC0tIHRvIGNvbXBhcmUgdGhlIGxha2VzIHdlIG5lZWQgdGhlIHZhbHVlcyBmcm9tIGVhY2ggbGFrZSBzZXBhcmF0ZWx5Lg0KDQpJbiBlYXJsaWVyIG1vZHVsZXMgd2UgaGF2ZSBzZWVuIHR3byB0ZWNobmlxdWVzIGZvciBzZWxlY3Rpbmcgb3V0IGp1c3QgdGhlIHJvd3MgZnJvbSBvbmUgbGFrZSAodXNpbmcgW10gb3IgdXNpbmcgYGZpbHRlcmApLiBUbyBydW4gZnVuY3Rpb24gYHN1bW1hcnlgIG9uIGVhY2ggbGFrZSBzZXBhcmF0ZWx5LCB3ZSBjb3VsZCBzZWxlY3QgdGhlIHN1YnNldCBmb3IgZWFjaCBsYWtlIGluIHR1cm4sIGFuZCBwYXNzIGVhY2ggc3Vic2V0IHRvIGBzdW1tYXJ5YC4gSG93ZXZlciwgd2UgY2FuIGFjaGlldmUgdGhlIHNhbWUgcmVzdWx0IG1vcmUgcGFyc2ltb25pb3VzbHkgYnkgdXNpbmcgZnVuY3Rpb24gYGFnZ3JlZ2F0ZWAuIEFib3ZlIHdlIHVzZWQgYWdncmVnYXRlIHdpdGggYEZVTiA9IG1lYW5gIHRvIGdldCB0aGUgbWVhbiBDaGxBIGZvciBlYWNoIGxha2UuIFdlIGNhbiB1c2UgYEZVTiA9IHN1bW1hcnlgIHRvIGNhbGwgZnVuY3Rpb24gYHN1bW1hcnlgIHNlcGFyYXRlbHkgZm9yIHRoZSByZWNvcmRzIG9mIGVhY2ggbGFrZS4gDQoNCmBgYHtyIGFnZ3JlZ2F0ZSBzdW1tYXJ5fQ0KDQojIFVzaW5nIGFnZ3JlZ2F0ZQ0KYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU49c3VtbWFyeSkNCg0KYGBgDQoNCldlIGNhbiBhbHNvIG1lYXN1cmUgdGhlIHZhcmlhYmxpdHkgaW4gYSBkYXRhIHNldCB3aXRoIHRoZSAqKnN0YW5kYXJkIGRldmlhdGlvbioqLiBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWVhc3VyZSBvZiB2YXJpYWJpbGl0eSwgYW5kIGl0IHBsYXlzIGFuIGltcG9ydGFudCBtYXRoZW1hdGljYWwgcm9sZSBpbiBpbmZlcmVudGlhbCBzdGF0aXN0aWNzIChhc2sgeW91ciBzdGF0cyBsZWN0dXJlciBmb3IgZGV0YWlscyAtLSBpdCdzIHZlcnkgaW50ZXJlc3RpbmcpLiBDb25jZXB0dWFsbHksIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gaXMgKmFsbW9zdCogZXF1YWwgdG8gdGhlIGF2ZXJhZ2UgZGlzdGFuY2UgZnJvbSB0aGUgbWVhbiBhY3Jvc3MgYWxsIHRoZSB2YWx1ZXMgaW4gYSBkYXRhIHNldCAtLSBpdCBkb2Vzbid0IGVxdWFsICpleGFjdGx5KiB0aGF0IHZhbHVlLCBiZWNhdXNlIG9mIGhvdyBpdCBpcyBjb21wdXRlZCwgYnV0IGl0IGlzIGNsb3NlLCBhbmQgaXQgY2FuIGJlIGhlbHBmdWwgdG8gdGhpbmsgb2YgaXQgd2l0aCB0aGlzIGFwcHJveGltYXRpb24uIEJpZyBzdGFuZGFyZCBkZXZpYXRpb24gc2hvd3MgdGhhdCBzY29yZXMgYXJlIHNwcmVhZCBmYXIgZnJvbSB0aGVpciBtZWFuOyBzbWFsbCBzdGFuZGFyZCBkZXZpYXRpb24gc2hvd3MgdGhhdCBzY29yZXMgdGVuZCB0byBodWRkbGUgY2xvc2UgdG8gdGhlaXIgbWVhbi4gQ29tcHV0ZSBzdGFuZGFyZCBkZXZpYXRpb24gd2l0aCBmdW5jdGlvbiBgc2RgLg0KDQpgYGB7ciBzZH0NCg0KIyBVc2luZyBhZ2dyZWdhdGUuIGNvbXB1dGUgdGhlIGdyb3VwIHNkcw0KYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU49c2QpDQoNCg0KIyBVc2luZyBncm91cF9ieSBhbmQgc3VtbWFyaXNlDQoNCmxha2VzICU+JSANCiAgZ3JvdXBfYnkoTGFrZU5hbWUpICU+JQ0KICBzdW1tYXJpc2UoU3RkRGV2ID0gc2QoQ2hsQSkpDQoNCmBgYA0KDQpUaGUgaGlzdG9ncmFtcywgdGhlIG1lYXN1cmVzIG9mIHJhbmdlLCBhbmQgdGhlIHN0YW5kYXJkIGRldmlhdGlvbnMgYWxsIGluZGljYXRlIHRoYXQgVGF1cG8gaGFzIHZlcnkgc3RhYmxlIENobEEgbWVhc3VyZXMsIFJvdG9ydWEgaXMgYSBsaXR0bGUgbm9pc2llciwgYW5kIEVsbGVzbWVyZSBpcyBhbGwgb3ZlciB0aGUgcGxhY2UuIFRoaXMgcGh5dG9wbGFua3RvbiBiaW9tYXNzIHN0YWJpbGl0eSBpcyBhbiBpbXBvcnRhbnQgaW5kaWNhdG9yIG9mIGxha2UgaGVhbHRoIC0tIGEgc3RhYmxlIGxha2UgaXMgYXQgbXVjaCBsb3dlciByaXNrIG9mIGEgdG94aWMgYWxnYWwgYmxvb20uDQoNCg0KIyMgRWZmaWNpZW50IGNvZGUgZm9yIGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MNCg0KVGhlIGZ1bmN0aW9uIGBkZXNjcmliZUJ5YCBpbiBwYWNrYWdlIGBwc3ljaGAgd2lsbCAgY29tcHV0ZSBhbGwgdGhlIGRlc2NyaXB0aXZlIHN1bW1hcmllcyB3ZSBoYXZlIHNlZW4gKGFuZCBhIGZldyBtb3JlKSBpbiBvbmUgc3RhdGVtZW50LiBXaGVuIHlvdSBhcmUgZXhwbG9yaW5nIGEgc2luZ2xlIGRhdGEgY29sdW1uIGFuZCBhIHNpbmdsZSBncm91cGluZyBjb2x1bW4gKHNvIHRoZSBvdXRwdXQgZG9lc24ndCBnZXQgdG9vIGxhcmdlKSwgdGhpcyBpcyBhIHZlcnkgdXNlZnVsIGZ1bmN0aW9uLiANCg0KDQpgYGB7ciBwc3ljaH0NCiMgSW5zdGFsbCBvbmNlIG9uIGFueSBjb21wdXRlcg0KI2luc3RhbGwucGFja2FnZXMoInBzeWNoIikNCg0KIyBDYWxsIG9uY2UgZWFjaCBSIHNlc3Npb24NCmxpYnJhcnkocHN5Y2gpDQoNCiMgUGFzcyBpbiB0aGUgZGF0YSBjb2x1bW4gYW5kIHRoZSBncm91cGluZyBjb2x1bW4NCmRlc2NyaWJlQnkobGFrZXMkQ2hsQSwgbGFrZXMkTGFrZU5hbWUpDQpgYGANCg0KUGFja2FnZSBgcHN5Y2hgIGNvbnRhaW5zIG1hbnkgb3RoZXIgaW50ZXJlc3Rpbmcgc3RhdGlzdGljYWwgdG9vbHMsIGVzcGVjaWFsbHkgZm9yIG11bHRpdmFyaWF0ZSBkYXRhIHNldHMgY29tbW9ubHkgZm91bmQgaW4gcHN5Y2hvbG9naWNhbCBhbmQgZWNvbG9naWNhbCByZXNlYXJjaC4gQXNrIEdvb2dsZSBvciB5b3VyIGxlY3R1cmVyIGZvciBkZXRhaWxzLg0KDQojIyBFeHBsb3JpbmcgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHR3byB2YXJpYWJsZXMNClRoZSBwcmVjZWRpbmcgZGVzY3JpcHRpdmUgc3RhdGlzdGljcyBhbGwgbG9va2VkIGF0IGRhdGEgbWVhc3VyZXMgLS0gQ2hsQSwgYmlsbCBsZW5ndGgsIGJvZHkgd2VpZ2h0LCBldGMuIC0tIGluZGl2aWR1YWxseSwgc3VtbWFyaXNpbmcgdGhlaXIgZGlzdHJpYnV0aW9uLCBjZW50cmFsIHRlbmRlbmN5IGFuZCB2YXJpYWJpbGl0eS4gT2Z0ZW4sIGhvd2V2ZXIsIHdlIGFyZSBpbnRlcmVzdGVkIGluIGRlc2NyaWJpbmcgKip0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gZGF0YSBtZWFzdXJlcyoqLiBGb3IgZXhhbXBsZSwgd2UgbWlnaHQgd2FudCB0byBrbm93IGlmIGhlYXZpZXIgcGVuZ3VpbnMgYWxzbyB0ZW5kIHRvIGhhdmUgbG9uZ2VyIGJpbGxzLiBUaGlzIHR5cGUgb2YgcmVsYXRpb25zaGlwIGlzIGNhbGxlZCBhICoqY29ycmVsYXRpb24qKi4gV2hlbiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgbWVhc3VyZSBmb3IgZWFjaCBleHBlcmltZW50YWwgcGFydGljaXBhbnQgKG9yIGVhY2ggcGVuZ3Vpbiwgb3IgZWFjaCBsYWtlKSB3ZSBjYW4gZXhwbG9yZSBjb3JyZWxhdGlvbnMgYmV0d2VlbiBwYWlycyBvZiBtZWFzdXJlcyBncmFwaGljYWxseSB3aXRoIGEgKipzY2F0dGVycGxvdCoqLiBBIHNjYXR0ZXJwbG90IGhhcyBvbmUgbWVhc3VyZSBvbiBlYWNoIGF4aXMsIGFuZCBvbmUgcG9pbnQgZm9yIGVhY2ggcGFydGljaXBhbnQncyBwYWlyIG9mIHNjb3Jlcy4NCg0KSW4gdGhlIGNvZGUgZXhhbXBsZSBiZWxvdyB3ZSBtYWtlIGEgc2NhdHRlcnBsb3Qgd2l0aCBnZ3Bsb3QgKGNmLiBNb2R1bGUgMDIpLCBhbmQgc2hvdyBob3cgdG8gYWRkIGEgKipsaW5lYXIgdHJlbmQgbGluZSoqLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgdGhlIGxpbmUgdGhhdCBydW5zIHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgc2NhdHRlcnBsb3QgcG9pbnRzLCBhbmQgaXQgaGVscHMgdXMgdG8gc2VlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJlbGF0aW9uc2hpcC4gTWF0aGVtYXRpY2FsbHksIHRyZW5kIGxpbmVzIGFyZSBhY3R1YWxseSB2ZXJ5IGNvbXBsaWNhdGVkIHRoaW5ncywgYW5kIHdlIGdlbmVyYXRlIHRoZW0gd2l0aCB0aGUgcG93ZXJmdWwgZnVuY3Rpb24gYGxtYCwoZm9yICoqbGluZWFyIG1vZGVsKiopLiBZb3Ugd2lsbCBsZWFybiBhYm91dCB0aGUgbWFueSBmYXNjaW5hdGluZyB0aGluZ3MgeW91IGNhbiBkbyB3aXRoIGxpbmVhciBtb2RlbGluZyBpZiB5b3UgdGFrZSBhZHZhbmNlZCBzdGF0aXN0aWNzIHBhcGVycy4NCg0KDQpgYGB7ciAwNC1zY2F0dGVycGxvdCwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0NCiMgZ2VvbV9wb2ludCBwbG90cyB0aGUgcG9pbnRzIG9mIHRoZSBzY2F0dGVycGxvdCANCg0KIyBnZW9tX3Ntb290aCBwbG90cyB0aGUgbGluZWFyIHRyZW5kIGxpbmUgY29tcHV0ZWQgd2l0aCBmdW5jdGlvbiBsbQ0KDQojIFRoZSBzZSBhcmd1bWVudCBkZXRlcm1pbmVzIHdoZXRoZXIgZXJyb3IgYmFycyBhcmUgc2hvd24gDQojIGFyb3VuZCB0aGUgdHJlbmQgbGluZS4NCg0KZ2dwbG90KGRhdGEgPSBwZW5ndWlucywgbWFwcGluZyA9IGFlcyh4ID0gYm9keV9tYXNzX2csIHkgPSBiaWxsX2xlbmd0aF9tbSkpICsNCiAgZ2VvbV9wb2ludCgpICsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgc2U9RkFMU0UpDQoNCmBgYA0KDQpUaGUgc2NhdHRlcnBsb3QgZ2l2ZXMgdXMgYSB2ZXJ5IGNsZWFyIHBpY3R1cmU6IHRob3NlIHBlbmd1aW5zIHdpdGggaGlnaGVyIGJvZHkgd2VpZ2h0cyB0ZW5kIHRvIGFsc28gaGF2ZSBsb25nZXIgYmlsbHMsIGFuZCB0aGlzIGlzIHJlZmxlY3RlZCBpbiB0aGUgcG9zaXRpdmUgc2xvcGUgb2YgdGhlIHRyZW5kbGluZS4gTm90ZSBob3dldmVyIHRoYXQgdGhpcyBpcyBub3QgYW4gYWJzb2x1dGUgcnVsZS4gSXMgaXQgZWFzeSB0byBmaW5kIHBhaXJzIG9mIHBvaW50cyBzdWNoIHRoYXQgdGhlIGxpZ2h0ZXIgb2YgdHdvIHBlbmd1aW5zIGhhcyB0aGUgbG9uZ2VyIGJpbGwuIFRoaXMgaXMgdHlwaWNhbCBvZiBjb3JyZWxhdGlvbmFsIGRhdGEuIA0KDQpUaGVyZSBhcmUgdmFyaW91cyBzdGF0aXN0aWNhbCBtZWFzdXJlcyB0aGF0IGNhcHR1cmUgdGhlIHN0cmVuZ3RoIG9mIGEgY29ycmVsYXRpb24gKGkuZS4gaG93IGNsb3NlIGl0IGlzIHRvIGJlaW5nIGFuIGFic29sdXRlIHJ1bGUpLiBGb3IgY29udGludW91cywgbnVtZXJpY2FsIGRhdGEgKHN1Y2ggYXMgYmlsbCBsZW5ndGggYW5kIGJvZHkgd2VpZ2h0KSB1c2UgdGhlIFIgZnVuY3Rpb24gYGNvcmAgdG8gY29tcHV0ZSB0aGUgbnVtZXJpY2FsIGNvcnJlbGF0aW9uIHZhbHVlLiBBcyB3aXRoIG1lYW5zIGFuZCBtZWRpYW5zLCB3ZSBtdXN0IHRlbGwgYGNvcmAgaG93IHRvIGNvcGUgd2l0aCBtaXNzaW5nIGRhdGEgKE5BIHNjb3JlcykuIFVuZm9ydHVuYXRlbHkgdGhlIHN5bnRheCBpcyBub3QgY29uc2lzdGVudCBhY3Jvc3MgdGhlIGZ1bmN0aW9ucy4gRm9yIGZ1bmN0aW9uIGBtZWFuYCB3ZSBzZXQgYXJndW1lbnQgYG5hLnJtID0gVFJVRWAuIEZvciBmdW5jdGlvbiBgY29yYCB3ZSBtdXN0IHNldCBhcmd1bWVudCBgdXNlID0gImNvbXBsZXRlLm9icyJgLCBtZWFuaW5nIHRoYXQgd2Ugd2FudCB0aGUgZnVuY3Rpb24gdG8gdXNlIG9ubHkgdGhvc2Ugcm93cyB0aGF0IGFyZSBjb21wbGV0ZSAoaS5lLiBoYXZlIGJvdGggdmFsdWVzKS4gVGhlc2UgaWRpb3N5bmNyYWNpZXMgb2NjdXIgZnJvbSB0aW1lIHRvIHRpbWUgaW4gUjsgeW91IGp1c3QgaGF2ZSB0byBsZWFybiB0aGVtLg0KDQpgYGB7ciBjb3J9DQoNCiMgUGFzcyB0aGUgdHdvIGRhdGEgY29sdW1ucyBpbnRvIGZ1bmN0aW9uIGNvcg0KY29yKHBlbmd1aW5zJGJpbGxfbGVuZ3RoX21tLCBwZW5ndWlucyRib2R5X21hc3NfZywgdXNlPSJjb21wbGV0ZS5vYnMiKQ0KYGBgDQoNCkZ1bmN0aW9uIGBjb3JgIHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLiBDb3JyZWxhdGlvbnMgdGhhdCB0cmVuZCBkb3dud2FyZCAoaS5lLiBpZiBvbmUgc2NvcmUgaXMgaGlnaCwgdGhlIG90aGVyIHRlbmRzIHRvIGJlIGxvdykgd2lsbCBoYXZlIGEgbmVnYXRpdmUgY29ycmVsYXRpb24gdmFsdWUuIENvcnJlbGF0aW9ucyB0aGF0IHRyZW5kIHVwd2FyZCAoaS5lLiBpZiBvbmUgc2NvcmUgaXMgaGlnaCB0aGUgb3RoZXIgYWxzbyB0ZW5kcyB0byBiZSBoaWdoKSB3aWxsIGhhdmUgYSBwb3NpdGl2ZSBjb3JyZWxhdGlvbiB2YWx1ZS4gVGhlIGNsb3NlciB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYGNvcmAgaXMgdG8gMSwgdGhlIHN0cm9uZ2VyIHRoZSBjb3JyZWxhdGlvbiAoeW91IGtub3cgd2hvIHRvIHRhbGsgdG8gZm9yIG1vcmUgZGV0YWlsLCBkb24ndCB5b3U/KS4NCg0KRm9yIGV4YW1wbGUsIGNvbnNpZGVyIHRoZXNlIHR3byBzY2F0dGVycGxvdHM6DQoNCmBgYHtyIDA0LWNvbXBhcmluZywgZWNobz1GQUxTRSwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0NCmxpYnJhcnkoZ3JpZEV4dHJhKQ0KcGxvdDEgPC0gZ2dwbG90KGRhdGEgPSBwZW5ndWlucywgbWFwcGluZyA9IGFlcyh4ID0gYm9keV9tYXNzX2csIHkgPSBiaWxsX2xlbmd0aF9tbSkpICsNCiAgZ2VvbV9wb2ludCgpICsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgc2U9RkFMU0UpDQpwbG90MiA8LSBnZ3Bsb3QoZGF0YSA9IHBlbmd1aW5zLCBtYXBwaW5nID0gYWVzKHggPSBib2R5X21hc3NfZywgeSA9IGZsaXBwZXJfbGVuZ3RoX21tKSkgKw0KICBnZW9tX3BvaW50KCkgKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCBzZT1GQUxTRSkNCmdyaWQuYXJyYW5nZShwbG90MSwgcGxvdDIsIG5jb2w9MikNCmBgYA0KDQpgYGB7ciBjb3IgZXhlcmNpc2Ugc29sdXRpb24sIGVjaG89RkFMU0UsIGluY2x1ZGU9RkFMU0V9DQpjb3IocGVuZ3VpbnMkYm9keV9tYXNzX2csIHBlbmd1aW5zJGJpbGxfbGVuZ3RoX21tLCB1c2U9ImNvbXBsZXRlLm9icyIpDQoNCmNvcihwZW5ndWlucyRib2R5X21hc3NfZywgcGVuZ3VpbnMkZmxpcHBlcl9sZW5ndGhfbW0sIHVzZT0iY29tcGxldGUub2JzIikNCmBgYA0KDQojIyMgRXhlcmNpc2UgNA0KDQpGb3Igb25lIG9mIHRoZSBzY2F0dGVycGxvdHMgYWJvdmUsIHRoZSBjb21wdXRlZCBjb3JyZWxhdGlvbiBzY29yZSBpcyAwLjYwLiBGb3IgdGhlIG90aGVyLCBpdCBpcyAwLjg3LiBGaXJzdCwgcHJlZGljdCB3aGljaCBpcyB3aGljaC4gU2Vjb25kLCB3cml0ZSB0aGUgbmVjZXNzYXJ5IFIgY29kZSB0byBjb25maXJtIHlvdXIgcHJlZGljdGlvbi4NCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("04-summarise.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Patricia Haden &amp; Murray Cadzow" />


<title>R for Successful Student Projects 05 - Descriptive Statistics</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R4SSP Semester 1 2022</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Intro</li>
    <li>
      <a href="01-intro.html">Intro to R and RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Focus</li>
    <li>
      <a href="02-visualise.html">Part 1: Data Loading and Looking</a>
    </li>
    <li>
      <a href="03-subset.html">Part 2: Subsetting</a>
    </li>
    <li>
      <a href="04-transform.html">Part 3: Transforming</a>
    </li>
    <li>
      <a href="05-summarise.html">Part 4: Summarising</a>
    </li>
    <li>
      <a href="06-communicate.html">Part 5: Communicating</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Programming focus</li>
    <li>
      <a href="07-functions.html">Functions and logic branching</a>
    </li>
    <li>
      <a href="08-iterate.html">Loops and iterators</a>
    </li>
    <li>
      <a href="09-workflows.html">Workflows</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Handouts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="handout1.html">Handout 1</a>
    </li>
    <li>
      <a href="handout2.html">Handout 2</a>
    </li>
    <li>
      <a href="handout3.html">Handout 3</a>
    </li>
    <li>
      <a href="handout4.html">Handout 4</a>
    </li>
    <li>
      <a href="handout5.html">Handout 5</a>
    </li>
    <li>
      <a href="handout6.html">Handout 6</a>
    </li>
    <li>
      <a href="handout7.html">Handout 7</a>
    </li>
    <li>
      <a href="handout8.html">Handout 8</a>
    </li>
    <li>
      <a href="handout9.html">Handout 9</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Worksheets
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="worksheet1.html">Worksheet 1</a>
    </li>
    <li>
      <a href="worksheet3.html">Worksheet 3</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">R for Successful Student Projects 05 - Descriptive Statistics</h1>
<h4 class="author">Patricia Haden &amp; Murray Cadzow</h4>
<h4 class="date">Semester 1, 2022</h4>

</div>


<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>We do scientific research to test hypotheses, answer questions, or just learn something about the world. After the often labourious process of data collection, we may have hundreds (or even thousands) of data points, but we haven’t actually learned anything. To squeeze the knowledge out of our raw data, we must use statistics.</p>
<p>The formal topic of statistics is large and complex, and we do not attempt to teach it here (there are papers for that, and we recommend you take as many of them as possible). We concentrate on how to use R to perform common statistical analyses. R is especially useful for such tasks because of its extensive set of statistical libraries and efficient data handling facilities.</p>
<p>There are two general types of statistical analyses – descriptive statistics, which allow us to summarise and describe our raw data, and inferential statistics, which allow us to generalise our results beyond our observed data. We will discuss descriptive statistics in this module and inferential techniques in Module 06.</p>
<p>For this module, we will use two data sets – the Palmers Penguins data we saw earlier in the Data Visualisation module, and a data set containing Chlorophyll A (ChlA) readings from three New Zealand lakes (data provided by the local Regional Councils). ChlA levels are an indicator of phytoplankton biomass, and provide a general measure of lake health – more ChlA indicates poorer health. The “toxic algal blooms” that occur occasionally in New Zealand lakes are accompanied by a dramatic spike in measured ChlA.</p>
</div>
<div id="loading-the-data" class="section level2">
<h2>Loading the data</h2>
<pre class="r"><code>
# Install palmerpenguins once on any computer
# install.packages(&quot;palmerspenguins&quot;)

# After loading the library, a tibble
# called &#39;penguins&#39; will be initialised
library(palmerpenguins)

# Check the structure
penguins
#&gt; # A tibble: 344 × 8
#&gt;    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g
#&gt;    &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;
#&gt;  1 Adelie  Torgersen           39.1          18.7               181        3750
#&gt;  2 Adelie  Torgersen           39.5          17.4               186        3800
#&gt;  3 Adelie  Torgersen           40.3          18                 195        3250
#&gt;  4 Adelie  Torgersen           NA            NA                  NA          NA
#&gt;  5 Adelie  Torgersen           36.7          19.3               193        3450
#&gt;  6 Adelie  Torgersen           39.3          20.6               190        3650
#&gt;  7 Adelie  Torgersen           38.9          17.8               181        3625
#&gt;  8 Adelie  Torgersen           39.2          19.6               195        4675
#&gt;  9 Adelie  Torgersen           34.1          18.1               193        3475
#&gt; 10 Adelie  Torgersen           42            20.2               190        4250
#&gt; # … with 334 more rows, and 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;

# Read in the lakes data file, parsing the lake 
# name column as a factor
lakes &lt;- read.csv(&quot;data/NZ_lake_chla_data.csv&quot;, stringsAsFactors = TRUE)

# Since they are conceptually categorical in this data set, 
# you may wish to cast Year and Month to factors as well, for completeness...
lakes$Year &lt;- as.factor(lakes$Year)
lakes$Month &lt;- as.factor(lakes$Month)  

# Check the structure
str(lakes)
#&gt; &#39;data.frame&#39;:    408 obs. of  4 variables:
#&gt;  $ LakeName: Factor w/ 3 levels &quot;Lake Ellesmere&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ Year    : Factor w/ 13 levels &quot;2001&quot;,&quot;2002&quot;,..: 4 4 4 4 4 4 4 4 4 4 ...
#&gt;  $ Month   : Factor w/ 12 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
#&gt;  $ ChlA    : num  66.9 79.9 95 82.4 59.6 69 62.1 96.3 135 102 ...</code></pre>
</div>
<div id="visualise-the-data" class="section level2">
<h2>Visualise the data</h2>
<p>When faced with a new data set, my first step is invariably to start making graphs. These “pictures” of your data provide an easy way to see large-scale patterns that will help guide your further analysis. They also help you to catch any problems in your data (see the skewness exercise below) that must be addressed before proceeding to more complex analyses.</p>
<p>An excellent first graph for continuous (i.e. not categorical) data is the <strong>frequency distribution</strong>, or <strong>histogram</strong>, which has data value on the x-axis and frequency (i.e. count or proportion) on the y-axis. This shows you, in a single picture, how your data are distributed.</p>
<p>The <code>penguins</code> data set contains values for 344 different penguins. We begin by looking at how the penguins’ body weights are distributed.</p>
<pre class="r"><code>
# With base R
# The &#39;breaks&#39; argument controls the number of bars drawn
hist(penguins$body_mass_g, 
     breaks = 100,
     main=&quot;Distribution of Penguin Body Mass&quot;, xlab = &quot;Body mass (g)&quot;, ylab = &quot;Frequency&quot;)</code></pre>
<p><img src="figures/histograms-1.png" width="672" /></p>
<pre class="r"><code>

# With ggplot
# Load the library before your first call to ggplot
library(ggplot2)

# The values provided to &#39;colour&#39; and &#39;fill&#39; are hexidecimal colour codes. Note the 
# hash mark prefix. It is required.
# The &#39;labs&#39; layer controls graph title and axis labels
ggplot(data = penguins) +
  geom_histogram(aes(x = body_mass_g), colour = &quot;#2222EE&quot;, fill=&quot;#eeeeff&quot;) +
  labs(title = &quot;Distribution of Penguin Body Mass&quot;, x = &quot;Body Mass (g)&quot;, y = &quot;Frequency&quot;)</code></pre>
<p><img src="figures/histograms-2.png" width="672" /></p>
</div>
<div id="exercise-1" class="section level1">
<h1>Exercise 1</h1>
<p>Using ggplot, make a histogram of all the ChlA values in data frame lakes, with each lake in a different colour, as shown. If you need help, review Module 3, or see my solution at the end of this handout. What does this simple graph tell you about the health of these three lakes?</p>
<p><img src="figures/lake%20hists-1.png" width="672" /></p>
<div id="distribution-graphs-for-categorical-data" class="section level2">
<h2>Distribution graphs for categorical data</h2>
<p>The functions <code>hist</code> and <code>geom_histogram</code> are appropriate for <strong>continuous</strong> (numerical) data. For <strong>categorical</strong> variables (e.g. Species and Island in the penguin data set) it is usually better to make a bar graph. The example code below shows how to generate a bar graph in ggplot (cf. Module 03). Note how we modify the default ggplot colour palette to something more accessible to viewers with atypical colour vision:</p>
<pre class="r"><code>
# &quot;Colour-blind friendly&quot; palette from #https://personal.sron.nl/~pault/
# These are hexadecimal colour codes. The # is required.
customPalette &lt;- c(&quot;#DDAA33&quot;, &quot;#BB5566&quot;, &quot;#004488&quot;)

# Generate a stacked bar plot, and use our custom colour palette
ggplot(data = penguins) +
  geom_bar(aes(x = island, fill=species), position = &quot;stack&quot;) +
  scale_fill_manual(values = customPalette)</code></pre>
<p><img src="figures/categorical%20distribution-1.png" width="672" /></p>
<p>Even a simple graph like this helps you to get to know your data. Just by inspection we see that Biscoe island has the largest population, Torgersen has only Adelie penguins, Dream Island has nearly equal numbers of Chinstrap and Gentoo, etc. When first approaching a big data set, always think about starting with some graphs.</p>
</div>
</div>
<div id="exercise-2" class="section level1">
<h1>Exercise 2</h1>
<p>The bar graph above is in “stacked” format. Some people prefer bar graphs to have separate bars for each group, as shown below. Write the code needed to generate this graph. Hint: This requires changing only the value of one argument in the code above. See Module 03 for more revision as needed.</p>
<p><img src="figures/categorical%20distribution%20dodge-1.png" width="672" /></p>
<div id="measures-of-central-tendency" class="section level2">
<h2>Measures of Central Tendency</h2>
<p>Look at the graph you made earlier showing the distributions of ChlA for the three lakes. You might describe the Lake Ellesmere ChlA readings as “mostly below 100” and the Lake Rotorua readings as “mostly between 10 and 20”. Statements like this are attempts to describe a <strong>typical</strong> score from a large data set. They allow us to capture the fact that, for example, <em>overall</em>, Lake Ellesmere has higher ChlA readings than Lake Rotorua It is not the case that <em>every</em> Ellesmere reading is higher than <em>every</em> Rotorua reading, but <strong>typically</strong> this is the case.</p>
<p>In statistics, a precise measure of such typicality is called a <strong>Measure of Central Tendency</strong> (MCT). The most common MCTs are the <strong>mean</strong>, the <strong>median</strong> and the <strong>mode</strong>. These are, respectively, the mathematical average, the middle score, and the most frequent score (or scores) in a data set. There are some subtle statistical issues around which of the three MCT is appropriate for any given data analysis situation (ask your lecturer for details), but they are all easy to compute in R (we have, in fact, already met function <code>mean</code> in earlier modules), and we show example code below for computing these descriptive statistics on a single column of data from the penguins data set.</p>
<p>Note that the penguins data has some missing some values (cf. Module 01 - Tidy Data), The functions for mean and median will not work if the input data have any <code>NA</code> (missing) values. The most common solution is to omit those scores from the computation by setting the <code>na.rm</code> argument to <code>TRUE</code> as shown:</p>
<pre class="r"><code>
# Mean

# We have seen this code before... We pass the column of interest
# to function mean
mean(penguins$body_mass_g, na.rm=TRUE)
#&gt; [1] 4201.754


# Median

# The familiar pattern....
median(penguins$body_mass_g, na.rm = TRUE)
#&gt; [1] 4050


# Mode

# Base R has no built-in function for mode. After Module 08
# you will be able to write your own Mode function. Or you can
# use one of several available in auxiliary libraries. The
# DescTools library is a good one.

# Install the package once on each machine
# install.packages(&quot;DescTools&quot;)

# Load the library once each session
library(DescTools)

#Call the function
Mode(penguins$body_mass_g, na.rm=TRUE)
#&gt; [1] 3800
#&gt; attr(,&quot;freq&quot;)
#&gt; [1] 12</code></pre>
<p>Note that DescTools::Mode returns the modal (i.e. most common value) with an attached <strong>attribute</strong> called “freq” equal to the number of occurences.</p>
</div>
<div id="using-function-summary" class="section level2">
<h2>Using function <code>summary</code></h2>
<p>When you have a very large number of data measures, you may wish to compute MCTs for individual columns as shown above. An efficient alternative for smaller data sets is to use function <code>summary</code>, which accepts a data frame and summarises <em>all</em> its columns at once. Function <code>summary</code> computes frequencies for categorical variables, and measures of central tendency for continuous variables. It also reports the numbers of NA values in each column. Function <code>summary</code> provides some additional measures (minimum, 1st quartile, 3rd quartile, and maximum) that we will discuss in more detail later.</p>
<pre class="r"><code>summary(penguins)
#&gt;       species          island    bill_length_mm  bill_depth_mm  
#&gt;  Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  
#&gt;  Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  
#&gt;  Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  
#&gt;                                  Mean   :43.92   Mean   :17.15  
#&gt;                                  3rd Qu.:48.50   3rd Qu.:18.70  
#&gt;                                  Max.   :59.60   Max.   :21.50  
#&gt;                                  NA&#39;s   :2       NA&#39;s   :2      
#&gt;  flipper_length_mm  body_mass_g       sex           year     
#&gt;  Min.   :172.0     Min.   :2700   female:165   Min.   :2007  
#&gt;  1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  
#&gt;  Median :197.0     Median :4050   NA&#39;s  : 11   Median :2008  
#&gt;  Mean   :200.9     Mean   :4202                Mean   :2008  
#&gt;  3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  
#&gt;  Max.   :231.0     Max.   :6300                Max.   :2009  
#&gt;  NA&#39;s   :2         NA&#39;s   :2</code></pre>
</div>
</div>
<div id="exercise-3" class="section level1">
<h1>Exercise 3</h1>
<p>The results for column <code>year</code> may not be what you expected. Function <code>summary</code> has computed an <em>average value</em> for <code>year</code>. Does this seem like the appropriate analysis? (Answer =&gt; No.) Modify <code>penguins</code> to make <code>summary</code> treat the <code>year</code> data correctly, and rerun <code>summary</code>.</p>
<div id="measures-of-variability" class="section level2">
<h2>Measures of Variability</h2>
<p>In the histograms for ChlA from each of three New Zealand lakes, the three groups of scores did not overlap completely, indicating that the typical values – the central tendencies – were different for the three lakes. We can confirm this observation by comparing the means. We can use function <code>aggregate</code> or <code>group_by</code> and <code>summarise</code> from package <code>dplyr</code> (cf. Module 03).</p>
<pre class="r"><code># Using aggregate. compute the group means
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=mean)
#&gt;             Lake         x
#&gt; 1 Lake Ellesmere 80.566667
#&gt; 2   Lake Rotorua 18.419015
#&gt; 3     Lake Taupo  1.030606

# Using dplyr -- install tidyverse first if needed
library(dplyr)
by_lake &lt;- group_by(lakes, LakeName)
summarise(by_lake, Mean_ChlA = mean(ChlA))
#&gt; # A tibble: 3 × 2
#&gt;   LakeName       Mean_ChlA
#&gt;   &lt;fct&gt;              &lt;dbl&gt;
#&gt; 1 Lake Ellesmere     80.6 
#&gt; 2 Lake Rotorua       18.4 
#&gt; 3 Lake Taupo          1.03</code></pre>
<p>However, not only do the central points of the three lakes’ distributions differ, so do the amounts of “spread”. Lake Taupo’s distribution is very “skinny”; all its readings are similar. Lake Ellesmere is squashed and spread out; its readings vary a lot. Lake Rotorua is intermediate. To illustrate this more clearly, we can use ggplot to make separate graphs for each lake, adjusting the y-axes to make comparison easier (note the arguments to <code>facet_grid</code>).</p>
<pre class="r"><code>ggplot(data = lakes) +
  geom_histogram(aes(x = ChlA, fill=LakeName), color=&quot;black&quot;) +
  facet_grid(rows = vars(LakeName), scales=&quot;free_y&quot;)</code></pre>
<p><img src="figures/facet%20graphs-1.png" width="672" /></p>
<p>Statistically, the “spread out” quality of a distribution reflects its <strong>variability</strong>.</p>
<p>We can capture variability more precisely with measures of the <strong>range</strong> of the data set. These are typically the smallest and largest scores (minimum and maximum) and the scores at the 25th and 75th percentiles (also called <strong>1st quartile</strong> and <strong>3rd quartile</strong>). Earlier, we saw that function <code>summary</code> computes these measures of range. However, if we simply pass the entire <code>lakes</code> data frame to function <code>summary</code>, it will combine the data from all three lakes – to compare the lakes we need the values from each lake separately.</p>
<p>In Module 02 we saw that we could solve this problem by using function <code>subset</code> to select out just the rows from one lake, and passing those rows to <code>summary</code>. However, we can achieve the same result more parsimoniously by using function <code>aggregate</code>. Above we used aggregate with <code>FUN = mean</code> to get the mean ChlA for each lake. We can use <code>FUN = summary</code> to call function <code>summary</code> separately for the records of each lake. (The same result can be achieved with <code>group_by</code> and <code>summarise</code>.)</p>
<pre class="r"><code>aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=summary)
#&gt;             Lake     x.Min.  x.1st Qu.   x.Median     x.Mean  x.3rd Qu.
#&gt; 1 Lake Ellesmere   1.300000  44.000000  67.950000  80.566667  97.087500
#&gt; 2   Lake Rotorua   2.500000  10.825000  15.950000  18.419015  23.625000
#&gt; 3     Lake Taupo   0.200000   0.600000   0.900000   1.030606   1.400000
#&gt;       x.Max.
#&gt; 1 521.300000
#&gt; 2  77.100000
#&gt; 3   2.900000</code></pre>
<p>We can also measure the variablity in a data set with the <strong>standard deviation</strong>. The standard deviation is the most commonly used measure of variability, and it plays an important mathematical role in inferential statistics (ask your stats lecturer for details – it’s very interesting). Conceptually, the standard deviation is <em>almost</em> equal to the average distance from the mean across all the values in a data set – it doesn’t equal <em>exactly</em> that value, because of how it is computed, but it is close, and it can be helpful to think of it with this approximation. Big standard deviation shows that scores are spread far from their mean; small standard deviation shows that scores tend to huddle close to their mean. Compute standard deviation with function <code>sd</code>.</p>
<pre class="r"><code>
# Remember you can save having to type the data frame
# name by using attach
attach(lakes)
aggregate(ChlA, by = list(Lake = LakeName), FUN=sd)
#&gt;             Lake          x
#&gt; 1 Lake Ellesmere 63.5217194
#&gt; 2   Lake Rotorua 11.6637583
#&gt; 3     Lake Taupo  0.5627233

# More processing of data frame lakes could go here........

# But remember to detach when you&#39;re finished...
detach(lakes)</code></pre>
<p>The histograms, the measures of range, and the standard deviations all indicate that Taupo has very stable ChlA measures, Rotorua is a little noisier, and Ellesmere is all over the place. This phytoplankton biomass stability is an important indicator of lake health – a stable lake is at much lower risk of a toxic algal bloom.</p>
</div>
<div id="efficient-code-for-descriptive-statistics" class="section level2">
<h2>Efficient code for descriptive statistics</h2>
<p>The function <code>describeBy</code> in package <code>psych</code> will compute all the descriptive summaries we have seen (and a few more) in one statement. When you are exploring a single data column and a single grouping column (so the output doesn’t get too large), this is a very useful function.</p>
<pre class="r"><code># Install once on any computer
#install.packages(&quot;psych&quot;)

# Call once each R session
library(psych)
#&gt; 
#&gt; Attaching package: &#39;psych&#39;
#&gt; The following objects are masked from &#39;package:DescTools&#39;:
#&gt; 
#&gt;     AUC, ICC, SD
#&gt; The following objects are masked from &#39;package:ggplot2&#39;:
#&gt; 
#&gt;     %+%, alpha

# Pass in the data column and the grouping column
describeBy(lakes$ChlA, lakes$LakeName)
#&gt; 
#&gt;  Descriptive statistics by group 
#&gt; group: Lake Ellesmere
#&gt;    vars   n  mean    sd median trimmed  mad min   max range skew kurtosis  se
#&gt; X1    1 120 80.57 63.52  67.95   72.45 40.7 1.3 521.3   520 3.12     17.5 5.8
#&gt; ------------------------------------------------------------ 
#&gt; group: Lake Rotorua
#&gt;    vars   n  mean    sd median trimmed  mad min  max range skew kurtosis   se
#&gt; X1    1 132 18.42 11.66  15.95   16.97 9.12 2.5 77.1  74.6 1.71     4.75 1.02
#&gt; ------------------------------------------------------------ 
#&gt; group: Lake Taupo
#&gt;    vars   n mean   sd median trimmed  mad min max range skew kurtosis   se
#&gt; X1    1 156 1.03 0.56    0.9    0.97 0.56 0.2 2.9   2.7 0.97      0.5 0.05</code></pre>
<p>Package <code>psych</code> contains many other interesting statistical tools, especially for multivariate data sets commonly found in psychological and ecological research. Ask Google or your lecturer for details.</p>
</div>
<div id="exploring-the-relationship-between-two-variables" class="section level2">
<h2>Exploring the relationship between two variables</h2>
<p>The preceding descriptive statistics all looked at data measures – ChlA, bill length, body weight, etc. – individually, summarising their distribution, central tendency and variability. Often, however, we are interested in describing <strong>the relationship between data measures</strong>. For example, we might want to know if heavier penguins also tend to have longer bills. This type of relationship is called a <strong>correlation</strong>. When we have more than one measure for each experimental participant (or each penguin, or each lake) we can explore correlations between pairs of measures graphically with a <strong>scatterplot</strong>. A scatterplot has one measure on each axis, and one point for each participant’s pair of scores.</p>
<p>In the code example below we make a scatterplot with ggplot (cf. Module 03), and show how to add a <strong>linear trend line</strong>. Conceptually, this is the line that runs through the center of the scatterplot points, and it helps us to see the direction of the relationship. Mathematically, trend lines are actually very complicated things, and we generate them with the powerful function <code>lm</code>,(for <strong>linear model</strong>). You will learn about the many fascinating things you can do with linear modeling if you take advanced statistics papers.</p>
<pre class="r"><code># geom_point plots the points of the scatterplot 

# geom_smooth plots the linear trend line computed with function lm

# The se argument determines whether error bars are shown 
# around the trend line.

ggplot(data = penguins, mapping = aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point() +
  geom_smooth(method = &quot;lm&quot;, se=FALSE)</code></pre>
<p><img src="figures/scatterplot-1.png" width="672" /></p>
<p>The scatterplot gives us a very clear picture: those penguins with higher body weights tend to also have longer bills, and this is reflected in the positive slope of the trendline. Note however that this is not an absolute rule. Is it easy to find pairs of points such that the lighter of two penguins has the longer bill. This is typical of correlational data.</p>
<p>There are various statistical measures that capture the strength of a correlation (i.e. how close it is to being an absolute rule). For continuous, numerical data (such as bill length and body weight) use the R function <code>cor</code> to compute the numerical correlation value. As with means and medians, we must tell <code>cor</code> how to cope with missing data (NA scores). Unfortunately the syntax is not consistent across the functions. For function <code>mean</code> we set argument <code>na.rm = TRUE</code>. For function <code>cor</code> we must set argument <code>use = "complete.obs"</code>, meaning that we want the function to use only those rows that are complete (i.e. have both values). These idiosyncracies occur from time to time in R; you just have to learn them.</p>
<pre class="r"><code>
# Pass the two data columns into function cor
cor(penguins$bill_length_mm, penguins$body_mass_g, use=&quot;complete.obs&quot;)
#&gt; [1] 0.5951098</code></pre>
<p>Function <code>cor</code> returns a value between -1 and 1. Correlations that trend downward (i.e. if one score is high, the other tends to be low) will have a negative correlation value. Correlations that trend upward (i.e. if one score is high the other also tends to be high) will have a positive correlation value. The closer the absolute value of <code>cor</code> is to 1, the stronger the correlation (you know who to talk to for more detail, don’t you?).</p>
<p>For example, consider these two scatterplots:</p>
<p><img src="figures/comparing-1.png" width="672" /></p>
</div>
</div>
<div id="exercise-4" class="section level1">
<h1>Exercise 4</h1>
<p>For one of the scatterplots above, the computed correlation score is 0.60. For the other, it is 0.87. First, predict which is which. Second, write the necessary R code to confirm your prediction.</p>
</div>
<div id="exercise-5" class="section level1">
<h1>Exercise 5</h1>
<p>5.1. Many scientific data sets have histograms that are “bell-shaped”. That is, most of the values cluster in the middle, and the frequency drops off symmetrically toward smaller and larger scores. The distribution of penguin body mass is a good example of a data set that is approximately bell-shaped.</p>
<p>Many inferential statistical techniques require data sets to be close to a very specific bell-shape called the <strong>normal curve</strong>. If your data deviate too far from <strong>normal</strong>, the inferential tests will give incorrect results. The most serious such deviation is <strong>skew</strong>, which is when the bell-shape tilts to one side, with a long tail in either the smaller or larger direction.</p>
<p>The penguin body mass graph is not perfectly symmetrical. It shows a bit of skewness with a longer tail toward the heavier penguins. But many data sets from nature are <em>extremely</em> skewed. We can see this in the lakes data.</p>
<p>Observe Lake Ellesmere in the histogram of the three lake’s ChlA readings. Although most of the readings are clustered below 100, there are some much larger values – one reading is more than 500 – creating a long “tail” to the right. The ChlA measure in Lake Ellesmere is skewed.</p>
<p>We can compute an exact numerical value for the skewness of a distribution using function <code>skewness</code> from package <code>e1071</code>. As in the examples above, we can compute the skewness for each lake using <code>aggregate</code> or, if we are using <code>dplyr</code>, using <code>group_by</code> and <code>summarise</code>. Alternatively, we can use <code>describeBy</code> as above. It includes skewness among its summary statistics.</p>
<p>With the method of your choice, compute the skewness value for each lake. What does the pattern of results tell you about the health of the three lakes?</p>
<p>5.2. A perfectly symmetrical distribution will have a skewness of 0. As a distribution tilts further and further from normal, the absolute value of the skewness measure goes up. What consititutes “too much skew” varies between disciplines, and for an assignment you will want to check with your lecturer. However, a common rule of thumb is that any value greater than 1 (or less than -1) has enough skew that you need to think about dealing with it. A value greater than 3 (as found with the Lake Ellesmere data) is <em>definitely</em> skewed.</p>
<p>As mentioned earlier, many inferential tests give inaccurate results with skewed data, so in cases like the lakes data, we must “unskew” our values. A common approach is to compute the natural logarithm of each data value (using R function <code>log</code>), and analyse those logs (ask your lecturer about alternative approaches). The logarithm computation pulls extreme scores in, reducing the skew, without changing the overall relationships between data values.</p>
<p>In Module 04 you saw how to add a new computed column to a data frame using either function <code>mutate</code> or the <code>$</code> operator. Using the technique of your choice, add a column to data frame lakes that holds the natural log of each ChlA reading.</p>
<ol start="3" style="list-style-type: decimal">
<li>Using ggplot, make a histogram of all the log ChlA values in data frame lakes, with each lake in a different colour. This code is <em>extremely</em> similar to the code you wrote for the earlier exercise. How would you describe these distributions. Are Lake Ellesmere’s log ChlA values skewed? What can you provide as evidence for your answer?</li>
</ol>
<div id="code-solution-for-the-lakes-histogram" class="section level2">
<h2>Code solution for the lakes histogram</h2>
<pre class="r"><code>ggplot(data = lakes) +
  geom_histogram(aes(x = ChlA, color = LakeName, fill=LakeName), position=&quot;dodge&quot;)
</code></pre>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiUiBmb3IgU3VjY2Vzc2Z1bCBTdHVkZW50IFByb2plY3RzIDA1IC0gRGVzY3JpcHRpdmUgU3RhdGlzdGljcyIKYXV0aG9yOiAiUGF0cmljaWEgSGFkZW4gJiBNdXJyYXkgQ2Fkem93IgpkYXRlOiAiU2VtZXN0ZXIgMSwgMjAyMiIKb3V0cHV0OgogIGh0bWxfZG9jdW1lbnQ6CiAgICB0b2M6IHRydWUKICAgIHRvY19mbG9hdDogdHJ1ZQogICAgdG9jX2RlcHRoOiAzCiAgICBjb2RlX2Rvd25sb2FkOiB0cnVlCiAgICBjb2RlX2ZvbGRpbmc6IHNob3cKLS0tCgpgYGB7ciBzZXR1cCwgaW5jbHVkZT1GQUxTRX0KbGlicmFyeShrbml0cikKCmtuaXRyOjpvcHRzX2NodW5rJHNldCgKICBjb21tZW50ID0gIiM+IiwKICBmaWcucGF0aCA9ICJmaWd1cmVzLyIsICMgdXNlIG9ubHkgZm9yIHNpbmdsZSBSbWQgZmlsZXMKICBjb2xsYXBzZSA9IFRSVUUsCiAgZWNobyA9IFRSVUUKKQpgYGAKCiMjIEludHJvZHVjdGlvbgpXZSBkbyBzY2llbnRpZmljIHJlc2VhcmNoIHRvIHRlc3QgaHlwb3RoZXNlcywgYW5zd2VyIHF1ZXN0aW9ucywgb3IganVzdCBsZWFybiBzb21ldGhpbmcgYWJvdXQgdGhlIHdvcmxkLiBBZnRlciB0aGUgb2Z0ZW4gbGFib3VyaW91cyBwcm9jZXNzIG9mIGRhdGEgY29sbGVjdGlvbiwgd2UgbWF5IGhhdmUgaHVuZHJlZHMgKG9yIGV2ZW4gdGhvdXNhbmRzKSBvZiBkYXRhIHBvaW50cywgYnV0IHdlIGhhdmVuJ3QgYWN0dWFsbHkgbGVhcm5lZCBhbnl0aGluZy4gVG8gc3F1ZWV6ZSB0aGUga25vd2xlZGdlIG91dCBvZiBvdXIgcmF3IGRhdGEsIHdlIG11c3QgdXNlIHN0YXRpc3RpY3MuCgpUaGUgZm9ybWFsIHRvcGljIG9mIHN0YXRpc3RpY3MgaXMgbGFyZ2UgYW5kIGNvbXBsZXgsIGFuZCB3ZSBkbyBub3QgYXR0ZW1wdCB0byB0ZWFjaCBpdCBoZXJlICh0aGVyZSBhcmUgcGFwZXJzIGZvciB0aGF0LCBhbmQgd2UgcmVjb21tZW5kIHlvdSB0YWtlIGFzIG1hbnkgb2YgdGhlbSBhcyBwb3NzaWJsZSkuIFdlIGNvbmNlbnRyYXRlIG9uIGhvdyB0byB1c2UgUiB0byBwZXJmb3JtIGNvbW1vbiBzdGF0aXN0aWNhbCBhbmFseXNlcy4gUiBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3Igc3VjaCB0YXNrcyBiZWNhdXNlIG9mIGl0cyBleHRlbnNpdmUgc2V0IG9mIHN0YXRpc3RpY2FsIGxpYnJhcmllcyBhbmQgZWZmaWNpZW50IGRhdGEgaGFuZGxpbmcgZmFjaWxpdGllcy4gCgpUaGVyZSBhcmUgdHdvIGdlbmVyYWwgdHlwZXMgb2Ygc3RhdGlzdGljYWwgYW5hbHlzZXMgLS0gZGVzY3JpcHRpdmUgc3RhdGlzdGljcywgd2hpY2ggYWxsb3cgdXMgdG8gc3VtbWFyaXNlIGFuZCBkZXNjcmliZSBvdXIgcmF3IGRhdGEsIGFuZCBpbmZlcmVudGlhbCBzdGF0aXN0aWNzLCB3aGljaCBhbGxvdyB1cyB0byBnZW5lcmFsaXNlIG91ciByZXN1bHRzIGJleW9uZCBvdXIgb2JzZXJ2ZWQgZGF0YS4gV2Ugd2lsbCBkaXNjdXNzIGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MgaW4gdGhpcyBtb2R1bGUgYW5kIGluZmVyZW50aWFsIHRlY2huaXF1ZXMgaW4gTW9kdWxlIDA2LgoKRm9yIHRoaXMgbW9kdWxlLCB3ZSB3aWxsIHVzZSB0d28gZGF0YSBzZXRzIC0tIHRoZSBQYWxtZXJzIFBlbmd1aW5zIGRhdGEgd2Ugc2F3IGVhcmxpZXIgaW4gdGhlIERhdGEgVmlzdWFsaXNhdGlvbiBtb2R1bGUsIGFuZCBhIGRhdGEgc2V0IGNvbnRhaW5pbmcgQ2hsb3JvcGh5bGwgQSAoQ2hsQSkgcmVhZGluZ3MgZnJvbSB0aHJlZSBOZXcgWmVhbGFuZCBsYWtlcyAoZGF0YSBwcm92aWRlZCBieSB0aGUgbG9jYWwgUmVnaW9uYWwgQ291bmNpbHMpLiBDaGxBIGxldmVscyBhcmUgYW4gaW5kaWNhdG9yIG9mIHBoeXRvcGxhbmt0b24gYmlvbWFzcywgYW5kIHByb3ZpZGUgYSBnZW5lcmFsIG1lYXN1cmUgb2YgbGFrZSBoZWFsdGggLS0gbW9yZSBDaGxBIGluZGljYXRlcyBwb29yZXIgaGVhbHRoLiBUaGUgInRveGljIGFsZ2FsIGJsb29tcyIgdGhhdCBvY2N1ciBvY2Nhc2lvbmFsbHkgaW4gTmV3IFplYWxhbmQgbGFrZXMgYXJlIGFjY29tcGFuaWVkIGJ5IGEgZHJhbWF0aWMgc3Bpa2UgaW4gbWVhc3VyZWQgQ2hsQS4KCiMjIExvYWRpbmcgdGhlIGRhdGEKYGBge3IgbG9hZCB0aGUgZGF0YSwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KCiMgSW5zdGFsbCBwYWxtZXJwZW5ndWlucyBvbmNlIG9uIGFueSBjb21wdXRlcgojIGluc3RhbGwucGFja2FnZXMoInBhbG1lcnNwZW5ndWlucyIpCgojIEFmdGVyIGxvYWRpbmcgdGhlIGxpYnJhcnksIGEgdGliYmxlCiMgY2FsbGVkICdwZW5ndWlucycgd2lsbCBiZSBpbml0aWFsaXNlZApsaWJyYXJ5KHBhbG1lcnBlbmd1aW5zKQoKIyBDaGVjayB0aGUgc3RydWN0dXJlCnBlbmd1aW5zCgojIFJlYWQgaW4gdGhlIGxha2VzIGRhdGEgZmlsZSwgcGFyc2luZyB0aGUgbGFrZSAKIyBuYW1lIGNvbHVtbiBhcyBhIGZhY3RvcgpsYWtlcyA8LSByZWFkLmNzdigiZGF0YS9OWl9sYWtlX2NobGFfZGF0YS5jc3YiLCBzdHJpbmdzQXNGYWN0b3JzID0gVFJVRSkKCiMgU2luY2UgdGhleSBhcmUgY29uY2VwdHVhbGx5IGNhdGVnb3JpY2FsIGluIHRoaXMgZGF0YSBzZXQsIAojIHlvdSBtYXkgd2lzaCB0byBjYXN0IFllYXIgYW5kIE1vbnRoIHRvIGZhY3RvcnMgYXMgd2VsbCwgZm9yIGNvbXBsZXRlbmVzcy4uLgpsYWtlcyRZZWFyIDwtIGFzLmZhY3RvcihsYWtlcyRZZWFyKQpsYWtlcyRNb250aCA8LSBhcy5mYWN0b3IobGFrZXMkTW9udGgpICAKCiMgQ2hlY2sgdGhlIHN0cnVjdHVyZQpzdHIobGFrZXMpCmBgYAoKCiMjIFZpc3VhbGlzZSB0aGUgZGF0YQpXaGVuIGZhY2VkIHdpdGggYSBuZXcgZGF0YSBzZXQsIG15IGZpcnN0IHN0ZXAgaXMgaW52YXJpYWJseSB0byBzdGFydCBtYWtpbmcgZ3JhcGhzLiBUaGVzZSAicGljdHVyZXMiIG9mIHlvdXIgZGF0YSBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIHNlZSBsYXJnZS1zY2FsZSBwYXR0ZXJucyB0aGF0IHdpbGwgaGVscCBndWlkZSB5b3VyIGZ1cnRoZXIgYW5hbHlzaXMuIFRoZXkgYWxzbyBoZWxwIHlvdSB0byBjYXRjaCBhbnkgcHJvYmxlbXMgaW4geW91ciBkYXRhIChzZWUgdGhlIHNrZXduZXNzIGV4ZXJjaXNlIGJlbG93KSB0aGF0IG11c3QgYmUgYWRkcmVzc2VkIGJlZm9yZSBwcm9jZWVkaW5nIHRvIG1vcmUgY29tcGxleCBhbmFseXNlcy4KCkFuIGV4Y2VsbGVudCBmaXJzdCBncmFwaCBmb3IgY29udGludW91cyAoaS5lLiBub3QgY2F0ZWdvcmljYWwpIGRhdGEgaXMgdGhlICoqZnJlcXVlbmN5IGRpc3RyaWJ1dGlvbioqLCAgb3IgKipoaXN0b2dyYW0qKiwgd2hpY2ggaGFzIGRhdGEgdmFsdWUgb24gdGhlIHgtYXhpcyBhbmQgZnJlcXVlbmN5IChpLmUuIGNvdW50IG9yIHByb3BvcnRpb24pIG9uIHRoZSB5LWF4aXMuIFRoaXMgc2hvd3MgeW91LCBpbiBhIHNpbmdsZSBwaWN0dXJlLCBob3cgeW91ciBkYXRhIGFyZSBkaXN0cmlidXRlZC4KClRoZSBgcGVuZ3VpbnNgIGRhdGEgc2V0IGNvbnRhaW5zIHZhbHVlcyBmb3IgMzQ0IGRpZmZlcmVudCBwZW5ndWlucy4gV2UgYmVnaW4gYnkgbG9va2luZyBhdCBob3cgdGhlIHBlbmd1aW5zJyBib2R5IHdlaWdodHMgYXJlIGRpc3RyaWJ1dGVkLiAKCmBgYHtyIGhpc3RvZ3JhbXMsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9CgojIFdpdGggYmFzZSBSCiMgVGhlICdicmVha3MnIGFyZ3VtZW50IGNvbnRyb2xzIHRoZSBudW1iZXIgb2YgYmFycyBkcmF3bgpoaXN0KHBlbmd1aW5zJGJvZHlfbWFzc19nLCAKICAgICBicmVha3MgPSAxMDAsCiAgICAgbWFpbj0iRGlzdHJpYnV0aW9uIG9mIFBlbmd1aW4gQm9keSBNYXNzIiwgeGxhYiA9ICJCb2R5IG1hc3MgKGcpIiwgeWxhYiA9ICJGcmVxdWVuY3kiKQoKCiMgV2l0aCBnZ3Bsb3QKIyBMb2FkIHRoZSBsaWJyYXJ5IGJlZm9yZSB5b3VyIGZpcnN0IGNhbGwgdG8gZ2dwbG90CmxpYnJhcnkoZ2dwbG90MikKCiMgVGhlIHZhbHVlcyBwcm92aWRlZCB0byAnY29sb3VyJyBhbmQgJ2ZpbGwnIGFyZSBoZXhpZGVjaW1hbCBjb2xvdXIgY29kZXMuIE5vdGUgdGhlIAojIGhhc2ggbWFyayBwcmVmaXguIEl0IGlzIHJlcXVpcmVkLgojIFRoZSAnbGFicycgbGF5ZXIgY29udHJvbHMgZ3JhcGggdGl0bGUgYW5kIGF4aXMgbGFiZWxzCmdncGxvdChkYXRhID0gcGVuZ3VpbnMpICsKICBnZW9tX2hpc3RvZ3JhbShhZXMoeCA9IGJvZHlfbWFzc19nKSwgY29sb3VyID0gIiMyMjIyRUUiLCBmaWxsPSIjZWVlZWZmIikgKwogIGxhYnModGl0bGUgPSAiRGlzdHJpYnV0aW9uIG9mIFBlbmd1aW4gQm9keSBNYXNzIiwgeCA9ICJCb2R5IE1hc3MgKGcpIiwgeSA9ICJGcmVxdWVuY3kiKQpgYGAKCiMgRXhlcmNpc2UgMQpVc2luZyBnZ3Bsb3QsIG1ha2UgYSBoaXN0b2dyYW0gb2YgYWxsIHRoZSBDaGxBIHZhbHVlcyBpbiBkYXRhIGZyYW1lIGxha2VzLCB3aXRoIGVhY2ggbGFrZSBpbiBhIGRpZmZlcmVudCBjb2xvdXIsIGFzIHNob3duLiBJZiB5b3UgbmVlZCBoZWxwLCByZXZpZXcgTW9kdWxlIDMsIG9yIHNlZSBteSBzb2x1dGlvbiBhdCB0aGUgZW5kIG9mIHRoaXMgaGFuZG91dC4gV2hhdCBkb2VzIHRoaXMgc2ltcGxlIGdyYXBoIHRlbGwgeW91IGFib3V0IHRoZSBoZWFsdGggb2YgdGhlc2UgdGhyZWUgbGFrZXM/CgpgYGB7ciBsYWtlIGhpc3RzLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQpnZ3Bsb3QoZGF0YSA9IGxha2VzKSArCiAgZ2VvbV9oaXN0b2dyYW0oYWVzKHggPSBDaGxBLCBjb2xvciA9IExha2VOYW1lLCBmaWxsPUxha2VOYW1lKSwgcG9zaXRpb249ImRvZGdlIikKCmBgYAoKCiMjIERpc3RyaWJ1dGlvbiBncmFwaHMgZm9yIGNhdGVnb3JpY2FsIGRhdGEKVGhlIGZ1bmN0aW9ucyBgaGlzdGAgYW5kIGBnZW9tX2hpc3RvZ3JhbWAgYXJlIGFwcHJvcHJpYXRlIGZvciAqKmNvbnRpbnVvdXMqKiAobnVtZXJpY2FsKSBkYXRhLiBGb3IgKipjYXRlZ29yaWNhbCoqIHZhcmlhYmxlcyAoZS5nLiBTcGVjaWVzIGFuZCBJc2xhbmQgaW4gdGhlIHBlbmd1aW4gZGF0YSBzZXQpIGl0IGlzIHVzdWFsbHkgYmV0dGVyIHRvIG1ha2UgYSBiYXIgZ3JhcGguIFRoZSBleGFtcGxlIGNvZGUgYmVsb3cgc2hvd3MgaG93IHRvIGdlbmVyYXRlIGEgYmFyIGdyYXBoIGluIGdncGxvdCAoY2YuIE1vZHVsZSAwMykuIE5vdGUgaG93IHdlIG1vZGlmeSB0aGUgZGVmYXVsdCBnZ3Bsb3QgY29sb3VyIHBhbGV0dGUgdG8gc29tZXRoaW5nIG1vcmUgYWNjZXNzaWJsZSB0byB2aWV3ZXJzIHdpdGggYXR5cGljYWwgY29sb3VyIHZpc2lvbjoKCgpgYGB7ciBjYXRlZ29yaWNhbCBkaXN0cmlidXRpb259CgojICJDb2xvdXItYmxpbmQgZnJpZW5kbHkiIHBhbGV0dGUgZnJvbSAjaHR0cHM6Ly9wZXJzb25hbC5zcm9uLm5sL35wYXVsdC8KIyBUaGVzZSBhcmUgaGV4YWRlY2ltYWwgY29sb3VyIGNvZGVzLiBUaGUgIyBpcyByZXF1aXJlZC4KY3VzdG9tUGFsZXR0ZSA8LSBjKCIjRERBQTMzIiwgIiNCQjU1NjYiLCAiIzAwNDQ4OCIpCgojIEdlbmVyYXRlIGEgc3RhY2tlZCBiYXIgcGxvdCwgYW5kIHVzZSBvdXIgY3VzdG9tIGNvbG91ciBwYWxldHRlCmdncGxvdChkYXRhID0gcGVuZ3VpbnMpICsKICBnZW9tX2JhcihhZXMoeCA9IGlzbGFuZCwgZmlsbD1zcGVjaWVzKSwgcG9zaXRpb24gPSAic3RhY2siKSArCiAgc2NhbGVfZmlsbF9tYW51YWwodmFsdWVzID0gY3VzdG9tUGFsZXR0ZSkKYGBgCgpFdmVuIGEgc2ltcGxlIGdyYXBoIGxpa2UgdGhpcyBoZWxwcyB5b3UgdG8gZ2V0IHRvIGtub3cgeW91ciBkYXRhLiBKdXN0IGJ5IGluc3BlY3Rpb24gd2Ugc2VlIHRoYXQgQmlzY29lIGlzbGFuZCBoYXMgdGhlIGxhcmdlc3QgcG9wdWxhdGlvbiwgVG9yZ2Vyc2VuIGhhcyBvbmx5IEFkZWxpZSBwZW5ndWlucywgRHJlYW0gSXNsYW5kIGhhcyBuZWFybHkgZXF1YWwgbnVtYmVycyBvZiBDaGluc3RyYXAgYW5kIEdlbnRvbywgZXRjLiBXaGVuIGZpcnN0IGFwcHJvYWNoaW5nIGEgYmlnIGRhdGEgc2V0LCBhbHdheXMgdGhpbmsgYWJvdXQgc3RhcnRpbmcgd2l0aCBzb21lIGdyYXBocy4KCgojIEV4ZXJjaXNlIDIKVGhlIGJhciBncmFwaCBhYm92ZSBpcyBpbiAic3RhY2tlZCIgZm9ybWF0LiBTb21lIHBlb3BsZSBwcmVmZXIgYmFyIGdyYXBocyB0byBoYXZlIHNlcGFyYXRlIGJhcnMgZm9yIGVhY2ggZ3JvdXAsIGFzIHNob3duIGJlbG93LiBXcml0ZSB0aGUgY29kZSBuZWVkZWQgdG8gZ2VuZXJhdGUgdGhpcyBncmFwaC4gSGludDogVGhpcyByZXF1aXJlcyBjaGFuZ2luZyBvbmx5IHRoZSB2YWx1ZSBvZiBvbmUgYXJndW1lbnQgaW4gdGhlIGNvZGUgYWJvdmUuIFNlZSBNb2R1bGUgMDMgZm9yIG1vcmUgcmV2aXNpb24gYXMgbmVlZGVkLgoKCmBgYHtyIGNhdGVnb3JpY2FsIGRpc3RyaWJ1dGlvbiBkb2RnZSwgZWNobz1GQUxTRSwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KCiMgIkNvbG91ci1ibGluZCBmcmllbmRseSIgcGFsZXR0ZSBmcm9tICNodHRwczovL3BlcnNvbmFsLnNyb24ubmwvfnBhdWx0LwojIFRoZXNlIGFyZSBoZXhhZGVjaW1hbCBjb2xvdXIgY29kZXMuIFRoZSAjIGlzIHJlcXVpcmVkLgpjdXN0b21QYWxldHRlIDwtIGMoIiNEREFBMzMiLCAiI0JCNTU2NiIsICIjMDA0NDg4IikKCiMgR2VuZXJhdGUgYSBzdGFja2VkIGJhciBwbG90LCBhbmQgdXNlIG91ciBjdXN0b20gY29sb3VyIHBhbGV0dGUKZ2dwbG90KGRhdGEgPSBwZW5ndWlucykgKwogIGdlb21fYmFyKGFlcyh4ID0gaXNsYW5kLCBmaWxsPXNwZWNpZXMpLCBwb3NpdGlvbiA9ICJkb2RnZSIpICsKICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21QYWxldHRlKQpgYGAKCiMjIE1lYXN1cmVzIG9mIENlbnRyYWwgVGVuZGVuY3kKTG9vayBhdCB0aGUgZ3JhcGggeW91IG1hZGUgZWFybGllciBzaG93aW5nIHRoZSBkaXN0cmlidXRpb25zIG9mIENobEEgZm9yIHRoZSB0aHJlZSBsYWtlcy4gWW91IG1pZ2h0IGRlc2NyaWJlIHRoZSBMYWtlIEVsbGVzbWVyZSBDaGxBIHJlYWRpbmdzIGFzICJtb3N0bHkgYmVsb3cgMTAwIiBhbmQgdGhlIExha2UgUm90b3J1YSByZWFkaW5ncyBhcyAibW9zdGx5IGJldHdlZW4gMTAgYW5kIDIwIi4gIFN0YXRlbWVudHMgbGlrZSB0aGlzIGFyZSBhdHRlbXB0cyB0byBkZXNjcmliZSBhICoqdHlwaWNhbCoqIHNjb3JlIGZyb20gYSBsYXJnZSBkYXRhIHNldC4gVGhleSBhbGxvdyB1cyB0byBjYXB0dXJlIHRoZSBmYWN0IHRoYXQsIGZvciBleGFtcGxlLCAqb3ZlcmFsbCosIExha2UgRWxsZXNtZXJlIGhhcyBoaWdoZXIgQ2hsQSByZWFkaW5ncyB0aGFuIExha2UgUm90b3J1YSBJdCBpcyBub3QgdGhlIGNhc2UgdGhhdCAqZXZlcnkqIEVsbGVzbWVyZSByZWFkaW5nIGlzIGhpZ2hlciB0aGFuICpldmVyeSogUm90b3J1YSByZWFkaW5nLCBidXQgKip0eXBpY2FsbHkqKiB0aGlzIGlzIHRoZSBjYXNlLiAKCkluIHN0YXRpc3RpY3MsIGEgcHJlY2lzZSBtZWFzdXJlIG9mIHN1Y2ggdHlwaWNhbGl0eSBpcyBjYWxsZWQgYSAqKk1lYXN1cmUgb2YgQ2VudHJhbCBUZW5kZW5jeSoqIChNQ1QpLiBUaGUgbW9zdCBjb21tb24gTUNUcyBhcmUgdGhlICoqbWVhbioqLCB0aGUgKiptZWRpYW4qKiBhbmQgdGhlICoqbW9kZSoqLiBUaGVzZSBhcmUsIHJlc3BlY3RpdmVseSwgdGhlIG1hdGhlbWF0aWNhbCBhdmVyYWdlLCB0aGUgbWlkZGxlIHNjb3JlLCBhbmQgdGhlIG1vc3QgZnJlcXVlbnQgc2NvcmUgKG9yIHNjb3JlcykgaW4gYSBkYXRhIHNldC4gVGhlcmUgYXJlIHNvbWUgc3VidGxlIHN0YXRpc3RpY2FsIGlzc3VlcyBhcm91bmQgd2hpY2ggb2YgdGhlIHRocmVlIE1DVCBpcyBhcHByb3ByaWF0ZSBmb3IgYW55IGdpdmVuIGRhdGEgYW5hbHlzaXMgc2l0dWF0aW9uIChhc2sgeW91ciBsZWN0dXJlciBmb3IgZGV0YWlscyksIGJ1dCB0aGV5IGFyZSBhbGwgZWFzeSB0byBjb21wdXRlIGluIFIgKHdlIGhhdmUsIGluIGZhY3QsIGFscmVhZHkgbWV0IGZ1bmN0aW9uIGBtZWFuYCBpbiBlYXJsaWVyIG1vZHVsZXMpLCBhbmQgd2Ugc2hvdyBleGFtcGxlIGNvZGUgYmVsb3cgZm9yIGNvbXB1dGluZyB0aGVzZSBkZXNjcmlwdGl2ZSBzdGF0aXN0aWNzIG9uIGEgc2luZ2xlIGNvbHVtbiBvZiBkYXRhIGZyb20gdGhlIHBlbmd1aW5zIGRhdGEgc2V0LgoKTm90ZSB0aGF0IHRoZSBwZW5ndWlucyBkYXRhIGhhcyBzb21lIG1pc3Npbmcgc29tZSB2YWx1ZXMgKGNmLiBNb2R1bGUgMDEgLSBUaWR5IERhdGEpLCBUaGUgZnVuY3Rpb25zIGZvciBtZWFuIGFuZCBtZWRpYW4gd2lsbCBub3Qgd29yayBpZiB0aGUgaW5wdXQgZGF0YSBoYXZlIGFueSBgTkFgIChtaXNzaW5nKSB2YWx1ZXMuIFRoZSBtb3N0IGNvbW1vbiBzb2x1dGlvbiBpcyB0byBvbWl0IHRob3NlIHNjb3JlcyBmcm9tIHRoZSBjb21wdXRhdGlvbiBieSBzZXR0aW5nIHRoZSBgbmEucm1gIGFyZ3VtZW50IHRvIGBUUlVFYCBhcyBzaG93bjoKCmBgYHtyIE1DVCwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KCiMgTWVhbgoKIyBXZSBoYXZlIHNlZW4gdGhpcyBjb2RlIGJlZm9yZS4uLiBXZSBwYXNzIHRoZSBjb2x1bW4gb2YgaW50ZXJlc3QKIyB0byBmdW5jdGlvbiBtZWFuCm1lYW4ocGVuZ3VpbnMkYm9keV9tYXNzX2csIG5hLnJtPVRSVUUpCgoKIyBNZWRpYW4KCiMgVGhlIGZhbWlsaWFyIHBhdHRlcm4uLi4uCm1lZGlhbihwZW5ndWlucyRib2R5X21hc3NfZywgbmEucm0gPSBUUlVFKQoKCiMgTW9kZQoKIyBCYXNlIFIgaGFzIG5vIGJ1aWx0LWluIGZ1bmN0aW9uIGZvciBtb2RlLiBBZnRlciBNb2R1bGUgMDgKIyB5b3Ugd2lsbCBiZSBhYmxlIHRvIHdyaXRlIHlvdXIgb3duIE1vZGUgZnVuY3Rpb24uIE9yIHlvdSBjYW4KIyB1c2Ugb25lIG9mIHNldmVyYWwgYXZhaWxhYmxlIGluIGF1eGlsaWFyeSBsaWJyYXJpZXMuIFRoZQojIERlc2NUb29scyBsaWJyYXJ5IGlzIGEgZ29vZCBvbmUuCgojIEluc3RhbGwgdGhlIHBhY2thZ2Ugb25jZSBvbiBlYWNoIG1hY2hpbmUKIyBpbnN0YWxsLnBhY2thZ2VzKCJEZXNjVG9vbHMiKQoKIyBMb2FkIHRoZSBsaWJyYXJ5IG9uY2UgZWFjaCBzZXNzaW9uCmxpYnJhcnkoRGVzY1Rvb2xzKQoKI0NhbGwgdGhlIGZ1bmN0aW9uCk1vZGUocGVuZ3VpbnMkYm9keV9tYXNzX2csIG5hLnJtPVRSVUUpCgpgYGAKTm90ZSB0aGF0IERlc2NUb29sczo6TW9kZSByZXR1cm5zIHRoZSBtb2RhbCAoaS5lLiBtb3N0IGNvbW1vbiB2YWx1ZSkgd2l0aCBhbiBhdHRhY2hlZCAqKmF0dHJpYnV0ZSoqIGNhbGxlZCAiZnJlcSIgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBvY2N1cmVuY2VzLgoKCiMjIFVzaW5nIGZ1bmN0aW9uIGBzdW1tYXJ5YApXaGVuIHlvdSBoYXZlIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgZGF0YSBtZWFzdXJlcywgeW91IG1heSB3aXNoIHRvIGNvbXB1dGUgTUNUcyBmb3IgaW5kaXZpZHVhbCBjb2x1bW5zIGFzIHNob3duIGFib3ZlLiBBbiBlZmZpY2llbnQgYWx0ZXJuYXRpdmUgZm9yIHNtYWxsZXIgZGF0YSBzZXRzIGlzIHRvIHVzZSBmdW5jdGlvbiBgc3VtbWFyeWAsIHdoaWNoIGFjY2VwdHMgYSBkYXRhIGZyYW1lIGFuZCBzdW1tYXJpc2VzICphbGwqIGl0cyBjb2x1bW5zIGF0IG9uY2UuIEZ1bmN0aW9uIGBzdW1tYXJ5YCBjb21wdXRlcyBmcmVxdWVuY2llcyBmb3IgY2F0ZWdvcmljYWwgdmFyaWFibGVzLCBhbmQgbWVhc3VyZXMgb2YgY2VudHJhbCB0ZW5kZW5jeSBmb3IgY29udGludW91cyB2YXJpYWJsZXMuIEl0IGFsc28gcmVwb3J0cyB0aGUgbnVtYmVycyBvZiBOQSB2YWx1ZXMgaW4gZWFjaCBjb2x1bW4uIEZ1bmN0aW9uIGBzdW1tYXJ5YCBwcm92aWRlcyBzb21lIGFkZGl0aW9uYWwgbWVhc3VyZXMgKG1pbmltdW0sIDFzdCBxdWFydGlsZSwgM3JkIHF1YXJ0aWxlLCBhbmQgbWF4aW11bSkgdGhhdCB3ZSB3aWxsIGRpc2N1c3MgaW4gbW9yZSBkZXRhaWwgbGF0ZXIuCgpgYGB7ciBzdW1tYXJ5fQpzdW1tYXJ5KHBlbmd1aW5zKQpgYGAKCiMgRXhlcmNpc2UgMwpUaGUgcmVzdWx0cyBmb3IgY29sdW1uIGB5ZWFyYCBtYXkgbm90IGJlIHdoYXQgeW91IGV4cGVjdGVkLiBGdW5jdGlvbiBgc3VtbWFyeWAgaGFzIGNvbXB1dGVkIGFuICphdmVyYWdlIHZhbHVlKiBmb3IgYHllYXJgLiBEb2VzIHRoaXMgc2VlbSBsaWtlIHRoZSBhcHByb3ByaWF0ZSBhbmFseXNpcz8gKEFuc3dlciA9PiBOby4pIE1vZGlmeSBgcGVuZ3VpbnNgIHRvIG1ha2UgYHN1bW1hcnlgIHRyZWF0IHRoZSBgeWVhcmAgZGF0YSBjb3JyZWN0bHksIGFuZCByZXJ1biBgc3VtbWFyeWAuCgoKIyMgTWVhc3VyZXMgb2YgVmFyaWFiaWxpdHkKSW4gdGhlIGhpc3RvZ3JhbXMgZm9yIENobEEgZnJvbSBlYWNoIG9mIHRocmVlIE5ldyBaZWFsYW5kIGxha2VzLCB0aGUgdGhyZWUgZ3JvdXBzIG9mIHNjb3JlcyBkaWQgbm90IG92ZXJsYXAgY29tcGxldGVseSwgaW5kaWNhdGluZyB0aGF0IHRoZSB0eXBpY2FsIHZhbHVlcyAtLSB0aGUgY2VudHJhbCB0ZW5kZW5jaWVzIC0tIHdlcmUgZGlmZmVyZW50IGZvciB0aGUgdGhyZWUgbGFrZXMuIFdlIGNhbiBjb25maXJtIHRoaXMgb2JzZXJ2YXRpb24gYnkgY29tcGFyaW5nIHRoZSBtZWFucy4gV2UgY2FuIHVzZSBmdW5jdGlvbiBgYWdncmVnYXRlYCBvciBgZ3JvdXBfYnlgIGFuZCBgc3VtbWFyaXNlYCBmcm9tIHBhY2thZ2UgYGRwbHlyYCAoY2YuIE1vZHVsZSAwMykuCgpgYGB7ciBsYWtlIG1lYW5zfQojIFVzaW5nIGFnZ3JlZ2F0ZS4gY29tcHV0ZSB0aGUgZ3JvdXAgbWVhbnMKYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU49bWVhbikKCiMgVXNpbmcgZHBseXIgLS0gaW5zdGFsbCB0aWR5dmVyc2UgZmlyc3QgaWYgbmVlZGVkCmxpYnJhcnkoZHBseXIpCmJ5X2xha2UgPC0gZ3JvdXBfYnkobGFrZXMsIExha2VOYW1lKQpzdW1tYXJpc2UoYnlfbGFrZSwgTWVhbl9DaGxBID0gbWVhbihDaGxBKSkKYGBgCgpIb3dldmVyLCBub3Qgb25seSBkbyB0aGUgY2VudHJhbCBwb2ludHMgb2YgdGhlIHRocmVlIGxha2VzJyBkaXN0cmlidXRpb25zIGRpZmZlciwgc28gZG8gdGhlIGFtb3VudHMgb2YgInNwcmVhZCIuIExha2UgVGF1cG8ncyBkaXN0cmlidXRpb24gaXMgdmVyeSAic2tpbm55IjsgYWxsIGl0cyByZWFkaW5ncyBhcmUgc2ltaWxhci4gTGFrZSBFbGxlc21lcmUgaXMgc3F1YXNoZWQgYW5kIHNwcmVhZCBvdXQ7IGl0cyByZWFkaW5ncyB2YXJ5IGEgbG90LiBMYWtlIFJvdG9ydWEgaXMgaW50ZXJtZWRpYXRlLiBUbyBpbGx1c3RyYXRlIHRoaXMgbW9yZSBjbGVhcmx5LCB3ZSBjYW4gdXNlIGdncGxvdCB0byBtYWtlIHNlcGFyYXRlIGdyYXBocyBmb3IgZWFjaCBsYWtlLCBhZGp1c3RpbmcgdGhlIHktYXhlcyB0byBtYWtlIGNvbXBhcmlzb24gZWFzaWVyIChub3RlIHRoZSBhcmd1bWVudHMgdG8gYGZhY2V0X2dyaWRgKS4KCmBgYHtyIGZhY2V0IGdyYXBocywgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KZ2dwbG90KGRhdGEgPSBsYWtlcykgKwogIGdlb21faGlzdG9ncmFtKGFlcyh4ID0gQ2hsQSwgZmlsbD1MYWtlTmFtZSksIGNvbG9yPSJibGFjayIpICsKICBmYWNldF9ncmlkKHJvd3MgPSB2YXJzKExha2VOYW1lKSwgc2NhbGVzPSJmcmVlX3kiKQpgYGAKClN0YXRpc3RpY2FsbHksIHRoZSAic3ByZWFkIG91dCIgcXVhbGl0eSBvZiBhIGRpc3RyaWJ1dGlvbiByZWZsZWN0cyBpdHMgKip2YXJpYWJpbGl0eSoqLgoKV2UgY2FuIGNhcHR1cmUgdmFyaWFiaWxpdHkgbW9yZSBwcmVjaXNlbHkgd2l0aCBtZWFzdXJlcyBvZiB0aGUgKipyYW5nZSoqIG9mIHRoZSBkYXRhIHNldC4gVGhlc2UgYXJlIHR5cGljYWxseSB0aGUgc21hbGxlc3QgYW5kIGxhcmdlc3Qgc2NvcmVzIChtaW5pbXVtIGFuZCBtYXhpbXVtKSBhbmQgdGhlIHNjb3JlcyBhdCB0aGUgMjV0aCBhbmQgNzV0aCBwZXJjZW50aWxlcyAoYWxzbyBjYWxsZWQgKioxc3QgcXVhcnRpbGUqKiBhbmQgKiozcmQgcXVhcnRpbGUqKikuIEVhcmxpZXIsIHdlIHNhdyB0aGF0IGZ1bmN0aW9uIGBzdW1tYXJ5YCBjb21wdXRlcyB0aGVzZSBtZWFzdXJlcyBvZiByYW5nZS4gSG93ZXZlciwgaWYgd2Ugc2ltcGx5IHBhc3MgdGhlIGVudGlyZSBgbGFrZXNgIGRhdGEgZnJhbWUgdG8gZnVuY3Rpb24gYHN1bW1hcnlgLCBpdCB3aWxsIGNvbWJpbmUgdGhlIGRhdGEgZnJvbSBhbGwgdGhyZWUgbGFrZXMgLS0gdG8gY29tcGFyZSB0aGUgbGFrZXMgd2UgbmVlZCB0aGUgdmFsdWVzIGZyb20gZWFjaCBsYWtlIHNlcGFyYXRlbHkuCgpJbiBNb2R1bGUgMDIgd2Ugc2F3IHRoYXQgd2UgY291bGQgc29sdmUgdGhpcyBwcm9ibGVtIGJ5IHVzaW5nIGZ1bmN0aW9uIGBzdWJzZXRgIHRvIHNlbGVjdCBvdXQganVzdCB0aGUgcm93cyBmcm9tIG9uZSBsYWtlLCBhbmQgcGFzc2luZyB0aG9zZSByb3dzIHRvIGBzdW1tYXJ5YC4gSG93ZXZlciwgd2UgY2FuIGFjaGlldmUgdGhlIHNhbWUgcmVzdWx0IG1vcmUgcGFyc2ltb25pb3VzbHkgYnkgdXNpbmcgZnVuY3Rpb24gYGFnZ3JlZ2F0ZWAuIEFib3ZlIHdlIHVzZWQgYWdncmVnYXRlIHdpdGggYEZVTiA9IG1lYW5gIHRvIGdldCB0aGUgbWVhbiBDaGxBIGZvciBlYWNoIGxha2UuIFdlIGNhbiB1c2UgYEZVTiA9IHN1bW1hcnlgIHRvIGNhbGwgZnVuY3Rpb24gYHN1bW1hcnlgIHNlcGFyYXRlbHkgZm9yIHRoZSByZWNvcmRzIG9mIGVhY2ggbGFrZS4gKFRoZSBzYW1lIHJlc3VsdCBjYW4gYmUgYWNoaWV2ZWQgd2l0aCBgZ3JvdXBfYnlgIGFuZCBgc3VtbWFyaXNlYC4pCgpgYGB7ciBhZ2dyZWdhdGUgc3VtbWFyeX0KYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU49c3VtbWFyeSkKYGBgCgpXZSBjYW4gYWxzbyBtZWFzdXJlIHRoZSB2YXJpYWJsaXR5IGluIGEgZGF0YSBzZXQgd2l0aCB0aGUgKipzdGFuZGFyZCBkZXZpYXRpb24qKi4gVGhlIHN0YW5kYXJkIGRldmlhdGlvbiBpcyB0aGUgbW9zdCBjb21tb25seSB1c2VkIG1lYXN1cmUgb2YgdmFyaWFiaWxpdHksIGFuZCBpdCBwbGF5cyBhbiBpbXBvcnRhbnQgbWF0aGVtYXRpY2FsIHJvbGUgaW4gaW5mZXJlbnRpYWwgc3RhdGlzdGljcyAoYXNrIHlvdXIgc3RhdHMgbGVjdHVyZXIgZm9yIGRldGFpbHMgLS0gaXQncyB2ZXJ5IGludGVyZXN0aW5nKS4gQ29uY2VwdHVhbGx5LCB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIGlzICphbG1vc3QqIGVxdWFsIHRvIHRoZSBhdmVyYWdlIGRpc3RhbmNlIGZyb20gdGhlIG1lYW4gYWNyb3NzIGFsbCB0aGUgdmFsdWVzIGluIGEgZGF0YSBzZXQgLS0gaXQgZG9lc24ndCBlcXVhbCAqZXhhY3RseSogdGhhdCB2YWx1ZSwgYmVjYXVzZSBvZiBob3cgaXQgaXMgY29tcHV0ZWQsIGJ1dCBpdCBpcyBjbG9zZSwgYW5kIGl0IGNhbiBiZSBoZWxwZnVsIHRvIHRoaW5rIG9mIGl0IHdpdGggdGhpcyBhcHByb3hpbWF0aW9uLiBCaWcgc3RhbmRhcmQgZGV2aWF0aW9uIHNob3dzIHRoYXQgc2NvcmVzIGFyZSBzcHJlYWQgZmFyIGZyb20gdGhlaXIgbWVhbjsgc21hbGwgc3RhbmRhcmQgZGV2aWF0aW9uIHNob3dzIHRoYXQgc2NvcmVzIHRlbmQgdG8gaHVkZGxlIGNsb3NlIHRvIHRoZWlyIG1lYW4uIENvbXB1dGUgc3RhbmRhcmQgZGV2aWF0aW9uIHdpdGggZnVuY3Rpb24gYHNkYC4KCmBgYHtyIHNkfQoKIyBSZW1lbWJlciB5b3UgY2FuIHNhdmUgaGF2aW5nIHRvIHR5cGUgdGhlIGRhdGEgZnJhbWUKIyBuYW1lIGJ5IHVzaW5nIGF0dGFjaAphdHRhY2gobGFrZXMpCmFnZ3JlZ2F0ZShDaGxBLCBieSA9IGxpc3QoTGFrZSA9IExha2VOYW1lKSwgRlVOPXNkKQoKIyBNb3JlIHByb2Nlc3Npbmcgb2YgZGF0YSBmcmFtZSBsYWtlcyBjb3VsZCBnbyBoZXJlLi4uLi4uLi4KCiMgQnV0IHJlbWVtYmVyIHRvIGRldGFjaCB3aGVuIHlvdSdyZSBmaW5pc2hlZC4uLgpkZXRhY2gobGFrZXMpCmBgYAoKVGhlIGhpc3RvZ3JhbXMsIHRoZSBtZWFzdXJlcyBvZiByYW5nZSwgYW5kIHRoZSBzdGFuZGFyZCBkZXZpYXRpb25zIGFsbCBpbmRpY2F0ZSB0aGF0IFRhdXBvIGhhcyB2ZXJ5IHN0YWJsZSBDaGxBIG1lYXN1cmVzLCBSb3RvcnVhIGlzIGEgbGl0dGxlIG5vaXNpZXIsIGFuZCBFbGxlc21lcmUgaXMgYWxsIG92ZXIgdGhlIHBsYWNlLiBUaGlzIHBoeXRvcGxhbmt0b24gYmlvbWFzcyBzdGFiaWxpdHkgaXMgYW4gaW1wb3J0YW50IGluZGljYXRvciBvZiBsYWtlIGhlYWx0aCAtLSBhIHN0YWJsZSBsYWtlIGlzIGF0IG11Y2ggbG93ZXIgcmlzayBvZiBhIHRveGljIGFsZ2FsIGJsb29tLgoKCiMjIEVmZmljaWVudCBjb2RlIGZvciBkZXNjcmlwdGl2ZSBzdGF0aXN0aWNzClRoZSBmdW5jdGlvbiBgZGVzY3JpYmVCeWAgaW4gcGFja2FnZSBgcHN5Y2hgIHdpbGwgIGNvbXB1dGUgYWxsIHRoZSBkZXNjcmlwdGl2ZSBzdW1tYXJpZXMgd2UgaGF2ZSBzZWVuIChhbmQgYSBmZXcgbW9yZSkgaW4gb25lIHN0YXRlbWVudC4gV2hlbiB5b3UgYXJlIGV4cGxvcmluZyBhIHNpbmdsZSBkYXRhIGNvbHVtbiBhbmQgYSBzaW5nbGUgZ3JvdXBpbmcgY29sdW1uIChzbyB0aGUgb3V0cHV0IGRvZXNuJ3QgZ2V0IHRvbyBsYXJnZSksIHRoaXMgaXMgYSB2ZXJ5IHVzZWZ1bCBmdW5jdGlvbi4gCgoKYGBge3IgcHN5Y2h9CiMgSW5zdGFsbCBvbmNlIG9uIGFueSBjb21wdXRlcgojaW5zdGFsbC5wYWNrYWdlcygicHN5Y2giKQoKIyBDYWxsIG9uY2UgZWFjaCBSIHNlc3Npb24KbGlicmFyeShwc3ljaCkKCiMgUGFzcyBpbiB0aGUgZGF0YSBjb2x1bW4gYW5kIHRoZSBncm91cGluZyBjb2x1bW4KZGVzY3JpYmVCeShsYWtlcyRDaGxBLCBsYWtlcyRMYWtlTmFtZSkKYGBgCgpQYWNrYWdlIGBwc3ljaGAgY29udGFpbnMgbWFueSBvdGhlciBpbnRlcmVzdGluZyBzdGF0aXN0aWNhbCB0b29scywgZXNwZWNpYWxseSBmb3IgbXVsdGl2YXJpYXRlIGRhdGEgc2V0cyBjb21tb25seSBmb3VuZCBpbiBwc3ljaG9sb2dpY2FsIGFuZCBlY29sb2dpY2FsIHJlc2VhcmNoLiBBc2sgR29vZ2xlIG9yIHlvdXIgbGVjdHVyZXIgZm9yIGRldGFpbHMuCgojIyBFeHBsb3JpbmcgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHR3byB2YXJpYWJsZXMKVGhlIHByZWNlZGluZyBkZXNjcmlwdGl2ZSBzdGF0aXN0aWNzIGFsbCBsb29rZWQgYXQgZGF0YSBtZWFzdXJlcyAtLSBDaGxBLCBiaWxsIGxlbmd0aCwgYm9keSB3ZWlnaHQsIGV0Yy4gLS0gaW5kaXZpZHVhbGx5LCBzdW1tYXJpc2luZyB0aGVpciBkaXN0cmlidXRpb24sIGNlbnRyYWwgdGVuZGVuY3kgYW5kIHZhcmlhYmlsaXR5LiBPZnRlbiwgaG93ZXZlciwgd2UgYXJlIGludGVyZXN0ZWQgaW4gZGVzY3JpYmluZyAqKnRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBkYXRhIG1lYXN1cmVzKiouIEZvciBleGFtcGxlLCB3ZSBtaWdodCB3YW50IHRvIGtub3cgaWYgaGVhdmllciBwZW5ndWlucyBhbHNvIHRlbmQgdG8gaGF2ZSBsb25nZXIgYmlsbHMuIFRoaXMgdHlwZSBvZiByZWxhdGlvbnNoaXAgaXMgY2FsbGVkIGEgKipjb3JyZWxhdGlvbioqLiBXaGVuIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBtZWFzdXJlIGZvciBlYWNoIGV4cGVyaW1lbnRhbCBwYXJ0aWNpcGFudCAob3IgZWFjaCBwZW5ndWluLCBvciBlYWNoIGxha2UpIHdlIGNhbiBleHBsb3JlIGNvcnJlbGF0aW9ucyBiZXR3ZWVuIHBhaXJzIG9mIG1lYXN1cmVzIGdyYXBoaWNhbGx5IHdpdGggYSAqKnNjYXR0ZXJwbG90KiouIEEgc2NhdHRlcnBsb3QgaGFzIG9uZSBtZWFzdXJlIG9uIGVhY2ggYXhpcywgYW5kIG9uZSBwb2ludCBmb3IgZWFjaCBwYXJ0aWNpcGFudCdzIHBhaXIgb2Ygc2NvcmVzLgoKSW4gdGhlIGNvZGUgZXhhbXBsZSBiZWxvdyB3ZSBtYWtlIGEgc2NhdHRlcnBsb3Qgd2l0aCBnZ3Bsb3QgKGNmLiBNb2R1bGUgMDMpLCBhbmQgc2hvdyBob3cgdG8gYWRkIGEgKipsaW5lYXIgdHJlbmQgbGluZSoqLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgdGhlIGxpbmUgdGhhdCBydW5zIHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgc2NhdHRlcnBsb3QgcG9pbnRzLCBhbmQgaXQgaGVscHMgdXMgdG8gc2VlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJlbGF0aW9uc2hpcC4gTWF0aGVtYXRpY2FsbHksIHRyZW5kIGxpbmVzIGFyZSBhY3R1YWxseSB2ZXJ5IGNvbXBsaWNhdGVkIHRoaW5ncywgYW5kIHdlIGdlbmVyYXRlIHRoZW0gd2l0aCB0aGUgcG93ZXJmdWwgZnVuY3Rpb24gYGxtYCwoZm9yICoqbGluZWFyIG1vZGVsKiopLiBZb3Ugd2lsbCBsZWFybiBhYm91dCB0aGUgbWFueSBmYXNjaW5hdGluZyB0aGluZ3MgeW91IGNhbiBkbyB3aXRoIGxpbmVhciBtb2RlbGluZyBpZiB5b3UgdGFrZSBhZHZhbmNlZCBzdGF0aXN0aWNzIHBhcGVycy4KCgpgYGB7ciBzY2F0dGVycGxvdCwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KIyBnZW9tX3BvaW50IHBsb3RzIHRoZSBwb2ludHMgb2YgdGhlIHNjYXR0ZXJwbG90IAoKIyBnZW9tX3Ntb290aCBwbG90cyB0aGUgbGluZWFyIHRyZW5kIGxpbmUgY29tcHV0ZWQgd2l0aCBmdW5jdGlvbiBsbQoKIyBUaGUgc2UgYXJndW1lbnQgZGV0ZXJtaW5lcyB3aGV0aGVyIGVycm9yIGJhcnMgYXJlIHNob3duIAojIGFyb3VuZCB0aGUgdHJlbmQgbGluZS4KCmdncGxvdChkYXRhID0gcGVuZ3VpbnMsIG1hcHBpbmcgPSBhZXMoeCA9IGJvZHlfbWFzc19nLCB5ID0gYmlsbF9sZW5ndGhfbW0pKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCBzZT1GQUxTRSkKCmBgYAoKVGhlIHNjYXR0ZXJwbG90IGdpdmVzIHVzIGEgdmVyeSBjbGVhciBwaWN0dXJlOiB0aG9zZSBwZW5ndWlucyB3aXRoIGhpZ2hlciBib2R5IHdlaWdodHMgdGVuZCB0byBhbHNvIGhhdmUgbG9uZ2VyIGJpbGxzLCBhbmQgdGhpcyBpcyByZWZsZWN0ZWQgaW4gdGhlIHBvc2l0aXZlIHNsb3BlIG9mIHRoZSB0cmVuZGxpbmUuIE5vdGUgaG93ZXZlciB0aGF0IHRoaXMgaXMgbm90IGFuIGFic29sdXRlIHJ1bGUuIElzIGl0IGVhc3kgdG8gZmluZCBwYWlycyBvZiBwb2ludHMgc3VjaCB0aGF0IHRoZSBsaWdodGVyIG9mIHR3byBwZW5ndWlucyBoYXMgdGhlIGxvbmdlciBiaWxsLiBUaGlzIGlzIHR5cGljYWwgb2YgY29ycmVsYXRpb25hbCBkYXRhLiAKClRoZXJlIGFyZSB2YXJpb3VzIHN0YXRpc3RpY2FsIG1lYXN1cmVzIHRoYXQgY2FwdHVyZSB0aGUgc3RyZW5ndGggb2YgYSBjb3JyZWxhdGlvbiAoaS5lLiBob3cgY2xvc2UgaXQgaXMgdG8gYmVpbmcgYW4gYWJzb2x1dGUgcnVsZSkuIEZvciBjb250aW51b3VzLCBudW1lcmljYWwgZGF0YSAoc3VjaCBhcyBiaWxsIGxlbmd0aCBhbmQgYm9keSB3ZWlnaHQpIHVzZSB0aGUgUiBmdW5jdGlvbiBgY29yYCB0byBjb21wdXRlIHRoZSBudW1lcmljYWwgY29ycmVsYXRpb24gdmFsdWUuIEFzIHdpdGggbWVhbnMgYW5kIG1lZGlhbnMsIHdlIG11c3QgdGVsbCBgY29yYCBob3cgdG8gY29wZSB3aXRoIG1pc3NpbmcgZGF0YSAoTkEgc2NvcmVzKS4gVW5mb3J0dW5hdGVseSB0aGUgc3ludGF4IGlzIG5vdCBjb25zaXN0ZW50IGFjcm9zcyB0aGUgZnVuY3Rpb25zLiBGb3IgZnVuY3Rpb24gYG1lYW5gIHdlIHNldCBhcmd1bWVudCBgbmEucm0gPSBUUlVFYC4gRm9yIGZ1bmN0aW9uIGBjb3JgIHdlIG11c3Qgc2V0IGFyZ3VtZW50IGB1c2UgPSAiY29tcGxldGUub2JzImAsIG1lYW5pbmcgdGhhdCB3ZSB3YW50IHRoZSBmdW5jdGlvbiB0byB1c2Ugb25seSB0aG9zZSByb3dzIHRoYXQgYXJlIGNvbXBsZXRlIChpLmUuIGhhdmUgYm90aCB2YWx1ZXMpLiBUaGVzZSBpZGlvc3luY3JhY2llcyBvY2N1ciBmcm9tIHRpbWUgdG8gdGltZSBpbiBSOyB5b3UganVzdCBoYXZlIHRvIGxlYXJuIHRoZW0uCgpgYGB7ciBjb3J9CgojIFBhc3MgdGhlIHR3byBkYXRhIGNvbHVtbnMgaW50byBmdW5jdGlvbiBjb3IKY29yKHBlbmd1aW5zJGJpbGxfbGVuZ3RoX21tLCBwZW5ndWlucyRib2R5X21hc3NfZywgdXNlPSJjb21wbGV0ZS5vYnMiKQpgYGAKCkZ1bmN0aW9uIGBjb3JgIHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLiBDb3JyZWxhdGlvbnMgdGhhdCB0cmVuZCBkb3dud2FyZCAoaS5lLiBpZiBvbmUgc2NvcmUgaXMgaGlnaCwgdGhlIG90aGVyIHRlbmRzIHRvIGJlIGxvdykgd2lsbCBoYXZlIGEgbmVnYXRpdmUgY29ycmVsYXRpb24gdmFsdWUuIENvcnJlbGF0aW9ucyB0aGF0IHRyZW5kIHVwd2FyZCAoaS5lLiBpZiBvbmUgc2NvcmUgaXMgaGlnaCB0aGUgb3RoZXIgYWxzbyB0ZW5kcyB0byBiZSBoaWdoKSB3aWxsIGhhdmUgYSBwb3NpdGl2ZSBjb3JyZWxhdGlvbiB2YWx1ZS4gVGhlIGNsb3NlciB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYGNvcmAgaXMgdG8gMSwgdGhlIHN0cm9uZ2VyIHRoZSBjb3JyZWxhdGlvbiAoeW91IGtub3cgd2hvIHRvIHRhbGsgdG8gZm9yIG1vcmUgZGV0YWlsLCBkb24ndCB5b3U/KS4KCkZvciBleGFtcGxlLCBjb25zaWRlciB0aGVzZSB0d28gc2NhdHRlcnBsb3RzOgoKYGBge3IgY29tcGFyaW5nLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQpsaWJyYXJ5KGdyaWRFeHRyYSkKcGxvdDEgPC0gZ2dwbG90KGRhdGEgPSBwZW5ndWlucywgbWFwcGluZyA9IGFlcyh4ID0gYm9keV9tYXNzX2csIHkgPSBiaWxsX2xlbmd0aF9tbSkpICsKICBnZW9tX3BvaW50KCkgKwogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIHNlPUZBTFNFKQpwbG90MiA8LSBnZ3Bsb3QoZGF0YSA9IHBlbmd1aW5zLCBtYXBwaW5nID0gYWVzKHggPSBib2R5X21hc3NfZywgeSA9IGZsaXBwZXJfbGVuZ3RoX21tKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgc2U9RkFMU0UpCmdyaWQuYXJyYW5nZShwbG90MSwgcGxvdDIsIG5jb2w9MikKYGBgCgpgYGB7ciBjb3IgZXhlcmNpc2Ugc29sdXRpb24sIGVjaG89RkFMU0UsIGluY2x1ZGU9RkFMU0V9CmNvcihwZW5ndWlucyRib2R5X21hc3NfZywgcGVuZ3VpbnMkYmlsbF9sZW5ndGhfbW0sIHVzZT0iY29tcGxldGUub2JzIikKCmNvcihwZW5ndWlucyRib2R5X21hc3NfZywgcGVuZ3VpbnMkZmxpcHBlcl9sZW5ndGhfbW0sIHVzZT0iY29tcGxldGUub2JzIikKYGBgCiMgRXhlcmNpc2UgNApGb3Igb25lIG9mIHRoZSBzY2F0dGVycGxvdHMgYWJvdmUsIHRoZSBjb21wdXRlZCBjb3JyZWxhdGlvbiBzY29yZSBpcyAwLjYwLiBGb3IgdGhlIG90aGVyLCBpdCBpcyAwLjg3LiBGaXJzdCwgcHJlZGljdCB3aGljaCBpcyB3aGljaC4gU2Vjb25kLCB3cml0ZSB0aGUgbmVjZXNzYXJ5IFIgY29kZSB0byBjb25maXJtIHlvdXIgcHJlZGljdGlvbi4KCgojIEV4ZXJjaXNlIDUKNS4xLiBNYW55IHNjaWVudGlmaWMgZGF0YSBzZXRzIGhhdmUgaGlzdG9ncmFtcyB0aGF0IGFyZSAiYmVsbC1zaGFwZWQiLiBUaGF0IGlzLCBtb3N0IG9mIHRoZSB2YWx1ZXMgY2x1c3RlciBpbiB0aGUgbWlkZGxlLCBhbmQgdGhlIGZyZXF1ZW5jeSBkcm9wcyBvZmYgc3ltbWV0cmljYWxseSB0b3dhcmQgc21hbGxlciBhbmQgbGFyZ2VyIHNjb3Jlcy4gVGhlIGRpc3RyaWJ1dGlvbiBvZiBwZW5ndWluIGJvZHkgbWFzcyBpcyBhIGdvb2QgZXhhbXBsZSBvZiBhIGRhdGEgc2V0IHRoYXQgaXMgYXBwcm94aW1hdGVseSBiZWxsLXNoYXBlZC4KCk1hbnkgaW5mZXJlbnRpYWwgc3RhdGlzdGljYWwgdGVjaG5pcXVlcyByZXF1aXJlIGRhdGEgc2V0cyB0byBiZSBjbG9zZSB0byBhIHZlcnkgc3BlY2lmaWMgYmVsbC1zaGFwZSBjYWxsZWQgdGhlICoqbm9ybWFsIGN1cnZlKiouIElmIHlvdXIgZGF0YSBkZXZpYXRlIHRvbyBmYXIgZnJvbSAqKm5vcm1hbCoqLCB0aGUgaW5mZXJlbnRpYWwgdGVzdHMgd2lsbCBnaXZlIGluY29ycmVjdCByZXN1bHRzLiBUaGUgbW9zdCBzZXJpb3VzIHN1Y2ggZGV2aWF0aW9uIGlzICoqc2tldyoqLCB3aGljaCBpcyB3aGVuIHRoZSBiZWxsLXNoYXBlIHRpbHRzIHRvIG9uZSBzaWRlLCB3aXRoIGEgbG9uZyB0YWlsIGluIGVpdGhlciB0aGUgc21hbGxlciBvciBsYXJnZXIgZGlyZWN0aW9uLiAKClRoZSBwZW5ndWluIGJvZHkgbWFzcyBncmFwaCBpcyBub3QgcGVyZmVjdGx5IHN5bW1ldHJpY2FsLiBJdCBzaG93cyBhIGJpdCBvZiBza2V3bmVzcyB3aXRoIGEgbG9uZ2VyIHRhaWwgdG93YXJkIHRoZSBoZWF2aWVyIHBlbmd1aW5zLiBCdXQgbWFueSBkYXRhIHNldHMgZnJvbSBuYXR1cmUgYXJlICpleHRyZW1lbHkqIHNrZXdlZC4gV2UgY2FuIHNlZSB0aGlzIGluIHRoZSBsYWtlcyBkYXRhLiAKCk9ic2VydmUgTGFrZSBFbGxlc21lcmUgaW4gdGhlIGhpc3RvZ3JhbSBvZiB0aGUgdGhyZWUgbGFrZSdzIENobEEgcmVhZGluZ3MuIEFsdGhvdWdoIG1vc3Qgb2YgdGhlIHJlYWRpbmdzIGFyZSBjbHVzdGVyZWQgYmVsb3cgMTAwLCB0aGVyZSBhcmUgc29tZSBtdWNoIGxhcmdlciB2YWx1ZXMgLS0gb25lIHJlYWRpbmcgaXMgbW9yZSB0aGFuIDUwMCAtLSBjcmVhdGluZyBhIGxvbmcgInRhaWwiIHRvIHRoZSByaWdodC4gVGhlIENobEEgbWVhc3VyZSBpbiBMYWtlIEVsbGVzbWVyZSBpcyBza2V3ZWQuIAoKV2UgY2FuIGNvbXB1dGUgYW4gZXhhY3QgbnVtZXJpY2FsIHZhbHVlIGZvciB0aGUgc2tld25lc3Mgb2YgYSBkaXN0cmlidXRpb24gdXNpbmcgZnVuY3Rpb24gYHNrZXduZXNzYCBmcm9tIHBhY2thZ2UgYGUxMDcxYC4gQXMgaW4gdGhlIGV4YW1wbGVzIGFib3ZlLCB3ZSBjYW4gY29tcHV0ZSB0aGUgc2tld25lc3MgZm9yIGVhY2ggbGFrZSB1c2luZyBgYWdncmVnYXRlYCBvciwgaWYgd2UgYXJlIHVzaW5nIGBkcGx5cmAsIHVzaW5nIGBncm91cF9ieWAgYW5kIGBzdW1tYXJpc2VgLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gdXNlIGBkZXNjcmliZUJ5YCBhcyBhYm92ZS4gSXQgaW5jbHVkZXMgc2tld25lc3MgYW1vbmcgaXRzIHN1bW1hcnkgc3RhdGlzdGljcy4KCldpdGggdGhlIG1ldGhvZCBvZiB5b3VyIGNob2ljZSwgY29tcHV0ZSB0aGUgc2tld25lc3MgdmFsdWUgZm9yIGVhY2ggbGFrZS4gV2hhdCBkb2VzIHRoZSBwYXR0ZXJuIG9mIHJlc3VsdHMgdGVsbCB5b3UgYWJvdXQgdGhlIGhlYWx0aCBvZiB0aGUgdGhyZWUgbGFrZXM/CgpgYGB7ciBza2V3bmVzcywgZWNobyA9IEZBTFNFLCBpbmNsdWRlID0gRkFMU0UsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9CgojIEluc3RhbGwgcGFja2FnZSBvbmNlIGZvciBlYWNoIG1hY2hpbmUKIyBpbnN0YWxsLnBhY2thZ2VzKCJlMTA3MSIpCgojIExvYWQgbGlicmFyeSBvbmNlIGZvciBlYWNoIFIgc2Vzc2lvbgpsaWJyYXJ5KGUxMDcxKQoKIyBVc2luZyBiYXNlIFIKYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU4gPSBza2V3bmVzcykKCgojIFVzaW5nIGRwbHlyCmxpYnJhcnkoZHBseXIpCmJ5X2xha2UgPC0gZ3JvdXBfYnkobGFrZXMsIExha2VOYW1lKQpzdW1tYXJpc2UoYnlfbGFrZSwgU2tld25lc3MgPSBza2V3bmVzcyhDaGxBKSkKYGBgCgo1LjIuIEEgcGVyZmVjdGx5IHN5bW1ldHJpY2FsIGRpc3RyaWJ1dGlvbiB3aWxsIGhhdmUgYSBza2V3bmVzcyBvZiAwLiBBcyBhIGRpc3RyaWJ1dGlvbiB0aWx0cyBmdXJ0aGVyIGFuZCBmdXJ0aGVyIGZyb20gbm9ybWFsLCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHNrZXduZXNzIG1lYXN1cmUgZ29lcyB1cC4gV2hhdCBjb25zaXRpdHV0ZXMgInRvbyBtdWNoIHNrZXciIHZhcmllcyBiZXR3ZWVuIGRpc2NpcGxpbmVzLCBhbmQgZm9yIGFuIGFzc2lnbm1lbnQgeW91IHdpbGwgd2FudCB0byBjaGVjayB3aXRoIHlvdXIgbGVjdHVyZXIuIEhvd2V2ZXIsIGEgY29tbW9uIHJ1bGUgb2YgdGh1bWIgaXMgdGhhdCBhbnkgdmFsdWUgZ3JlYXRlciB0aGFuIDEgKG9yIGxlc3MgdGhhbiAtMSkgaGFzIGVub3VnaCBza2V3IHRoYXQgeW91IG5lZWQgdG8gdGhpbmsgYWJvdXQgZGVhbGluZyB3aXRoIGl0LiBBIHZhbHVlIGdyZWF0ZXIgdGhhbiAzIChhcyBmb3VuZCB3aXRoIHRoZSBMYWtlIEVsbGVzbWVyZSBkYXRhKSBpcyAqZGVmaW5pdGVseSogc2tld2VkLgoKQXMgbWVudGlvbmVkIGVhcmxpZXIsIG1hbnkgaW5mZXJlbnRpYWwgdGVzdHMgZ2l2ZSBpbmFjY3VyYXRlIHJlc3VsdHMgd2l0aCBza2V3ZWQgZGF0YSwgc28gaW4gY2FzZXMgbGlrZSB0aGUgbGFrZXMgZGF0YSwgd2UgbXVzdCAidW5za2V3IiBvdXIgdmFsdWVzLiBBIGNvbW1vbiBhcHByb2FjaCBpcyB0byBjb21wdXRlIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBlYWNoIGRhdGEgdmFsdWUgKHVzaW5nIFIgZnVuY3Rpb24gYGxvZ2ApLCBhbmQgYW5hbHlzZSB0aG9zZSBsb2dzIChhc2sgeW91ciBsZWN0dXJlciBhYm91dCBhbHRlcm5hdGl2ZSBhcHByb2FjaGVzKS4gVGhlIGxvZ2FyaXRobSBjb21wdXRhdGlvbiBwdWxscyBleHRyZW1lIHNjb3JlcyBpbiwgcmVkdWNpbmcgdGhlIHNrZXcsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG92ZXJhbGwgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGRhdGEgdmFsdWVzLiAKCkluIE1vZHVsZSAwNCB5b3Ugc2F3IGhvdyB0byBhZGQgYSBuZXcgY29tcHV0ZWQgY29sdW1uIHRvIGEgZGF0YSBmcmFtZSB1c2luZyBlaXRoZXIgZnVuY3Rpb24gYG11dGF0ZWAgb3IgdGhlIGAkYCBvcGVyYXRvci4gVXNpbmcgdGhlIHRlY2huaXF1ZSBvZiB5b3VyIGNob2ljZSwgYWRkIGEgY29sdW1uIHRvIGRhdGEgZnJhbWUgbGFrZXMgdGhhdCBob2xkcyB0aGUgbmF0dXJhbCBsb2cgb2YgZWFjaCBDaGxBIHJlYWRpbmcuCgpgYGB7ciBsb2dzIHNvbHV0aW9uLCBlY2hvPUZBTFNFLCBpbmNsdWRlPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQoKIyBBZGQgYSBuZXcgY29sdW1uIHRvIHRoZSBkYXRhIGZyYW1lIHRoYXQgaG9sZHMgdGhlIGxvZyBvZiB0aGUgcmF3IENobEEKIyBUaGlzIGNhbiBhbHNvIGJlIGRvbmUgd2l0aCBkcGx5cjo6bXV0YXRlCmxha2VzJGxvZ19DaGxBIDwtIGxvZyhsYWtlcyRDaGxBKQoKIyBQbG90IHRoZSBoaXN0b2dyYW0KCmdncGxvdChkYXRhID0gbGFrZXMpICsKICBnZW9tX2hpc3RvZ3JhbShhZXMoeCA9IGxvZ19DaGxBLCBjb2xvciA9IExha2VOYW1lLCBmaWxsPUxha2VOYW1lKSwgcG9zaXRpb249ImRvZGdlIikKYGBgCgozLiBVc2luZyBnZ3Bsb3QsIG1ha2UgYSBoaXN0b2dyYW0gb2YgYWxsIHRoZSBsb2cgQ2hsQSB2YWx1ZXMgaW4gZGF0YSBmcmFtZSBsYWtlcywgd2l0aCBlYWNoIGxha2UgaW4gYSBkaWZmZXJlbnQgY29sb3VyLiBUaGlzIGNvZGUgaXMgKmV4dHJlbWVseSogc2ltaWxhciB0byB0aGUgY29kZSB5b3Ugd3JvdGUgZm9yIHRoZSBlYXJsaWVyIGV4ZXJjaXNlLiBIb3cgd291bGQgeW91IGRlc2NyaWJlIHRoZXNlIGRpc3RyaWJ1dGlvbnMuIEFyZSBMYWtlIEVsbGVzbWVyZSdzIGxvZyBDaGxBIHZhbHVlcyBza2V3ZWQ/IFdoYXQgY2FuIHlvdSBwcm92aWRlIGFzIGV2aWRlbmNlIGZvciB5b3VyIGFuc3dlcj8KCgoKIyMgQ29kZSBzb2x1dGlvbiBmb3IgdGhlIGxha2VzIGhpc3RvZ3JhbQoKYGBge3IgbGFrZSBoaXN0cyBzb2x1dGlvbiwgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRSwgZXZhbD1GQUxTRX0KZ2dwbG90KGRhdGEgPSBsYWtlcykgKwogIGdlb21faGlzdG9ncmFtKGFlcyh4ID0gQ2hsQSwgY29sb3IgPSBMYWtlTmFtZSwgZmlsbD1MYWtlTmFtZSksIHBvc2l0aW9uPSJkb2RnZSIpCgpgYGAK</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("handout4.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Repeating Code</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R4SSP Semester 1 2022</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Intro</li>
    <li>
      <a href="01-intro.html">Intro to R and RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Focus</li>
    <li>
      <a href="02-visualise.html">Part 1: Visualising</a>
    </li>
    <li>
      <a href="03-subset.html">Part 2: Subsetting</a>
    </li>
    <li>
      <a href="04-summarise.html">Part 3: Summarising</a>
    </li>
    <li>
      <a href="05-transform.html">Part 4: Transforming</a>
    </li>
    <li>
      <a href="06-communicate.html">Part 5: Communicating</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Programming focus</li>
    <li>
      <a href="07-functions.html">Functions and Choices</a>
    </li>
    <li class="dropdown-header">Repeating Code</li>
    <li class="dropdown-header">Workflows</li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Zoom Notes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="zoom_notes_01.html">01 - Introducing R and RStudio</a>
    </li>
    <li>
      <a href="zoom_notes_02.html">02 - Visualising data</a>
    </li>
    <li>
      <a href="zoom_notes_03.html">03 - Subsetting data</a>
    </li>
    <li>
      <a href="zoom_notes_04.html">04 - Summarising data</a>
    </li>
    <li>
      <a href="zoom_notes_05.html">05 - Transforming data</a>
    </li>
    <li>
      <a href="zoom_notes_06.html">06 - Communicating data</a>
    </li>
    <li>
      <a href="zoom_notes_07.html">07 - Functions and Choices</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Repeating Code</h1>
<h4 class="date">Semester 1, 2022</h4>

</div>


<blockquote>
<h4 id="associated-material">Associated Material</h4>
<p>Zoom Notes: <a href="zoom_notes_08.html">Zoom Notes 08 - Repeating Code</a></p>
<p>Readings:</p>
<ul>
<li><a href="https://r4ds.had.co.nz/iteration.html">R for Data Science - Chapter 21</a></li>
</ul>
</blockquote>
<p><br />
</p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>In the previous module we saw how to make our code more <strong>modular</strong> by organising it into functions, each of which encapsulates some logically distinct task. By repeatedly calling a function, we can execute the same code many times, while only having to type it out once. This is <strong>code reuse</strong> and is an important goal in efficient software development.</p>
<p>We can also achieve code reuse through <strong>iteration</strong>. Iterative constructs, more casually called <strong>loops</strong> allow us to write out some commands once, then instruct R to execute them a specified number of times. The number of iterations can be made to vary, depending on the <strong>state</strong>. (Recall that <strong>state</strong> is the set of values of all the variables in the environment when a command is executed.) For example, we can write a loop that iterates as many times as there are rows in a data frame that we read from a file before the loop starts.</p>
<p>In R, as in most modern programming languages, there are different types of loops, with subtle differences in behaviour. See the recommended reading for details. In this module, we will concentrate on the most general kind of loop – the <strong>for loop</strong>.</p>
</div>
<div id="schematic" class="section level1">
<h1>Schematic</h1>
<p>In R a for loop has this structure:</p>
<p>for (<em>variable_name</em> in <em>some_kind_of_sequence</em>) { <em>Code to be repeated. Can be as long as required.</em> }</p>
<p>The keywords <strong>for</strong> and <strong>in</strong> are required, as are the round brackets in the <strong>loop header</strong>, and the curly brackets that delineate the code body.</p>
<p>The <em>some_kind_of sequence</em> is usually a vector. The code body is executed as many times as there are elements in the vector.</p>
<p>We will discuss the role of the <em>variable_name</em> element later in the module.</p>
</div>
<div id="basic-loop" class="section level1">
<h1>Basic loop</h1>
<p>A popular cheer in Australian sports is “Aussie!, Aussie!, Aussie!”. Assume that (for some inexplicable reason) you wished to print this cheer. That is, you want to print “Aussie!” to the console three times. Using only sequential code you would write:</p>
<pre class="r"><code>print(&quot;Aussie!&quot;)
print(&quot;Aussie!&quot;)
print(&quot;Aussie!&quot;)</code></pre>
<p>You are executing the identical line of code three times. Having to type the same line of code many times is boring, and simply multiplies the number of opportunities for typos and bugs to sneak in. (And in this toy example, we are only repeating one line of code three times; in a real computational situation we might need to repeats dozens of lines of code hundreds of times.) Using a for-loop, we can achieve the same output while only typing the command once.</p>
<pre class="r"><code>for (cheer in c(1,2,3))
{
  print(&quot;Aussie&quot;)
}
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;</code></pre>
<p>Match the parts of this loop to the schematic, noting the position of the keywords <strong>for</strong> and <strong>in</strong>, the brackets, and the <em>some_kind_of_sequence</em> element which is, in this case, the vector created by <code>c(1,2,3)</code>. Since there are three elements in the vector, the code body is executed three times.</p>
<div id="vector-sequences" class="section level2">
<h2>Vector sequences</h2>
<p>If we wanted to print “Aussie!” 5 times, we could increase the length of the vector to 5. If we wanted to print it 100 times (could happen) we could increase the length of the vector to 100, but using function <code>c()</code> for this is too cumbersome. In R, we have an alternative for generating a sequence of numbers using the <code>:</code> operator.</p>
<pre class="r"><code>small_seq &lt;- 1:5
small_seq
#&gt; [1] 1 2 3 4 5

big_seq &lt;- 1:50
big_seq
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
#&gt; [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50</code></pre>
<p>There are more powerful functions for generating sequences (see, for example <code>seq</code> and <code>rep</code>) but for basic for loops, the <code>:</code> operator is sufficient. We can extend our cheer-printing for-loop:</p>
<pre class="r"><code>for (cheer in 1:15)
{
  print(&quot;Aussie&quot;)
}
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;</code></pre>
</div>
</div>
<div id="the-loop-driver" class="section level1">
<h1>The Loop Driver</h1>
<p>Recall the schematic for an R for loop:</p>
<p>for (<em>variable_name</em> in <em>some_kind_of_sequence</em>) { <em>Code to be repeated. Can be as long as required.</em> }</p>
<p>The <em>variable_name</em> element can be any legal R variable name. This element is called the <strong>loop driver</strong>. Inside the code body of the for-loop the loop driver variable is always available. For example, in our “Aussie!, Aussie! Aussie!” example, our loop driver was called <em>cheer</em>. In our code body we could have referred to variable <code>cheer</code>.</p>
<p>As discussed above, the for loop code body is executed as many times as there are elements in the sequence in the header. At each pass through the loop, the loop driver automatically takes on <strong>the value of the corresponding element of the sequence</strong>. That is, in the first pass of the loop, the loop driver variable is assigned the value of the first element of the sequence; in the second pass of the loop, the loop driver variable is assigned the value of the second element of the sequence, and so on.</p>
<p>We illustrate this by extending our previous example to print the value of loop driver <code>cheer</code> inside the code body:</p>
<pre class="r"><code>for (cheer in 1:3)
{
  print(&quot;Aussie&quot;)
  print(cheer)
}
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] 1
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] 2
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] 3</code></pre>
<p>Note that you <strong>never assign</strong> a value to the loop driver – it takes on its values automatically as the for loop runs.</p>
<p>In all our examples so far, the sequence in the for-loop header has been numbers from 1 to <em>n</em>. In R, the sequence can be a vector of any type, and the loop driver will take on whatever values the sequence contains. For example, we can drive a for loop with a vector of string:</p>
<pre class="r"><code>sports &lt;- c(&quot;Rugby&quot;, &quot;Cycling&quot;, &quot;Ice Skating&quot;)
for (current_sport in sports)
{
  # Print the sport name
  print(current_sport)
  
  # Compute the number of characters in the sport name
  print(nchar(current_sport))
}
#&gt; [1] &quot;Rugby&quot;
#&gt; [1] 5
#&gt; [1] &quot;Cycling&quot;
#&gt; [1] 7
#&gt; [1] &quot;Ice Skating&quot;
#&gt; [1] 11</code></pre>
<div id="loop-driver-as-index" class="section level2">
<h2>Loop driver as index</h2>
<p>Throughout the course we have seen that R relies heavily on managing data in ordered collections (vectors, lists, and data frames). We select elements from those collections using [], providing the ordinal position of the element of interest. Since loop driver variables take on each value in their sequence, we can use a for loop to step through each element of a collection in turn.</p>
<p>For example, assume a data frame containing a student’s internal and exam marks for the papers taken in one semester:</p>
<pre class="r"><code>
paper_codes &lt;- c(&quot;HUBS192&quot;, &quot;ECOL212&quot;, &quot;STAT260&quot;)
internal_marks &lt;- c(87, 85, 62)
exam_marks &lt;- c(93, 84, 85)

marks_df &lt;- data.frame(PaperCode = paper_codes,
                       InternalMark = internal_marks,
                       ExamMarks = exam_marks)</code></pre>
<p>We know that we can select all columns from a single row in that data frame using the syntax [<em>row number</em>, ]</p>
<pre class="r"><code># Select and print row 2

selected_row &lt;- marks_df[2, ]
print(selected_row)
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 2   ECOL212           85        84</code></pre>
<p>With a for loop we can use the loop driver to iterate over all the rows, processing each in turn:</p>
<pre class="r"><code>for (index in 1:3)
{
  # Use the loop driver to index into the data frame
  selected_row &lt;- marks_df[index, ]
  print(selected_row)
}
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 1   HUBS192           87        93
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 2   ECOL212           85        84
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 3   STAT260           62        85</code></pre>
<p>Note that if we made our data frame longer than three rows by adding more papers to it, the preceding for loop <strong>would not</strong> print all the rows; the sequence in that exmaple is always <code>1, 2, 3</code> so we see only rows 1, 2, and 3. We can make the loop more general by determining the for-loop sequence <strong>dynamically</strong> using function <code>nrows</code>, which accepts a data frame as an argument, and returns the number of rows in the data frame:</p>
<pre class="r"><code>
# Display all rows
for (index in 1:nrow(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_row &lt;- marks_df[index, ]
  print(selected_row)
}
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 1   HUBS192           87        93
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 2   ECOL212           85        84
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 3   STAT260           62        85

# Add a row to the data frame
marks_df &lt;- rbind(marks_df, c(&quot;ZOOL316&quot;, 83, 90))


# Repeat the loop -- see four rows
for (index in 1:nrow(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_row &lt;- marks_df[index, ]
  print(selected_row)
}
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 1   HUBS192           87        93
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 2   ECOL212           85        84
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 3   STAT260           62        85
#&gt;   PaperCode InternalMark ExamMarks
#&gt; 4   ZOOL316           83        90</code></pre>
<div id="nesting-of-loops" class="section level3">
<h3>Nesting of loops</h3>
<p>It’s generally recommended to avoid the nesting of loops within other loops. Let’s say the outer loop has a total of <code>n</code> iterations to get through and an inner loop has <code>m</code>. Every time we add one extra iteration of the outer loop we end up adding an extra <code>m</code> iterations of the inner loop, so the total number of iterations is <code>n * m</code>. Depending on how big <code>m</code> is, this could be adding thousands or millions of extra iterations, causing your code to take longer to run. Some times however, nesting is unavoidable but it’s a good idea to keep an eye out for nesting if your code is taking a while to run as this is usually the first place things can be sped up.</p>
</div>
</div>
<div id="while-loop" class="section level2">
<h2>While loop</h2>
<p>The while loop is a useful loop to use when the length of the input vector is unknown. The situation where this arises often would be in simulations where you want to find out how many times something happened until you got a certain result – an exit condition.</p>
<p>The skeleton for a <code>while</code> loop is as follows:</p>
<pre class="r"><code>while (condition) {
  # loop body
}</code></pre>
<p>Here is an example of a <code>while</code> loop where we want to find out how many iterations it takes to obtain 3 heads in a row:</p>
<pre class="r"><code>## Example from R for Data Science - 21.3.4 ##

# Function to simulate head or tail as the result of a coin flip
flip &lt;- function(){
  sample(c(&quot;T&quot;, &quot;H&quot;), 1)
}

# variables to keep track of key results
flips &lt;- 0
nheads &lt;- 0

# flip a coin until there are three heads and count how many flips were performed.
while (nheads &lt; 3) {
  if (flip() == &quot;H&quot;) {
    nheads &lt;- nheads + 1
  } else {
    nheads &lt;- 0
  }
  flips &lt;- flips + 1
}
flips
#&gt; [1] 5</code></pre>
<p>It’s very important to <strong>always make sure your condition will eventually be FALSE before running!</strong> Otherwise you’ll be stuck in an ‘infinite loop’ where your code keeps running and never stopping. If you find yourself in this situation in RStudio, in the top right of the console window you can click the ‘stop’ sign, or under the <code>Session</code> menu click “Interrupt R” to make it stop.</p>
</div>
</div>
<div id="map" class="section level1">
<h1>Map</h1>
<p>From the package <code>purrr</code> (part of the tidyverse), there are a collection of <code>map</code> functions which are a method of iterating over a collection of things applying a function. This is known as <em>functional programming</em>, and allows us to extract the code that is in common for a loop, into a function, so rather than being concerned about the set-up of the loop, we can focus on the contents of the loop. This idea of mapping a function onto data is extremely similar to the concept underlying the <code>for</code> loop.</p>
<div id="map-and-friends" class="section level2">
<h2>Map and friends</h2>
<p>The package <code>purrr</code> within the tidyverse provides the <code>map</code> functions that take a vector or list as the first argument, and the second argument is the function to be run on each item in the vector or list. The object that is returned back with the results depends on the exact version of <code>map</code> that is called, the default <code>map()</code> returns the results as items in a list, but there are suffix versions of <code>map</code> that will return the results back in a specified data type.</p>
<ul>
<li><code>map()</code> makes a list.</li>
<li><code>map_lgl()</code> makes a logical vector.</li>
<li><code>map_int()</code> makes an integer vector.</li>
<li><code>map_dbl()</code> makes a double vector.</li>
<li><code>map_chr()</code> makes a character vector.</li>
</ul>
<p>These suffix versions will give an error if the data type of the results doesn’t match. This is useful for being able to program with, as it means that you can be sure that you have a particular data type for future code. Some of the base R functions that you will meet in the next section don’t provide this guarantee. The arguments to the <code>map</code> functions are <code>.x</code> which is the vector or list input, and <code>.f</code> which is the name of the function. if the supplied function takes multiple arguments these can be passed in as extra arguments to <code>map</code>.</p>
<p>We could use the example of converting some temperatures to demonstrate</p>
<pre class="r"><code>library(purrr)

farenheit_to_celcius &lt;- function(temp_f){
  temp_c &lt;- (temp_f -32) * 5/9
  return(temp_c)
}

my_temps_f &lt;- c(90, 78, 88, 89, 77)

# gives back a list
my_temps_c_list &lt;- map(.x = my_temps_f, .f = farenheit_to_celcius)
my_temps_c_list
#&gt; [[1]]
#&gt; [1] 32.22222
#&gt; 
#&gt; [[2]]
#&gt; [1] 25.55556
#&gt; 
#&gt; [[3]]
#&gt; [1] 31.11111
#&gt; 
#&gt; [[4]]
#&gt; [1] 31.66667
#&gt; 
#&gt; [[5]]
#&gt; [1] 25

# gives back a vector of type numeric/double
my_temps_c_dbl &lt;- map_dbl(.x = my_temps_f, .f = farenheit_to_celcius)
my_temps_c_dbl
#&gt; [1] 32.22222 25.55556 31.11111 31.66667 25.00000</code></pre>
<p>When using <code>map</code> and variants, don’t include the <code>()</code>’s on the function name, if you do you’ll get this error:</p>
<pre class="r"><code>map(.x = my_temps_f, .f = farenheit_to_celcius())
#&gt; Error in farenheit_to_celcius(): argument &quot;temp_f&quot; is missing, with no default</code></pre>
</div>
</div>
<div id="apply" class="section level1">
<h1>Apply</h1>
<p>Base R has built in functions for applying a function to a vector, list or data frame. There is <code>apply</code> which will apply a function to either columns or rows of a data frame, <code>lapply</code> for applying to a list or vector - it’s analogous to <code>map()</code>, and <code>vapply</code> which can takes the return data type as one of the arguments so can be thought of as analogous to the suffix versions of <code>map</code>. The <code>apply()</code> function is very similar to <code>map()</code></p>
<p>The equivalent example of what we did above with <code>map()</code> <code>and map_dbl()</code> is as follows:</p>
<pre class="r"><code>farenheit_to_celcius &lt;- function(temp_f){
  temp_c &lt;- (temp_f -32) * 5/9
  return(temp_c)
}

my_temps_f &lt;- c(90, 78, 88, 89, 77)

# lapply example
lapply_my_temps_c &lt;- lapply(X = my_temps_f, FUN = farenheit_to_celcius)
lapply_my_temps_c
#&gt; [[1]]
#&gt; [1] 32.22222
#&gt; 
#&gt; [[2]]
#&gt; [1] 25.55556
#&gt; 
#&gt; [[3]]
#&gt; [1] 31.11111
#&gt; 
#&gt; [[4]]
#&gt; [1] 31.66667
#&gt; 
#&gt; [[5]]
#&gt; [1] 25

# vapply example. FUN.VALUE defines the type and length size of each of the returned results. 
vapply_my_temps_c &lt;- vapply(X = my_temps_f, FUN = farenheit_to_celcius, FUN.VALUE = numeric(1))
vapply_my_temps_c
#&gt; [1] 32.22222 25.55556 31.11111 31.66667 25.00000</code></pre>
<p>We can see that there is a difference in the results that R returns between <code>lapply</code> and <code>vapply</code> by using <code>str</code> to look at the structure.</p>
<pre class="r"><code>str(lapply_my_temps_c)
#&gt; List of 5
#&gt;  $ : num 32.2
#&gt;  $ : num 25.6
#&gt;  $ : num 31.1
#&gt;  $ : num 31.7
#&gt;  $ : num 25
str(vapply_my_temps_c)
#&gt;  num [1:5] 32.2 25.6 31.1 31.7 25</code></pre>
<p><code>lapply_my_temps_c</code> is a <em>list</em> with each item being a numeric vector, whereas <code>sapply_my_temps_c</code> is single a <em>numeric</em> vector of (the data type that we specified). When we specified the data type for <code>vapply</code> we used <code>numeric(1)</code> as an argument. What this meant was that each time our function specified for <code>FUN =</code> is run, it was expected to return a vector of length 1 of type numeric. If this wasn’t the case, an error would occur. One thing to be aware of is that <code>vapply</code> doesn’t always return a vector, the data structure that it returns depends on the data going in. This can make it challenging to know beforehand what the output is going to look like - unlike the suffix versions of <code>map</code> from <code>purrr</code>.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>In this module we covered how repeat tasks efficiently. Combining iteration with part 1 - functions and flow and control - you now have the knowledge to be able to create code that is modular and reusable, and maintainable. This will enable you to be more efficient going forward with your programming and analysis.</p>
<div id="whats-next" class="section level2">
<h2>What’s Next</h2>
<p>Congratulations on finishing the course! This doesn’t have to be the end of your learning journey with R though. There are many free online resources to delve further in. If you haven’t already, a good place to start is the chapters of <a href="https://r4ds.had.co.nz">R for Data Science</a> that weren’t covered in the course. And if you want to get more in-depth with the R language the online book <a href="https://adv-r.hadley.nz">Advanced R</a> covers more of the R language and programming.</p>
<p>Please fill in the module feedback form <a href="https://tinyurl.com/r4ssp-module-fb">https://tinyurl.com/r4ssp-module-fb</a>.</p>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlJlcGVhdGluZyBDb2RlIg0KZGF0ZTogIlNlbWVzdGVyIDEsIDIwMjIiDQpvdXRwdXQ6DQogIGh0bWxfZG9jdW1lbnQ6DQogICAgdG9jOiB0cnVlDQogICAgdG9jX2Zsb2F0OiB0cnVlDQogICAgdG9jX2RlcHRoOiAzDQogICAgY29kZV9kb3dubG9hZDogdHJ1ZQ0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KLS0tDQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0KbGlicmFyeShrbml0cikNCg0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KA0KICBjb21tZW50ID0gIiM+IiwNCiAgZmlnLnBhdGggPSAiZmlndXJlcy8wOC8iLCAjIHVzZSBvbmx5IGZvciBzaW5nbGUgUm1kIGZpbGVzDQogIGNvbGxhcHNlID0gVFJVRSwNCiAgZWNobyA9IFRSVUUNCikNCg0KDQpgYGANCg0KPiAjIyMjIEFzc29jaWF0ZWQgTWF0ZXJpYWwNCj4NCj4gWm9vbSBOb3RlczogW1pvb20gTm90ZXMgMDggLSBSZXBlYXRpbmcgQ29kZV0oem9vbV9ub3Rlc18wOC5odG1sKQ0KPg0KPiBSZWFkaW5nczoNCj4NCj4gLSBbUiBmb3IgRGF0YSBTY2llbmNlIC0gQ2hhcHRlciAyMV0oaHR0cHM6Ly9yNGRzLmhhZC5jby5uei9pdGVyYXRpb24uaHRtbCkNCg0KXA0KDQojIEludHJvZHVjdGlvbg0KDQpJbiB0aGUgcHJldmlvdXMgbW9kdWxlIHdlIHNhdyBob3cgdG8gbWFrZSBvdXIgY29kZSBtb3JlICoqbW9kdWxhcioqIGJ5IG9yZ2FuaXNpbmcgaXQgaW50byBmdW5jdGlvbnMsIGVhY2ggb2Ygd2hpY2ggZW5jYXBzdWxhdGVzIHNvbWUgbG9naWNhbGx5IGRpc3RpbmN0IHRhc2suIEJ5IHJlcGVhdGVkbHkgY2FsbGluZyBhIGZ1bmN0aW9uLCB3ZSBjYW4gZXhlY3V0ZSB0aGUgc2FtZSBjb2RlIG1hbnkgdGltZXMsIHdoaWxlIG9ubHkgaGF2aW5nIHRvIHR5cGUgaXQgb3V0IG9uY2UuIFRoaXMgaXMgKipjb2RlIHJldXNlKiogYW5kIGlzIGFuIGltcG9ydGFudCBnb2FsIGluIGVmZmljaWVudCBzb2Z0d2FyZSBkZXZlbG9wbWVudC4NCg0KV2UgY2FuIGFsc28gYWNoaWV2ZSBjb2RlIHJldXNlIHRocm91Z2ggKippdGVyYXRpb24qKi4gSXRlcmF0aXZlIGNvbnN0cnVjdHMsIG1vcmUgY2FzdWFsbHkgY2FsbGVkICoqbG9vcHMqKiBhbGxvdyB1cyB0byB3cml0ZSBvdXQgc29tZSBjb21tYW5kcyBvbmNlLCB0aGVuIGluc3RydWN0IFIgdG8gZXhlY3V0ZSB0aGVtIGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGNhbiBiZSBtYWRlIHRvIHZhcnksIGRlcGVuZGluZyBvbiB0aGUgKipzdGF0ZSoqLiAoUmVjYWxsIHRoYXQgKipzdGF0ZSoqIGlzIHRoZSBzZXQgb2YgdmFsdWVzIG9mIGFsbCB0aGUgdmFyaWFibGVzIGluIHRoZSBlbnZpcm9ubWVudCB3aGVuIGEgY29tbWFuZCBpcyBleGVjdXRlZC4pIEZvciBleGFtcGxlLCB3ZSBjYW4gd3JpdGUgYSBsb29wIHRoYXQgaXRlcmF0ZXMgYXMgbWFueSB0aW1lcyBhcyB0aGVyZSBhcmUgcm93cyBpbiBhIGRhdGEgZnJhbWUgdGhhdCB3ZSByZWFkIGZyb20gYSBmaWxlIGJlZm9yZSB0aGUgbG9vcCBzdGFydHMuDQoNCkluIFIsIGFzIGluIG1vc3QgbW9kZXJuIHByb2dyYW1taW5nIGxhbmd1YWdlcywgdGhlcmUgYXJlIGRpZmZlcmVudCB0eXBlcyBvZiBsb29wcywgd2l0aCBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gYmVoYXZpb3VyLiBTZWUgdGhlIHJlY29tbWVuZGVkIHJlYWRpbmcgZm9yIGRldGFpbHMuIEluIHRoaXMgbW9kdWxlLCB3ZSB3aWxsIGNvbmNlbnRyYXRlIG9uIHRoZSBtb3N0IGdlbmVyYWwga2luZCBvZiBsb29wIC0tIHRoZSAqKmZvciBsb29wKiouDQoNCg0KIyBTY2hlbWF0aWMNCg0KSW4gUiBhIGZvciBsb29wIGhhcyB0aGlzIHN0cnVjdHVyZToNCg0KZm9yICgqdmFyaWFibGVfbmFtZSogaW4gKnNvbWVfa2luZF9vZl9zZXF1ZW5jZSopDQp7DQogICpDb2RlIHRvIGJlIHJlcGVhdGVkLiBDYW4gYmUgYXMgbG9uZyBhcyByZXF1aXJlZC4qDQp9DQoNCg0KVGhlIGtleXdvcmRzICoqZm9yKiogYW5kICoqaW4qKiBhcmUgcmVxdWlyZWQsIGFzIGFyZSB0aGUgcm91bmQgYnJhY2tldHMgaW4gdGhlICoqbG9vcCBoZWFkZXIqKiwgYW5kIHRoZSBjdXJseSBicmFja2V0cyB0aGF0IGRlbGluZWF0ZSB0aGUgY29kZSBib2R5Lg0KDQpUaGUgKnNvbWVfa2luZF9vZiBzZXF1ZW5jZSogaXMgdXN1YWxseSBhIHZlY3Rvci4gVGhlIGNvZGUgYm9keSBpcyBleGVjdXRlZCBhcyBtYW55IHRpbWVzIGFzIHRoZXJlIGFyZSBlbGVtZW50cyBpbiB0aGUgdmVjdG9yLg0KDQpXZSB3aWxsIGRpc2N1c3MgdGhlIHJvbGUgb2YgdGhlICp2YXJpYWJsZV9uYW1lKiBlbGVtZW50IGxhdGVyIGluIHRoZSBtb2R1bGUuDQoNCg0KIyBCYXNpYyBsb29wDQoNCkEgcG9wdWxhciBjaGVlciBpbiBBdXN0cmFsaWFuIHNwb3J0cyBpcyAiQXVzc2llISwgQXVzc2llISwgQXVzc2llISIuIEFzc3VtZSB0aGF0IChmb3Igc29tZSBpbmV4cGxpY2FibGUgcmVhc29uKSB5b3Ugd2lzaGVkIHRvIHByaW50IHRoaXMgY2hlZXIuIFRoYXQgaXMsIHlvdSB3YW50IHRvIHByaW50ICJBdXNzaWUhIiB0byB0aGUgY29uc29sZSB0aHJlZSB0aW1lcy4gVXNpbmcgb25seSBzZXF1ZW50aWFsIGNvZGUgeW91IHdvdWxkIHdyaXRlOg0KDQpgYGB7ciBzZXF1ZW50aWFsLCBldmFsPUZBTFNFfQ0KcHJpbnQoIkF1c3NpZSEiKQ0KcHJpbnQoIkF1c3NpZSEiKQ0KcHJpbnQoIkF1c3NpZSEiKQ0KYGBgDQpZb3UgYXJlIGV4ZWN1dGluZyB0aGUgaWRlbnRpY2FsIGxpbmUgb2YgY29kZSB0aHJlZSB0aW1lcy4gSGF2aW5nIHRvIHR5cGUgdGhlIHNhbWUgbGluZSBvZiBjb2RlIG1hbnkgdGltZXMgaXMgYm9yaW5nLCBhbmQgc2ltcGx5IG11bHRpcGxpZXMgdGhlIG51bWJlciBvZiBvcHBvcnR1bml0aWVzIGZvciB0eXBvcyBhbmQgYnVncyB0byBzbmVhayBpbi4gKEFuZCBpbiB0aGlzIHRveSBleGFtcGxlLCB3ZSBhcmUgb25seSByZXBlYXRpbmcgb25lIGxpbmUgb2YgY29kZSB0aHJlZSB0aW1lczsgaW4gYSByZWFsIGNvbXB1dGF0aW9uYWwgc2l0dWF0aW9uIHdlIG1pZ2h0IG5lZWQgdG8gcmVwZWF0cyBkb3plbnMgb2YgbGluZXMgb2YgY29kZSBodW5kcmVkcyBvZiB0aW1lcy4pIFVzaW5nIGEgZm9yLWxvb3AsIHdlIGNhbiBhY2hpZXZlIHRoZSBzYW1lIG91dHB1dCB3aGlsZSBvbmx5IHR5cGluZyB0aGUgY29tbWFuZCBvbmNlLg0KDQpgYGB7ciBiYXNpYyBsb29wfQ0KZm9yIChjaGVlciBpbiBjKDEsMiwzKSkNCnsNCiAgcHJpbnQoIkF1c3NpZSIpDQp9DQpgYGANCg0KTWF0Y2ggdGhlIHBhcnRzIG9mIHRoaXMgbG9vcCB0byB0aGUgc2NoZW1hdGljLCBub3RpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBrZXl3b3JkcyAqKmZvcioqIGFuZCAqKmluKiosIHRoZSBicmFja2V0cywgYW5kIHRoZSAqc29tZV9raW5kX29mX3NlcXVlbmNlKiBlbGVtZW50IHdoaWNoIGlzLCBpbiB0aGlzIGNhc2UsIHRoZSB2ZWN0b3IgY3JlYXRlZCBieSBgYygxLDIsMylgLiBTaW5jZSB0aGVyZSBhcmUgdGhyZWUgZWxlbWVudHMgaW4gdGhlIHZlY3RvciwgdGhlIGNvZGUgYm9keSBpcyBleGVjdXRlZCB0aHJlZSB0aW1lcy4gDQoNCiMjIFZlY3RvciBzZXF1ZW5jZXMNCg0KSWYgd2Ugd2FudGVkIHRvIHByaW50ICJBdXNzaWUhIiA1IHRpbWVzLCB3ZSBjb3VsZCBpbmNyZWFzZSB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IgdG8gNS4gSWYgd2Ugd2FudGVkIHRvIHByaW50IGl0IDEwMCB0aW1lcyAoY291bGQgaGFwcGVuKSB3ZSBjb3VsZCBpbmNyZWFzZSB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IgdG8gMTAwLCBidXQgdXNpbmcgZnVuY3Rpb24gYGMoKWAgZm9yIHRoaXMgaXMgdG9vIGN1bWJlcnNvbWUuIEluIFIsIHdlIGhhdmUgYW4gYWx0ZXJuYXRpdmUgZm9yIGdlbmVyYXRpbmcgYSBzZXF1ZW5jZSBvZiBudW1iZXJzIHVzaW5nIHRoZSBgOmAgb3BlcmF0b3IuDQoNCmBgYHtyIHNlcSB9DQpzbWFsbF9zZXEgPC0gMTo1DQpzbWFsbF9zZXENCg0KYmlnX3NlcSA8LSAxOjUwDQpiaWdfc2VxDQpgYGANCg0KVGhlcmUgYXJlIG1vcmUgcG93ZXJmdWwgZnVuY3Rpb25zIGZvciBnZW5lcmF0aW5nIHNlcXVlbmNlcyAoc2VlLCBmb3IgZXhhbXBsZSBgc2VxYCBhbmQgYHJlcGApIGJ1dCBmb3IgYmFzaWMgZm9yIGxvb3BzLCB0aGUgYDpgIG9wZXJhdG9yIGlzIHN1ZmZpY2llbnQuIFdlIGNhbiBleHRlbmQgb3VyIGNoZWVyLXByaW50aW5nIGZvci1sb29wOg0KDQpgYGB7ciBsb25nIGNoZWVyfQ0KZm9yIChjaGVlciBpbiAxOjE1KQ0Kew0KICBwcmludCgiQXVzc2llIikNCn0NCmBgYA0KDQojIFRoZSBMb29wIERyaXZlcg0KDQoNClJlY2FsbCB0aGUgc2NoZW1hdGljIGZvciBhbiBSIGZvciBsb29wOg0KDQpmb3IgKCp2YXJpYWJsZV9uYW1lKiBpbiAqc29tZV9raW5kX29mX3NlcXVlbmNlKikNCnsNCiAgKkNvZGUgdG8gYmUgcmVwZWF0ZWQuIENhbiBiZSBhcyBsb25nIGFzIHJlcXVpcmVkLioNCn0NCg0KVGhlICp2YXJpYWJsZV9uYW1lKiBlbGVtZW50IGNhbiBiZSBhbnkgbGVnYWwgUiB2YXJpYWJsZSBuYW1lLiBUaGlzIGVsZW1lbnQgaXMgY2FsbGVkIHRoZSAqKmxvb3AgZHJpdmVyKiouIEluc2lkZSB0aGUgY29kZSBib2R5IG9mIHRoZSBmb3ItbG9vcCB0aGUgbG9vcCBkcml2ZXIgdmFyaWFibGUgaXMgYWx3YXlzIGF2YWlsYWJsZS4gRm9yIGV4YW1wbGUsIGluIG91ciAiQXVzc2llISwgQXVzc2llISBBdXNzaWUhIiBleGFtcGxlLCBvdXIgbG9vcCBkcml2ZXIgd2FzIGNhbGxlZCAqY2hlZXIqLiBJbiBvdXIgY29kZSBib2R5IHdlIGNvdWxkIGhhdmUgcmVmZXJyZWQgdG8gdmFyaWFibGUgYGNoZWVyYC4gDQoNCkFzIGRpc2N1c3NlZCBhYm92ZSwgdGhlIGZvciBsb29wIGNvZGUgYm9keSBpcyBleGVjdXRlZCBhcyBtYW55IHRpbWVzIGFzIHRoZXJlIGFyZSBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UgaW4gdGhlIGhlYWRlci4gQXQgZWFjaCBwYXNzIHRocm91Z2ggdGhlIGxvb3AsIHRoZSBsb29wIGRyaXZlciBhdXRvbWF0aWNhbGx5IHRha2VzIG9uICoqdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgdGhlIHNlcXVlbmNlKiouIFRoYXQgaXMsIGluIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBsb29wLCB0aGUgbG9vcCBkcml2ZXIgdmFyaWFibGUgaXMgYXNzaWduZWQgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBzZXF1ZW5jZTsgaW4gdGhlIHNlY29uZCBwYXNzIG9mIHRoZSBsb29wLCB0aGUgbG9vcCBkcml2ZXIgdmFyaWFibGUgaXMgYXNzaWduZWQgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgc2VxdWVuY2UsIGFuZCBzbyBvbi4NCg0KV2UgaWxsdXN0cmF0ZSB0aGlzIGJ5IGV4dGVuZGluZyBvdXIgcHJldmlvdXMgZXhhbXBsZSB0byBwcmludCB0aGUgdmFsdWUgb2YgbG9vcCBkcml2ZXIgYGNoZWVyYCBpbnNpZGUgdGhlIGNvZGUgYm9keToNCg0KYGBge3IgbG9uZyBjaGVlciAyfQ0KZm9yIChjaGVlciBpbiAxOjMpDQp7DQogIHByaW50KCJBdXNzaWUiKQ0KICBwcmludChjaGVlcikNCn0NCmBgYA0KDQpOb3RlIHRoYXQgeW91ICoqbmV2ZXIgYXNzaWduKiogYSB2YWx1ZSB0byB0aGUgbG9vcCBkcml2ZXIgLS0gaXQgdGFrZXMgb24gaXRzIHZhbHVlcyBhdXRvbWF0aWNhbGx5IGFzIHRoZSBmb3IgbG9vcCBydW5zLg0KDQpJbiBhbGwgb3VyIGV4YW1wbGVzIHNvIGZhciwgdGhlIHNlcXVlbmNlIGluIHRoZSBmb3ItbG9vcCBoZWFkZXIgaGFzIGJlZW4gbnVtYmVycyBmcm9tIDEgdG8gKm4qLiBJbiBSLCB0aGUgc2VxdWVuY2UgY2FuIGJlIGEgdmVjdG9yIG9mIGFueSB0eXBlLCBhbmQgdGhlIGxvb3AgZHJpdmVyIHdpbGwgdGFrZSBvbiB3aGF0ZXZlciB2YWx1ZXMgdGhlIHNlcXVlbmNlIGNvbnRhaW5zLiBGb3IgZXhhbXBsZSwgd2UgY2FuIGRyaXZlIGEgZm9yIGxvb3Agd2l0aCBhIHZlY3RvciBvZiBzdHJpbmc6DQoNCmBgYHtyIHNlcSBvZiBzdHJpbmd9DQpzcG9ydHMgPC0gYygiUnVnYnkiLCAiQ3ljbGluZyIsICJJY2UgU2thdGluZyIpDQpmb3IgKGN1cnJlbnRfc3BvcnQgaW4gc3BvcnRzKQ0Kew0KICAjIFByaW50IHRoZSBzcG9ydCBuYW1lDQogIHByaW50KGN1cnJlbnRfc3BvcnQpDQogIA0KICAjIENvbXB1dGUgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzcG9ydCBuYW1lDQogIHByaW50KG5jaGFyKGN1cnJlbnRfc3BvcnQpKQ0KfQ0KICANCmBgYA0KDQojIyBMb29wIGRyaXZlciBhcyBpbmRleA0KDQpUaHJvdWdob3V0IHRoZSBjb3Vyc2Ugd2UgaGF2ZSBzZWVuIHRoYXQgUiByZWxpZXMgaGVhdmlseSBvbiBtYW5hZ2luZyBkYXRhIGluIG9yZGVyZWQgY29sbGVjdGlvbnMgKHZlY3RvcnMsIGxpc3RzLCBhbmQgZGF0YSBmcmFtZXMpLiBXZSBzZWxlY3QgZWxlbWVudHMgZnJvbSB0aG9zZSBjb2xsZWN0aW9ucyB1c2luZyBbXSwgcHJvdmlkaW5nIHRoZSBvcmRpbmFsIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IG9mIGludGVyZXN0LiBTaW5jZSBsb29wIGRyaXZlciB2YXJpYWJsZXMgdGFrZSBvbiBlYWNoIHZhbHVlIGluIHRoZWlyIHNlcXVlbmNlLCB3ZSBjYW4gdXNlIGEgZm9yIGxvb3AgdG8gc3RlcCB0aHJvdWdoIGVhY2ggZWxlbWVudCBvZiBhIGNvbGxlY3Rpb24gaW4gdHVybi4NCg0KRm9yIGV4YW1wbGUsIGFzc3VtZSBhIGRhdGEgZnJhbWUgY29udGFpbmluZyBhIHN0dWRlbnQncyBpbnRlcm5hbCBhbmQgZXhhbSBtYXJrcyBmb3IgdGhlIHBhcGVycyB0YWtlbiBpbiBvbmUgc2VtZXN0ZXI6IA0KDQpgYGB7ciBtYWtlIGRhdGEgZnJhbWV9DQoNCnBhcGVyX2NvZGVzIDwtIGMoIkhVQlMxOTIiLCAiRUNPTDIxMiIsICJTVEFUMjYwIikNCmludGVybmFsX21hcmtzIDwtIGMoODcsIDg1LCA2MikNCmV4YW1fbWFya3MgPC0gYyg5MywgODQsIDg1KQ0KDQptYXJrc19kZiA8LSBkYXRhLmZyYW1lKFBhcGVyQ29kZSA9IHBhcGVyX2NvZGVzLA0KICAgICAgICAgICAgICAgICAgICAgICBJbnRlcm5hbE1hcmsgPSBpbnRlcm5hbF9tYXJrcywNCiAgICAgICAgICAgICAgICAgICAgICAgRXhhbU1hcmtzID0gZXhhbV9tYXJrcykNCg0KYGBgDQoNCldlIGtub3cgdGhhdCB3ZSBjYW4gc2VsZWN0IGFsbCBjb2x1bW5zIGZyb20gYSBzaW5nbGUgcm93IGluIHRoYXQgZGF0YSBmcmFtZSB1c2luZyB0aGUgc3ludGF4IFsqcm93IG51bWJlciosIF0NCg0KYGBge3Igc2VsZWN0IHJvd30NCiMgU2VsZWN0IGFuZCBwcmludCByb3cgMg0KDQpzZWxlY3RlZF9yb3cgPC0gbWFya3NfZGZbMiwgXQ0KcHJpbnQoc2VsZWN0ZWRfcm93KQ0KDQpgYGANCldpdGggYSBmb3IgbG9vcCB3ZSBjYW4gdXNlIHRoZSBsb29wIGRyaXZlciB0byBpdGVyYXRlIG92ZXIgYWxsIHRoZSByb3dzLCBwcm9jZXNzaW5nIGVhY2ggaW4gdHVybjoNCg0KDQpgYGB7ciBzaW1wbGUgZHJpdmVyIGFzIGluZGV4fQ0KZm9yIChpbmRleCBpbiAxOjMpDQp7DQogICMgVXNlIHRoZSBsb29wIGRyaXZlciB0byBpbmRleCBpbnRvIHRoZSBkYXRhIGZyYW1lDQogIHNlbGVjdGVkX3JvdyA8LSBtYXJrc19kZltpbmRleCwgXQ0KICBwcmludChzZWxlY3RlZF9yb3cpDQp9DQoNCmBgYA0KDQpOb3RlIHRoYXQgaWYgd2UgbWFkZSBvdXIgZGF0YSBmcmFtZSBsb25nZXIgdGhhbiB0aHJlZSByb3dzIGJ5IGFkZGluZyBtb3JlIHBhcGVycyB0byBpdCwgdGhlIHByZWNlZGluZyBmb3IgbG9vcCAqKndvdWxkIG5vdCoqIHByaW50IGFsbCB0aGUgcm93czsgdGhlIHNlcXVlbmNlIGluIHRoYXQgZXhtYXBsZSBpcyBhbHdheXMgYDEsIDIsIDNgIHNvIHdlIHNlZSBvbmx5IHJvd3MgMSwgMiwgYW5kIDMuIFdlIGNhbiBtYWtlIHRoZSBsb29wIG1vcmUgZ2VuZXJhbCBieSBkZXRlcm1pbmluZyB0aGUgZm9yLWxvb3Agc2VxdWVuY2UgKipkeW5hbWljYWxseSoqIHVzaW5nIGZ1bmN0aW9uIGBucm93c2AsIHdoaWNoIGFjY2VwdHMgYSBkYXRhIGZyYW1lIGFzIGFuIGFyZ3VtZW50LCBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgZnJhbWU6DQoNCmBgYHtyIHVzaW5nIG5yb3d9DQoNCiMgRGlzcGxheSBhbGwgcm93cw0KZm9yIChpbmRleCBpbiAxOm5yb3cobWFya3NfZGYpKQ0Kew0KICAjIFVzZSB0aGUgbG9vcCBkcml2ZXIgdG8gaW5kZXggaW50byB0aGUgZGF0YSBmcmFtZQ0KICBzZWxlY3RlZF9yb3cgPC0gbWFya3NfZGZbaW5kZXgsIF0NCiAgcHJpbnQoc2VsZWN0ZWRfcm93KQ0KfQ0KDQojIEFkZCBhIHJvdyB0byB0aGUgZGF0YSBmcmFtZQ0KbWFya3NfZGYgPC0gcmJpbmQobWFya3NfZGYsIGMoIlpPT0wzMTYiLCA4MywgOTApKQ0KDQoNCiMgUmVwZWF0IHRoZSBsb29wIC0tIHNlZSBmb3VyIHJvd3MNCmZvciAoaW5kZXggaW4gMTpucm93KG1hcmtzX2RmKSkNCnsNCiAgIyBVc2UgdGhlIGxvb3AgZHJpdmVyIHRvIGluZGV4IGludG8gdGhlIGRhdGEgZnJhbWUNCiAgc2VsZWN0ZWRfcm93IDwtIG1hcmtzX2RmW2luZGV4LCBdDQogIHByaW50KHNlbGVjdGVkX3JvdykNCn0NCmBgYA0KDQoNCg0KDQoNCiMjIyBOZXN0aW5nIG9mIGxvb3BzDQoNCkl0J3MgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIGF2b2lkIHRoZSBuZXN0aW5nIG9mIGxvb3BzIHdpdGhpbiBvdGhlciBsb29wcy4gTGV0J3Mgc2F5IHRoZSBvdXRlciBsb29wIGhhcyBhIHRvdGFsIG9mIGBuYCBpdGVyYXRpb25zIHRvIGdldCB0aHJvdWdoIGFuZCBhbiBpbm5lciBsb29wIGhhcyBgbWAuIEV2ZXJ5IHRpbWUgd2UgYWRkIG9uZSBleHRyYSBpdGVyYXRpb24gb2YgdGhlIG91dGVyIGxvb3Agd2UgZW5kIHVwIGFkZGluZyBhbiBleHRyYSBgbWAgaXRlcmF0aW9ucyBvZiB0aGUgaW5uZXIgbG9vcCwgc28gdGhlIHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGlzIGBuICogbWAuIERlcGVuZGluZyBvbiBob3cgYmlnIGBtYCBpcywgdGhpcyBjb3VsZCBiZSBhZGRpbmcgdGhvdXNhbmRzIG9yIG1pbGxpb25zIG9mIGV4dHJhIGl0ZXJhdGlvbnMsIGNhdXNpbmcgeW91ciBjb2RlIHRvIHRha2UgbG9uZ2VyIHRvIHJ1bi4gU29tZSB0aW1lcyBob3dldmVyLCBuZXN0aW5nIGlzIHVuYXZvaWRhYmxlIGJ1dCBpdCdzIGEgZ29vZCBpZGVhIHRvIGtlZXAgYW4gZXllIG91dCBmb3IgbmVzdGluZyBpZiB5b3VyIGNvZGUgaXMgdGFraW5nIGEgd2hpbGUgdG8gcnVuIGFzIHRoaXMgaXMgdXN1YWxseSB0aGUgZmlyc3QgcGxhY2UgdGhpbmdzIGNhbiBiZSBzcGVkIHVwLg0KDQojIyBXaGlsZSBsb29wDQoNClRoZSB3aGlsZSBsb29wIGlzIGEgdXNlZnVsIGxvb3AgdG8gdXNlIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgdmVjdG9yIGlzIHVua25vd24uIFRoZSBzaXR1YXRpb24gd2hlcmUgdGhpcyBhcmlzZXMgb2Z0ZW4gd291bGQgYmUgaW4gc2ltdWxhdGlvbnMgd2hlcmUgeW91IHdhbnQgdG8gZmluZCBvdXQgaG93IG1hbnkgdGltZXMgc29tZXRoaW5nIGhhcHBlbmVkIHVudGlsIHlvdSBnb3QgYSBjZXJ0YWluIHJlc3VsdCAtLSBhbiBleGl0IGNvbmRpdGlvbi4NCg0KVGhlIHNrZWxldG9uIGZvciBhIGB3aGlsZWAgbG9vcCBpcyBhcyBmb2xsb3dzOg0KDQpgYGB7ciwgZXZhbCA9IEZBTFNFfQ0Kd2hpbGUgKGNvbmRpdGlvbikgew0KICAjIGxvb3AgYm9keQ0KfQ0KYGBgDQoNCkhlcmUgaXMgYW4gZXhhbXBsZSBvZiBhIGB3aGlsZWAgbG9vcCB3aGVyZSB3ZSB3YW50IHRvIGZpbmQgb3V0IGhvdyBtYW55IGl0ZXJhdGlvbnMgaXQgdGFrZXMgdG8gb2J0YWluIDMgaGVhZHMgaW4gYSByb3c6DQoNCmBgYHtyLCBlY2hvID0gVFJVRSwgZXZhbCA9IFRSVUV9DQojIyBFeGFtcGxlIGZyb20gUiBmb3IgRGF0YSBTY2llbmNlIC0gMjEuMy40ICMjDQoNCiMgRnVuY3Rpb24gdG8gc2ltdWxhdGUgaGVhZCBvciB0YWlsIGFzIHRoZSByZXN1bHQgb2YgYSBjb2luIGZsaXANCmZsaXAgPC0gZnVuY3Rpb24oKXsNCiAgc2FtcGxlKGMoIlQiLCAiSCIpLCAxKQ0KfQ0KDQojIHZhcmlhYmxlcyB0byBrZWVwIHRyYWNrIG9mIGtleSByZXN1bHRzDQpmbGlwcyA8LSAwDQpuaGVhZHMgPC0gMA0KDQojIGZsaXAgYSBjb2luIHVudGlsIHRoZXJlIGFyZSB0aHJlZSBoZWFkcyBhbmQgY291bnQgaG93IG1hbnkgZmxpcHMgd2VyZSBwZXJmb3JtZWQuDQp3aGlsZSAobmhlYWRzIDwgMykgew0KICBpZiAoZmxpcCgpID09ICJIIikgew0KICAgIG5oZWFkcyA8LSBuaGVhZHMgKyAxDQogIH0gZWxzZSB7DQogICAgbmhlYWRzIDwtIDANCiAgfQ0KICBmbGlwcyA8LSBmbGlwcyArIDENCn0NCmZsaXBzDQoNCmBgYA0KDQpJdCdzIHZlcnkgaW1wb3J0YW50IHRvICoqYWx3YXlzIG1ha2Ugc3VyZSB5b3VyIGNvbmRpdGlvbiB3aWxsIGV2ZW50dWFsbHkgYmUgRkFMU0UgYmVmb3JlIHJ1bm5pbmchKiogT3RoZXJ3aXNlIHlvdSdsbCBiZSBzdHVjayBpbiBhbiAnaW5maW5pdGUgbG9vcCcgd2hlcmUgeW91ciBjb2RlIGtlZXBzIHJ1bm5pbmcgYW5kIG5ldmVyIHN0b3BwaW5nLiBJZiB5b3UgZmluZCB5b3Vyc2VsZiBpbiB0aGlzIHNpdHVhdGlvbiBpbiBSU3R1ZGlvLCBpbiB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBjb25zb2xlIHdpbmRvdyB5b3UgY2FuIGNsaWNrIHRoZSAnc3RvcCcgc2lnbiwgb3IgdW5kZXIgdGhlIGBTZXNzaW9uYCBtZW51IGNsaWNrICJJbnRlcnJ1cHQgUiIgdG8gbWFrZSBpdCBzdG9wLg0KDQoNCg0KIyBNYXANCg0KRnJvbSB0aGUgcGFja2FnZSBgcHVycnJgIChwYXJ0IG9mIHRoZSB0aWR5dmVyc2UpLCB0aGVyZSBhcmUgYSBjb2xsZWN0aW9uIG9mIGBtYXBgIGZ1bmN0aW9ucyB3aGljaCBhcmUgYSBtZXRob2Qgb2YgaXRlcmF0aW5nIG92ZXIgYSBjb2xsZWN0aW9uIG9mIHRoaW5ncyBhcHBseWluZyBhIGZ1bmN0aW9uLiBUaGlzIGlzIGtub3duIGFzIF9mdW5jdGlvbmFsIHByb2dyYW1taW5nXywgYW5kIGFsbG93cyB1cyB0byBleHRyYWN0IHRoZSBjb2RlIHRoYXQgaXMgaW4gY29tbW9uIGZvciBhIGxvb3AsIGludG8gYSBmdW5jdGlvbiwgc28gcmF0aGVyIHRoYW4gYmVpbmcgY29uY2VybmVkIGFib3V0IHRoZSBzZXQtdXAgb2YgdGhlIGxvb3AsIHdlIGNhbiBmb2N1cyBvbiB0aGUgY29udGVudHMgb2YgdGhlIGxvb3AuIFRoaXMgaWRlYSBvZiBtYXBwaW5nIGEgZnVuY3Rpb24gb250byBkYXRhIGlzIGV4dHJlbWVseSBzaW1pbGFyIHRvIHRoZSBjb25jZXB0IHVuZGVybHlpbmcgdGhlIGBmb3JgIGxvb3AuDQoNCiMjIE1hcCBhbmQgZnJpZW5kcw0KDQpUaGUgcGFja2FnZSBgcHVycnJgIHdpdGhpbiB0aGUgdGlkeXZlcnNlIHByb3ZpZGVzIHRoZSBgbWFwYCBmdW5jdGlvbnMgdGhhdCB0YWtlIGEgdmVjdG9yIG9yIGxpc3QgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdG8gYmUgcnVuIG9uIGVhY2ggaXRlbSBpbiB0aGUgdmVjdG9yIG9yIGxpc3QuIFRoZSBvYmplY3QgdGhhdCBpcyByZXR1cm5lZCBiYWNrIHdpdGggdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgZXhhY3QgdmVyc2lvbiBvZiBgbWFwYCB0aGF0IGlzIGNhbGxlZCwgdGhlIGRlZmF1bHQgYG1hcCgpYCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGl0ZW1zIGluIGEgbGlzdCwgYnV0IHRoZXJlIGFyZSBzdWZmaXggdmVyc2lvbnMgb2YgYG1hcGAgdGhhdCB3aWxsIHJldHVybiB0aGUgcmVzdWx0cyBiYWNrIGluIGEgc3BlY2lmaWVkIGRhdGEgdHlwZS4NCg0KLSBgbWFwKClgIG1ha2VzIGEgbGlzdC4NCi0gYG1hcF9sZ2woKWAgbWFrZXMgYSBsb2dpY2FsIHZlY3Rvci4NCi0gYG1hcF9pbnQoKWAgbWFrZXMgYW4gaW50ZWdlciB2ZWN0b3IuDQotIGBtYXBfZGJsKClgIG1ha2VzIGEgZG91YmxlIHZlY3Rvci4NCi0gYG1hcF9jaHIoKWAgbWFrZXMgYSBjaGFyYWN0ZXIgdmVjdG9yLg0KDQpUaGVzZSBzdWZmaXggdmVyc2lvbnMgd2lsbCBnaXZlIGFuIGVycm9yIGlmIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHJlc3VsdHMgZG9lc24ndCBtYXRjaC4gVGhpcyBpcyB1c2VmdWwgZm9yIGJlaW5nIGFibGUgdG8gcHJvZ3JhbSB3aXRoLCBhcyBpdCBtZWFucyB0aGF0IHlvdSBjYW4gYmUgc3VyZSB0aGF0IHlvdSBoYXZlIGEgcGFydGljdWxhciBkYXRhIHR5cGUgZm9yIGZ1dHVyZSBjb2RlLiBTb21lIG9mIHRoZSBiYXNlIFIgZnVuY3Rpb25zIHRoYXQgeW91IHdpbGwgbWVldCBpbiB0aGUgbmV4dCBzZWN0aW9uIGRvbid0IHByb3ZpZGUgdGhpcyBndWFyYW50ZWUuIFRoZSBhcmd1bWVudHMgdG8gdGhlIGBtYXBgIGZ1bmN0aW9ucyBhcmUgYC54YCB3aGljaCBpcyB0aGUgdmVjdG9yIG9yIGxpc3QgaW5wdXQsIGFuZCBgLmZgIHdoaWNoIGlzIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi4gaWYgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHRha2VzIG11bHRpcGxlIGFyZ3VtZW50cyB0aGVzZSBjYW4gYmUgcGFzc2VkIGluIGFzIGV4dHJhIGFyZ3VtZW50cyB0byBgbWFwYC4NCg0KV2UgY291bGQgdXNlIHRoZSBleGFtcGxlIG9mIGNvbnZlcnRpbmcgc29tZSB0ZW1wZXJhdHVyZXMgdG8gZGVtb25zdHJhdGUNCmBgYHtyfQ0KbGlicmFyeShwdXJycikNCg0KZmFyZW5oZWl0X3RvX2NlbGNpdXMgPC0gZnVuY3Rpb24odGVtcF9mKXsNCiAgdGVtcF9jIDwtICh0ZW1wX2YgLTMyKSAqIDUvOQ0KICByZXR1cm4odGVtcF9jKQ0KfQ0KDQpteV90ZW1wc19mIDwtIGMoOTAsIDc4LCA4OCwgODksIDc3KQ0KDQojIGdpdmVzIGJhY2sgYSBsaXN0DQpteV90ZW1wc19jX2xpc3QgPC0gbWFwKC54ID0gbXlfdGVtcHNfZiwgLmYgPSBmYXJlbmhlaXRfdG9fY2VsY2l1cykNCm15X3RlbXBzX2NfbGlzdA0KDQojIGdpdmVzIGJhY2sgYSB2ZWN0b3Igb2YgdHlwZSBudW1lcmljL2RvdWJsZQ0KbXlfdGVtcHNfY19kYmwgPC0gbWFwX2RibCgueCA9IG15X3RlbXBzX2YsIC5mID0gZmFyZW5oZWl0X3RvX2NlbGNpdXMpDQpteV90ZW1wc19jX2RibA0KYGBgDQoNCldoZW4gdXNpbmcgYG1hcGAgYW5kIHZhcmlhbnRzLCBkb24ndCBpbmNsdWRlIHRoZSBgKClgJ3Mgb24gdGhlIGZ1bmN0aW9uIG5hbWUsIGlmIHlvdSBkbyB5b3UnbGwgZ2V0IHRoaXMgZXJyb3I6DQpgYGB7ciwgZXJyb3IgPSBUUlVFfQ0KbWFwKC54ID0gbXlfdGVtcHNfZiwgLmYgPSBmYXJlbmhlaXRfdG9fY2VsY2l1cygpKQ0KYGBgDQoNCg0KIyBBcHBseQ0KDQpCYXNlIFIgaGFzIGJ1aWx0IGluIGZ1bmN0aW9ucyBmb3IgYXBwbHlpbmcgYSBmdW5jdGlvbiB0byBhIHZlY3RvciwgbGlzdCBvciBkYXRhIGZyYW1lLiBUaGVyZSBpcyBgYXBwbHlgIHdoaWNoIHdpbGwgYXBwbHkgYSBmdW5jdGlvbiB0byBlaXRoZXIgY29sdW1ucyBvciByb3dzIG9mIGEgZGF0YSBmcmFtZSwgYGxhcHBseWAgZm9yIGFwcGx5aW5nIHRvIGEgbGlzdCBvciB2ZWN0b3IgLSBpdCdzIGFuYWxvZ291cyB0byBgbWFwKClgLCBhbmQgYHZhcHBseWAgd2hpY2ggY2FuIHRha2VzIHRoZSByZXR1cm4gZGF0YSB0eXBlIGFzIG9uZSBvZiB0aGUgYXJndW1lbnRzIHNvIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGFuYWxvZ291cyB0byB0aGUgc3VmZml4IHZlcnNpb25zIG9mIGBtYXBgLiBUaGUgYGFwcGx5KClgIGZ1bmN0aW9uIGlzIHZlcnkgc2ltaWxhciB0byBgbWFwKClgDQoNCg0KVGhlIGVxdWl2YWxlbnQgZXhhbXBsZSBvZiB3aGF0IHdlIGRpZCBhYm92ZSB3aXRoIGBtYXAoKWAgYGFuZCBtYXBfZGJsKClgIGlzIGFzIGZvbGxvd3M6DQoNCmBgYHtyfQ0KZmFyZW5oZWl0X3RvX2NlbGNpdXMgPC0gZnVuY3Rpb24odGVtcF9mKXsNCiAgdGVtcF9jIDwtICh0ZW1wX2YgLTMyKSAqIDUvOQ0KICByZXR1cm4odGVtcF9jKQ0KfQ0KDQpteV90ZW1wc19mIDwtIGMoOTAsIDc4LCA4OCwgODksIDc3KQ0KDQojIGxhcHBseSBleGFtcGxlDQpsYXBwbHlfbXlfdGVtcHNfYyA8LSBsYXBwbHkoWCA9IG15X3RlbXBzX2YsIEZVTiA9IGZhcmVuaGVpdF90b19jZWxjaXVzKQ0KbGFwcGx5X215X3RlbXBzX2MNCg0KIyB2YXBwbHkgZXhhbXBsZS4gRlVOLlZBTFVFIGRlZmluZXMgdGhlIHR5cGUgYW5kIGxlbmd0aCBzaXplIG9mIGVhY2ggb2YgdGhlIHJldHVybmVkIHJlc3VsdHMuIA0KdmFwcGx5X215X3RlbXBzX2MgPC0gdmFwcGx5KFggPSBteV90ZW1wc19mLCBGVU4gPSBmYXJlbmhlaXRfdG9fY2VsY2l1cywgRlVOLlZBTFVFID0gbnVtZXJpYygxKSkNCnZhcHBseV9teV90ZW1wc19jDQpgYGANCg0KV2UgY2FuIHNlZSB0aGF0IHRoZXJlIGlzIGEgZGlmZmVyZW5jZSBpbiB0aGUgcmVzdWx0cyB0aGF0IFIgcmV0dXJucyBiZXR3ZWVuIGBsYXBwbHlgIGFuZCBgdmFwcGx5YCBieSB1c2luZyBgc3RyYCB0byBsb29rIGF0IHRoZSBzdHJ1Y3R1cmUuDQoNCmBgYHtyfQ0Kc3RyKGxhcHBseV9teV90ZW1wc19jKQ0Kc3RyKHZhcHBseV9teV90ZW1wc19jKQ0KYGBgDQoNCmBsYXBwbHlfbXlfdGVtcHNfY2AgaXMgYSBfbGlzdF8gd2l0aCBlYWNoIGl0ZW0gYmVpbmcgYSBudW1lcmljIHZlY3Rvciwgd2hlcmVhcyBgc2FwcGx5X215X3RlbXBzX2NgIGlzIHNpbmdsZSBhIF9udW1lcmljXyB2ZWN0b3Igb2YgKHRoZSBkYXRhIHR5cGUgdGhhdCB3ZSBzcGVjaWZpZWQpLiBXaGVuIHdlIHNwZWNpZmllZCB0aGUgZGF0YSB0eXBlIGZvciBgdmFwcGx5YCB3ZSB1c2VkIGBudW1lcmljKDEpYCBhcyBhbiBhcmd1bWVudC4gV2hhdCB0aGlzIG1lYW50IHdhcyB0aGF0IGVhY2ggdGltZSBvdXIgZnVuY3Rpb24gc3BlY2lmaWVkIGZvciBgRlVOID0gYCBpcyBydW4sIGl0IHdhcyBleHBlY3RlZCB0byByZXR1cm4gYSB2ZWN0b3Igb2YgbGVuZ3RoIDEgb2YgdHlwZSBudW1lcmljLiBJZiB0aGlzIHdhc24ndCB0aGUgY2FzZSwgYW4gZXJyb3Igd291bGQgb2NjdXIuIE9uZSB0aGluZyB0byBiZSBhd2FyZSBvZiBpcyB0aGF0IGB2YXBwbHlgIGRvZXNuJ3QgYWx3YXlzIHJldHVybiBhIHZlY3RvciwgdGhlIGRhdGEgc3RydWN0dXJlIHRoYXQgaXQgcmV0dXJucyBkZXBlbmRzIG9uIHRoZSBkYXRhIGdvaW5nIGluLiBUaGlzIGNhbiBtYWtlIGl0IGNoYWxsZW5naW5nIHRvIGtub3cgYmVmb3JlaGFuZCB3aGF0IHRoZSBvdXRwdXQgaXMgZ29pbmcgdG8gbG9vayBsaWtlIC0gdW5saWtlIHRoZSBzdWZmaXggdmVyc2lvbnMgb2YgYG1hcGAgZnJvbSBgcHVycnJgLg0KDQoNCg0KIyBDb25jbHVzaW9uDQoNCkluIHRoaXMgbW9kdWxlIHdlIGNvdmVyZWQgaG93IHJlcGVhdCB0YXNrcyBlZmZpY2llbnRseS4gQ29tYmluaW5nIGl0ZXJhdGlvbiB3aXRoIHBhcnQgMSAtIGZ1bmN0aW9ucyBhbmQgZmxvdyBhbmQgY29udHJvbCAtIHlvdSBub3cgaGF2ZSB0aGUga25vd2xlZGdlIHRvIGJlIGFibGUgdG8gY3JlYXRlIGNvZGUgdGhhdCBpcyBtb2R1bGFyIGFuZCByZXVzYWJsZSwgYW5kIG1haW50YWluYWJsZS4gVGhpcyB3aWxsIGVuYWJsZSB5b3UgdG8gYmUgbW9yZSBlZmZpY2llbnQgZ29pbmcgZm9yd2FyZCB3aXRoIHlvdXIgcHJvZ3JhbW1pbmcgYW5kIGFuYWx5c2lzLg0KDQoNCiMjIFdoYXQncyBOZXh0DQoNCkNvbmdyYXR1bGF0aW9ucyBvbiBmaW5pc2hpbmcgdGhlIGNvdXJzZSEgVGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgdGhlIGVuZCBvZiB5b3VyIGxlYXJuaW5nIGpvdXJuZXkgd2l0aCBSIHRob3VnaC4gVGhlcmUgYXJlIG1hbnkgZnJlZSBvbmxpbmUgcmVzb3VyY2VzIHRvIGRlbHZlIGZ1cnRoZXIgaW4uIElmIHlvdSBoYXZlbid0IGFscmVhZHksIGEgZ29vZCBwbGFjZSB0byBzdGFydCBpcyB0aGUgY2hhcHRlcnMgb2YgW1IgZm9yIERhdGEgU2NpZW5jZV0oaHR0cHM6Ly9yNGRzLmhhZC5jby5ueikgdGhhdCB3ZXJlbid0IGNvdmVyZWQgaW4gdGhlIGNvdXJzZS4gQW5kIGlmIHlvdSB3YW50IHRvIGdldCBtb3JlIGluLWRlcHRoIHdpdGggdGhlIFIgbGFuZ3VhZ2UgdGhlIG9ubGluZSBib29rIFtBZHZhbmNlZCBSXShodHRwczovL2Fkdi1yLmhhZGxleS5ueikgY292ZXJzIG1vcmUgb2YgdGhlIFIgbGFuZ3VhZ2UgYW5kIHByb2dyYW1taW5nLg0KDQpQbGVhc2UgZmlsbCBpbiB0aGUgbW9kdWxlIGZlZWRiYWNrIGZvcm0gW2h0dHBzOi8vdGlueXVybC5jb20vcjRzc3AtbW9kdWxlLWZiXShodHRwczovL3Rpbnl1cmwuY29tL3I0c3NwLW1vZHVsZS1mYikuDQoNCiANCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("08-iterate.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Repeating Code</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R4SSP Semester 1 2022</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Intro</li>
    <li>
      <a href="01-intro.html">Intro to R and RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Focus</li>
    <li>
      <a href="02-visualise.html">Part 1: Visualising</a>
    </li>
    <li>
      <a href="03-subset.html">Part 2: Subsetting</a>
    </li>
    <li>
      <a href="04-summarise.html">Part 3: Summarising</a>
    </li>
    <li>
      <a href="05-transform.html">Part 4: Transforming</a>
    </li>
    <li>
      <a href="06-communicate.html">Part 5: Communicating</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Programming focus</li>
    <li>
      <a href="07-functions.html">Functions and Choices</a>
    </li>
    <li class="dropdown-header">Repeating Code</li>
    <li class="dropdown-header">Workflows</li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Zoom Notes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="zoom_notes_01.html">01 - Introducing R and RStudio</a>
    </li>
    <li>
      <a href="zoom_notes_02.html">02 - Visualising data</a>
    </li>
    <li>
      <a href="zoom_notes_03.html">03 - Subsetting data</a>
    </li>
    <li>
      <a href="zoom_notes_04.html">04 - Summarising data</a>
    </li>
    <li>
      <a href="zoom_notes_05.html">05 - Transforming data</a>
    </li>
    <li>
      <a href="zoom_notes_06.html">06 - Communicating data</a>
    </li>
    <li>
      <a href="zoom_notes_07.html">07 - Functions and Choices</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Repeating Code</h1>
<h4 class="date">Semester 1, 2022</h4>

</div>


<blockquote>
<h4 id="associated-material">Associated Material</h4>
<p>Zoom Notes: <a href="zoom_notes_08.html">Zoom Notes 08 - Repeating Code</a></p>
<p>Readings:</p>
<ul>
<li><a href="https://r4ds.had.co.nz/iteration.html">R for Data Science - Chapter 21</a></li>
</ul>
</blockquote>
<p><br />
</p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>In the previous module we learned to make our code more <strong>modular</strong> by organising it into functions, each of which encapsulates some logically distinct task. By repeatedly calling a function, we can execute the same code many times, while only having to type it out once. This is <strong>code reuse</strong> and is an important goal in efficient software development.</p>
<p>We can also achieve code reuse through <strong>iteration</strong>. Iterative constructs (more casually called <strong>loops</strong>) allow us to write a code block once, then instruct R to execute it a specified number of times. The number of iterations can be made to vary depending on the <strong>state</strong>. (Recall that <strong>state</strong> is the set of values of all the variables in the environment when a command is executed.) For example, we can write a loop that iterates as many times as there are rows in a data frame that we read from a file before the loop starts.</p>
<p>In R, as in most modern programming languages, there are different types of loops, with subtle differences in behaviour. We begin with the most general kind of loop – the <strong>for loop</strong>.</p>
</div>
<div id="syntax" class="section level1">
<h1>Syntax</h1>
<p>In R a <strong>for loop</strong> has the following structure:</p>
<div class="line-block"><strong>for</strong> (<em>variable_name</em> <strong>in</strong> <em>some_kind_of_sequence</em>)<br />
{<br />
    <em>Code block to be repeated. Can be as long as required.</em><br />
}</div>
<p><br />
</p>
<p>The keywords <strong>for</strong> and <strong>in</strong> are required, as are the round brackets in the <strong>loop header</strong>, and the curly brackets that delineate the code body.</p>
<p>The <em>some_kind_of sequence</em> is usually a vector. The code body is executed as many times as there are elements in the vector.</p>
<p>We will discuss the role of the <em>variable_name</em> element later in the module.</p>
<p>(It is also syntactically acceptable to place the opening curly bracket on the same line as the for loop header, after the closing round bracket, separated by a space.)</p>
</div>
<div id="basic-for-loop" class="section level1">
<h1>Basic for loop</h1>
<p>A popular cheer in Australian sports is “Aussie!, Aussie!, Aussie!”. Assume that (for some inexplicable reason) you wished to print this cheer. That is, you want to print “Aussie!” to the console three times. Using only sequential code you would write:</p>
<pre class="r"><code>print(&quot;Aussie!&quot;)
print(&quot;Aussie!&quot;)
print(&quot;Aussie!&quot;)</code></pre>
<p>You are executing the identical line of code three times. Having to type the same line of code multiple times is boring, and increases the number of opportunities for typos and bugs to sneak in. (In this toy example, we are only repeating one line of code three times; in a real computational situation we might need to repeat dozens of lines of code hundreds of times.) Using a <strong>for loop</strong>, we can achieve the same output while only typing the command once.</p>
<pre class="r"><code>for (cheer in c(1,2,3))
{
  print(&quot;Aussie&quot;)
}
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;</code></pre>
<p>Match the parts of this loop to the schematic, noting the position of the keywords <strong>for</strong> and <strong>in</strong>, the round brackets, and the curly brackets. Note the <em>some_kind_of_sequence</em> element which, in this case, is the vector created by <code>c(1,2,3)</code>. Since there are three elements in the vector, the code body is executed three times.</p>
<div id="vector-sequences" class="section level2">
<h2>Vector sequences</h2>
<p>If we wanted to print “Aussie!” 5 times, we could increase the length of the vector to 5. If we wanted to print it 100 times (could happen) we could increase the length of the vector to 100, but using function <code>c()</code> for this is too cumbersome. In R, we have an alternative for generating a sequence of numbers – the <code>:</code> operator.</p>
<pre class="r"><code>small_seq &lt;- 1:5
small_seq
#&gt; [1] 1 2 3 4 5

big_seq &lt;- 1:50
big_seq
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
#&gt; [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50</code></pre>
<p>There are more powerful R functions for generating sequences (see, for example <code>seq</code> and <code>rep</code>) but for basic for loops, the <code>:</code> operator is sufficient. We can extend our cheer-printing for loop:</p>
<pre class="r"><code>for (cheer in 1:10)
{
  print(&quot;Aussie&quot;)
}
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] &quot;Aussie&quot;</code></pre>
<p><br />
</p>
</div>
</div>
<div id="the-loop-driver" class="section level1">
<h1>The Loop Driver</h1>
<p>Recall the schematic for a for loop in R:</p>
<div class="line-block"><strong>for</strong> (<em>variable_name</em> <strong>in</strong> <em>some_kind_of_sequence</em>)<br />
{<br />
    <em>Code to be repeated. Can be as long as required.</em><br />
}</div>
<p><br />
The <em>variable_name</em> element can be any legal R variable name. This element is called the <strong>loop driver</strong>. Inside the code body of the for loop, the loop driver variable <strong>is always available</strong>. For example, in our “Aussie!, Aussie! Aussie!” example, our loop driver was called <em>cheer</em>. In our code body we could have referred to variable <code>cheer</code>.</p>
<p>As discussed above, the for loop code body is executed as many times as there are elements in the sequence in the header. At each pass through the loop, the loop driver variable automatically takes on <strong>the value of the corresponding element of the sequence</strong>. That is, in the first pass of the loop, the loop driver holds the value of the first element of the sequence; in the second pass of the loop, the loop driver holds the value of the second element of the sequence, and so on.</p>
<p>We illustrate this by extending our previous example to print the value of loop driver <code>cheer</code> inside the code body:</p>
<pre class="r"><code>for (cheer in 1:3)
{
  print(&quot;Aussie&quot;)
  print(cheer)
}
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] 1
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] 2
#&gt; [1] &quot;Aussie&quot;
#&gt; [1] 3</code></pre>
<p>Note that you <strong>never assign a value to the loop driver</strong> – it takes on its values automatically as the for loop runs.</p>
<p>In all our examples so far, the sequence in the for loop header has been numbers from 1 to <em>n</em>. In R, the sequence can be a vector of any type, and the loop driver will take on whatever values the sequence contains. For example, we can drive a for loop with a vector of string:</p>
<pre class="r"><code>sports &lt;- c(&quot;Rugby&quot;, &quot;Cycling&quot;, &quot;Ice Skating&quot;)
for (current_sport in sports)
{
  # Print the sport name
  print(current_sport)
  
  # Compute the number of characters in the sport name
  print(nchar(current_sport))
}
#&gt; [1] &quot;Rugby&quot;
#&gt; [1] 5
#&gt; [1] &quot;Cycling&quot;
#&gt; [1] 7
#&gt; [1] &quot;Ice Skating&quot;
#&gt; [1] 11</code></pre>
<p><br />
</p>
<div id="loop-driver-as-index" class="section level2">
<h2>Loop driver as index</h2>
<p>Throughout the course we have seen that R relies heavily on managing data in ordered collections (vectors, lists, and data frames). We select elements from those collections using the selection operator <code>[]</code>, providing the ordinal position of the element of interest. Since loop driver variables take on each value in their sequence, we can use a for loop to step through each element of a collection in turn.</p>
<p>For example, assume you have a data frame containing one student’s internal and exam marks for the papers taken in one semester:</p>
<pre class="r"><code>paper_codes &lt;- c(&quot;HUBS192&quot;, &quot;ECOL212&quot;, &quot;STAT260&quot;)
internal_marks &lt;- c(87, 85, 62)
exam_marks &lt;- c(93, 84, 85)

marks_df &lt;- data.frame(PaperCode = paper_codes,
                       InternalMark = as.numeric(internal_marks),
                       ExamMark = as.numeric(exam_marks))

marks_df
#&gt;   PaperCode InternalMark ExamMark
#&gt; 1   HUBS192           87       93
#&gt; 2   ECOL212           85       84
#&gt; 3   STAT260           62       85</code></pre>
<p>We know that we can select all columns from a single row in that data frame using the syntax [<em>row number</em>, ]</p>
<pre class="r"><code># Select and print row 2
selected_row &lt;- marks_df[2, ]
print(selected_row)
#&gt;   PaperCode InternalMark ExamMark
#&gt; 2   ECOL212           85       84</code></pre>
<p>With a for loop, we can use the loop driver to iterate over all the rows, processing each in turn:</p>
<pre class="r"><code>for (index in 1:3)
{
  # Use the loop driver to select a row from the data frame
  selected_row &lt;- marks_df[index, ]
  
  # Process the row (just printing in this example)
  print(selected_row)
}
#&gt;   PaperCode InternalMark ExamMark
#&gt; 1   HUBS192           87       93
#&gt;   PaperCode InternalMark ExamMark
#&gt; 2   ECOL212           85       84
#&gt;   PaperCode InternalMark ExamMark
#&gt; 3   STAT260           62       85</code></pre>
<p>Note that if we made our data frame longer than three rows by adding more papers to it, the preceding for loop <strong>would not</strong> print all the rows; the sequence in that example is always <code>1, 2, 3</code> so we see only rows 1, 2, and 3. We can make the loop more general by determining the for loop sequence <strong>dynamically</strong> using function <code>nrow</code>, which accepts a data frame as an argument, and returns the number of rows in the data frame:</p>
<pre class="r"><code># Display all rows
for (index in 1:nrow(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_row &lt;- marks_df[index, ]
  print(selected_row)
}
#&gt;   PaperCode InternalMark ExamMark
#&gt; 1   HUBS192           87       93
#&gt;   PaperCode InternalMark ExamMark
#&gt; 2   ECOL212           85       84
#&gt;   PaperCode InternalMark ExamMark
#&gt; 3   STAT260           62       85

# Add a row to the data frame
marks_df &lt;- rbind(marks_df, data.frame(PaperCode = &quot;ZOOL316&quot;, 
                                       InternalMark = 83, 
                                       ExamMark = 90))


# Repeat the loop -- see four rows
for (index in 1:nrow(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_row &lt;- marks_df[index, ]
  print(selected_row)
}
#&gt;   PaperCode InternalMark ExamMark
#&gt; 1   HUBS192           87       93
#&gt;   PaperCode InternalMark ExamMark
#&gt; 2   ECOL212           85       84
#&gt;   PaperCode InternalMark ExamMark
#&gt; 3   STAT260           62       85
#&gt;   PaperCode InternalMark ExamMark
#&gt; 4   ZOOL316           83       90</code></pre>
<p><br />
</p>
</div>
</div>
<div id="exercise" class="section level1">
<h1>Exercise</h1>
<ol style="list-style-type: decimal">
<li>Write a for loop that iterates over marks_df printing <strong>each column</strong> in turn.</li>
<li>Your final mark in each paper is computed as 40% of your internal mark plus 60% of your exam mark. Using the technique of your choice, add a new column to data frame marks_df which contains the computed final mark for each paper.</li>
<li>Run your for loop again and confirm that it displays <em>all</em> the columns, including the new one.</li>
</ol>
<pre class="r"><code># Display all columns
for (index in 1:ncol(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_col &lt;- marks_df[ , index]
  print(selected_col)
}
#&gt; [1] &quot;HUBS192&quot; &quot;ECOL212&quot; &quot;STAT260&quot; &quot;ZOOL316&quot;
#&gt; [1] 87 85 62 83
#&gt; [1] 93 84 85 90


# Add a new column
marks_df$TotalMark &lt;- (0.40 * marks_df$InternalMark) + (0.60 * marks_df$ExamMark) 


# Confirm that we display all four columns
for (index in 1:ncol(marks_df))
{
  # Use the loop driver to index into the data frame
  selected_col &lt;- marks_df[ , index]
  print(selected_col)
}
#&gt; [1] &quot;HUBS192&quot; &quot;ECOL212&quot; &quot;STAT260&quot; &quot;ZOOL316&quot;
#&gt; [1] 87 85 62 83
#&gt; [1] 93 84 85 90
#&gt; [1] 90.6 84.4 75.8 87.2</code></pre>
<p><br />
</p>
</div>
<div id="nested-for-loops" class="section level1">
<h1>Nested for loops</h1>
<p>In the preceding examples, we have iterated over a data frame processing complete rows, or complete columns. Frequently, it is necessary to iterate over a data frame (or matrix) processing each <em>individual cell</em> in turn. That is, instead of using the <code>[, col]</code> or <code>[row, ]</code> forms of selection, we need to specify both a row index and a column index (i.e. <code>[row, col]</code>). This is very common processing technique in simulation, computer graphics, artificial intelligence, and computational problems requiring matrix algebra.</p>
<p>We iterate over tabular date in an orderly fashion. For example, if we have a 3x3 matrix or data frame we would process the cells in the first row from left to right ([1,1], [1,2], [1,3]), then the cells in the second row ([2,1], [2,2], [2,3]), and finally the cells in the third row ([3,1], [3,1], [3,3]). You can view this pattern as using <strong>two loop drivers</strong>, one for the row index and one for the column index. While the row driver is 1, we want the column driver to loop through values 1, 2, and 3. Then, we want the row driver to take on 2, and again want the column driver to loop through 1, 2, and 3. Finally we want the row driver to be 3, and the column driver to loop again. We can achieve this by <strong>nesting</strong> a for loop for columns <strong>inside</strong> a for loop for rows, as shown below. Note that each for loop has its own loop driver, its own sequence and its own round and curly brackets. The style of indenting the <strong>inner for loop</strong> is important for maintaining code readability.</p>
<pre class="r"><code># Outer loop.
for (row_index in 1:nrow(marks_df))
{
  # Inner loop -- makes all iterations for each pass through outer loop
  for (col_index in 1:ncol(marks_df))
  {
    # Use both loop drivers to select
    cell_value &lt;- marks_df[row_index, col_index]
    print(cell_value)
  }
}
#&gt; [1] &quot;HUBS192&quot;
#&gt; [1] 87
#&gt; [1] 93
#&gt; [1] 90.6
#&gt; [1] &quot;ECOL212&quot;
#&gt; [1] 85
#&gt; [1] 84
#&gt; [1] 84.4
#&gt; [1] &quot;STAT260&quot;
#&gt; [1] 62
#&gt; [1] 85
#&gt; [1] 75.8
#&gt; [1] &quot;ZOOL316&quot;
#&gt; [1] 83
#&gt; [1] 90
#&gt; [1] 87.2</code></pre>
<p><br />
</p>
<div id="exercise-1" class="section level2">
<h2>Exercise</h2>
<p>The preceding example prints <em>row-wise</em>. That is, it prints all the values for each row (i.e. for a single paper) before moving to the next row (paper). Modify the code to print <em>column-wise</em>. That is, print down the columns: all the paper names, then all the internal marks, then all the exam marks, then all the final marks.</p>
<pre class="r"><code># Outer loop.
for (col_index in 1:ncol(marks_df))
{
  # Inner loop -- makes all iterations for each pass through outer loop
  for (row_index in 1:nrow(marks_df))
  {
    # Use both loop drivers to select
    cell_value &lt;- marks_df[row_index, col_index]
    print(cell_value)
  }
}
#&gt; [1] &quot;HUBS192&quot;
#&gt; [1] &quot;ECOL212&quot;
#&gt; [1] &quot;STAT260&quot;
#&gt; [1] &quot;ZOOL316&quot;
#&gt; [1] 87
#&gt; [1] 85
#&gt; [1] 62
#&gt; [1] 83
#&gt; [1] 93
#&gt; [1] 84
#&gt; [1] 85
#&gt; [1] 90
#&gt; [1] 90.6
#&gt; [1] 84.4
#&gt; [1] 75.8
#&gt; [1] 87.2</code></pre>
<p><br />
</p>
<div id="caution" class="section level3">
<h3>CAUTION</h3>
<p>Using a nested for loop to visit every cell in a table is a very common, and very powerful code pattern. However, be aware that it can be computationally expensive (i.e. it can take a long time to run). If your outer loop runs <code>n</code> passes and your inner loop runs <code>m</code> passes, you make a total of <code>n * m</code> passes. When processing a 1000 row x 1000 column table with a nested for loop, the code body of the inner loop is executed one million times, which may be intractable. If you have large tabular data sets that take a long time to process, you should consider leveraging R’s advanced vector processing techniques that can be more efficient than an interior for loop. See, for example, <a href="https://rstudio-pubs-static.s3.amazonaws.com/72295_692737b667614d369bd87cb0f51c9a4b.html" class="uri">https://rstudio-pubs-static.s3.amazonaws.com/72295_692737b667614d369bd87cb0f51c9a4b.html</a> or <a href="http://www.john-ros.com/Rcourse/memory.html" class="uri">http://www.john-ros.com/Rcourse/memory.html</a> for discussions.</p>
</div>
</div>
</div>
<div id="while-loop" class="section level1">
<h1>While loop</h1>
<p>The <strong>for loop</strong> is used when you want to execute a code body a specific number of times, or iterate over a specific sequence of values. An alternative loop structure – the <strong>while loop</strong> repeats as long as a given condition evaluates to true.</p>
<p>The schematic for a <code>while</code> loop is as follows:</p>
<pre class="r"><code>while (condition) 
{
  # Loop body
}</code></pre>
<p>In an earlier module, we used function <code>rnorm</code> to randomly select a value from a normal distribution with a known mean and standard deviation. Imagine that you want to explore the probability of randomly selecting a number from such a distribution that is more than two standard deviations above the mean (i.e. has a z-score of 2 or more). You could estimate this by repeatedly selecting a number until you achieved the criterion, and counting the number of times you had to select. We wish to loop repeatedly over some logic (selecting and counting), but we don’t know exactly how many times the loop should run, so a for loop is not appropriate. In this situation, we use a <strong>while loop</strong>.</p>
<p><strong>Before looking at the code sample below, try to work out what the while loop condition will be.</strong></p>
<pre class="r"><code># Define the parameters
distribution_mean &lt;- 100
distribution_sd &lt;- 10

# Prepare a variable to count the passes
count &lt;- 0

# Make your first selection so the loop condition to be evaluated 
# on the first pass
rand_value &lt;- rnorm(1, distribution_mean, distribution_sd)

# The loop. Note the condition. We continue running the loop
# as long as our selected value is less than mean + 2*sd.
# While loops run as long as the loop condition is true.
while (rand_value &lt; distribution_mean + (2 * distribution_sd))
{
  # increment the count because the loop condition was true
  count &lt;- count + 1
  
  # Select again
  rand_value &lt;- rnorm(1, distribution_mean, distribution_sd)
  
} # end of while loop

# Display the result
output &lt;- paste(count, &quot;values were chosen before z-score &gt; 1&quot;)
print(output)
#&gt; [1] &quot;13 values were chosen before z-score &gt; 1&quot;</code></pre>
<p>Here is an example of a <code>while</code> loop to count how many iterations it takes to obtain 3 heads in a row:</p>
<pre class="r"><code>## Example from R for Data Science - 21.3.4 ##

# Function to simulate head or tail as the result of a coin flip
flip &lt;- function(){
  sample(c(&quot;T&quot;, &quot;H&quot;), 1)
}

# variables to keep track of key results
flips &lt;- 0
nheads &lt;- 0

# flip a coin until there are three heads and count how many flips were performed.
while (nheads &lt; 3) {
  if (flip() == &quot;H&quot;) {
    nheads &lt;- nheads + 1
  } else {
    nheads &lt;- 0
  }
  flips &lt;- flips + 1
}
flips
#&gt; [1] 3</code></pre>
<p><br />
</p>
<div id="infinite-while-loops" class="section level2">
<h2>Infinite while loops</h2>
<p>NB: It is essential that your while loop condition will <strong>eventually evaluate to false</strong>. Consider the following code sample (which we will <em>not</em> run).</p>
<pre class="r"><code># Set a starting value so we can check the condition on the first pass
x &lt;- 10

# The loop
while (x &gt; 0)
{
  # The code body
  x &lt;- x + 1
}
</code></pre>
<p>The variable x is initialised to 10, and incremented at each pass through the code body. Its value will therefore always be greater than or equal to 10. The loop condition is <code>x &gt; 0</code>. Since x starts at 10 and increases at each pass, it will always be greater than 0, so the loop condition will always be true, and the loop will never stop. This is an <strong>infinite loop</strong>. When your code is in an infinite loop, the only way to stop it is to forcibly terminate the program (assuming you recognise what has occurred). In R you can usually do this by clicking the red stop sign in the top right corner of the console window. An infinite loop that produces a lot of variables can consume memory to the point where the machine will crash. This is bad. Always check that your loop condition is guaranteed to eventually evaluate to false before running code with a while loop.</p>
</div>
</div>
<div id="map" class="section level1">
<h1>Map</h1>
<p>In the package <code>purrr</code> (part of package tidyverse), there are a collection of <code>map</code> functions which iterate over a vector or list, applying a function to each element. This is a very succinct syntax, which achieves the same result as calling the function inside a for loop, without the overhead of writing out the loop structure.</p>
<pre class="r"><code>library(purrr)

farenheit_to_celcius &lt;- function(temp_f){
  temp_c &lt;- (temp_f - 32) * 5/9
  return(temp_c)
}

my_temps_f &lt;- c(90, 78, 88, 89, 77)

# map applies the function (2nd argument) to each element of the vector (1st argument) 
# and returns the results as a list. 
my_temps_c_list &lt;- map(my_temps_f, farenheit_to_celcius)
my_temps_c_list
#&gt; [[1]]
#&gt; [1] 32.22222
#&gt; 
#&gt; [[2]]
#&gt; [1] 25.55556
#&gt; 
#&gt; [[3]]
#&gt; [1] 31.11111
#&gt; 
#&gt; [[4]]
#&gt; [1] 31.66667
#&gt; 
#&gt; [[5]]
#&gt; [1] 25</code></pre>
<p>The <code>map</code> argument names are <code>.x</code> and <code>.f</code>, so the call to <code>map</code> above could also be written as <code>my_temps_c_list &lt;- map(.x = my_temps_f, .f = farenheit_to_celcius)</code></p>
<p>Note that when providing a function as an argument, give <strong>only the function name</strong>. Do not follow the function name with () as for a function call.</p>
<div id="map-and-friends" class="section level2">
<h2>Map and friends</h2>
<p>The basic form of <code>map</code> above, returns the results in a list. There are suffix versions of <code>map</code> that return the results as a specific data type.</p>
<ul>
<li><code>map()</code> makes a list.</li>
<li><code>map_lgl()</code> makes a logical vector.</li>
<li><code>map_int()</code> makes an integer vector.</li>
<li><code>map_dbl()</code> makes a double vector.</li>
<li><code>map_chr()</code> makes a character vector.</li>
</ul>
<p>These suffix versions will give an error if the data type of the results doesn’t match the intended return type. This is useful because you can write code to process the results further, confident that they are of a specific data type.</p>
</div>
</div>
<div id="apply" class="section level1">
<h1>Apply</h1>
<p>Base R has a set of built in functions that duplicate the behaviour of <code>purrr::map</code> and its suffix functions. These are the <strong>apply family</strong>: <code>apply</code>, <code>lapply</code>, <code>sapply</code>, <code>mapply</code>, and <code>tapply</code>. The functions differ primarily in the structure of the data they return. See, for example, <a href="http://adv-r.had.co.nz/Functionals.html" class="uri">http://adv-r.had.co.nz/Functionals.html</a> for more detail.</p>
<p>Function <code>lapply</code> is analogous to <code>purrr::map()</code>:</p>
<pre class="r"><code>farenheit_to_celcius &lt;- function(temp_f){
  temp_c &lt;- (temp_f -32) * 5/9
  return(temp_c)
}

my_temps_f &lt;- c(90, 78, 88, 89, 77)

# lapply example
lapply_my_temps_c &lt;- lapply(X = my_temps_f, FUN = farenheit_to_celcius)
lapply_my_temps_c
#&gt; [[1]]
#&gt; [1] 32.22222
#&gt; 
#&gt; [[2]]
#&gt; [1] 25.55556
#&gt; 
#&gt; [[3]]
#&gt; [1] 31.11111
#&gt; 
#&gt; [[4]]
#&gt; [1] 31.66667
#&gt; 
#&gt; [[5]]
#&gt; [1] 25</code></pre>
<p>Note that some of the apply family return different data structures depending on the type of the input data. This can make it challenging to know beforehand what the output is going to look like - unlike the suffix versions of <code>purrr::map</code></p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>In this module we covered using for and while loops to repeat code fragments efficiently. We saw that functions in the map and apply families provide an equivalent, yet more succinct syntax, when the repeated code is a single function. Combining loops with functions and conditional flow of control from last week’s session, you can create code that is modular, reusable, and maintainable.</p>
</div>
<div id="whats-next" class="section level1">
<h1>What’s Next</h1>
<p>Next week we conclude the formal content of R4SSP with a discussion of R workflows, including project structure, incremental development, and effective debugging techniques.</p>
<p>Please fill in the module feedback form <a href="https://tinyurl.com/r4ssp-module-fb">https://tinyurl.com/r4ssp-module-fb</a>.</p>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlJlcGVhdGluZyBDb2RlIg0KZGF0ZTogIlNlbWVzdGVyIDEsIDIwMjIiDQpvdXRwdXQ6DQogIGh0bWxfZG9jdW1lbnQ6DQogICAgdG9jOiB0cnVlDQogICAgdG9jX2Zsb2F0OiB0cnVlDQogICAgdG9jX2RlcHRoOiAzDQogICAgY29kZV9kb3dubG9hZDogdHJ1ZQ0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KLS0tDQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0KbGlicmFyeShrbml0cikNCg0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KA0KICBjb21tZW50ID0gIiM+IiwNCiAgZmlnLnBhdGggPSAiZmlndXJlcy8wOC8iLCAjIHVzZSBvbmx5IGZvciBzaW5nbGUgUm1kIGZpbGVzDQogIGNvbGxhcHNlID0gVFJVRSwNCiAgZWNobyA9IFRSVUUNCikNCg0KDQpgYGANCg0KPiAjIyMjIEFzc29jaWF0ZWQgTWF0ZXJpYWwNCj4NCj4gWm9vbSBOb3RlczogW1pvb20gTm90ZXMgMDggLSBSZXBlYXRpbmcgQ29kZV0oem9vbV9ub3Rlc18wOC5odG1sKQ0KPg0KPiBSZWFkaW5nczoNCj4NCj4gLSBbUiBmb3IgRGF0YSBTY2llbmNlIC0gQ2hhcHRlciAyMV0oaHR0cHM6Ly9yNGRzLmhhZC5jby5uei9pdGVyYXRpb24uaHRtbCkNCg0KXA0KDQojIEludHJvZHVjdGlvbg0KDQpJbiB0aGUgcHJldmlvdXMgbW9kdWxlIHdlIGxlYXJuZWQgdG8gbWFrZSBvdXIgY29kZSBtb3JlICoqbW9kdWxhcioqIGJ5IG9yZ2FuaXNpbmcgaXQgaW50byBmdW5jdGlvbnMsIGVhY2ggb2Ygd2hpY2ggZW5jYXBzdWxhdGVzIHNvbWUgbG9naWNhbGx5IGRpc3RpbmN0IHRhc2suIEJ5IHJlcGVhdGVkbHkgY2FsbGluZyBhIGZ1bmN0aW9uLCB3ZSBjYW4gZXhlY3V0ZSB0aGUgc2FtZSBjb2RlIG1hbnkgdGltZXMsIHdoaWxlIG9ubHkgaGF2aW5nIHRvIHR5cGUgaXQgb3V0IG9uY2UuIFRoaXMgaXMgKipjb2RlIHJldXNlKiogYW5kIGlzIGFuIGltcG9ydGFudCBnb2FsIGluIGVmZmljaWVudCBzb2Z0d2FyZSBkZXZlbG9wbWVudC4NCg0KV2UgY2FuIGFsc28gYWNoaWV2ZSBjb2RlIHJldXNlIHRocm91Z2ggKippdGVyYXRpb24qKi4gSXRlcmF0aXZlIGNvbnN0cnVjdHMgKG1vcmUgY2FzdWFsbHkgY2FsbGVkICoqbG9vcHMqKikgYWxsb3cgdXMgdG8gd3JpdGUgYSBjb2RlIGJsb2NrIG9uY2UsIHRoZW4gaW5zdHJ1Y3QgUiB0byBleGVjdXRlIGl0IGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGNhbiBiZSBtYWRlIHRvIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSAqKnN0YXRlKiouIChSZWNhbGwgdGhhdCAqKnN0YXRlKiogaXMgdGhlIHNldCBvZiB2YWx1ZXMgb2YgYWxsIHRoZSB2YXJpYWJsZXMgaW4gdGhlIGVudmlyb25tZW50IHdoZW4gYSBjb21tYW5kIGlzIGV4ZWN1dGVkLikgRm9yIGV4YW1wbGUsIHdlIGNhbiB3cml0ZSBhIGxvb3AgdGhhdCBpdGVyYXRlcyBhcyBtYW55IHRpbWVzIGFzIHRoZXJlIGFyZSByb3dzIGluIGEgZGF0YSBmcmFtZSB0aGF0IHdlIHJlYWQgZnJvbSBhIGZpbGUgYmVmb3JlIHRoZSBsb29wIHN0YXJ0cy4NCg0KSW4gUiwgYXMgaW4gbW9zdCBtb2Rlcm4gcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLCB0aGVyZSBhcmUgZGlmZmVyZW50IHR5cGVzIG9mIGxvb3BzLCB3aXRoIHN1YnRsZSBkaWZmZXJlbmNlcyBpbiBiZWhhdmlvdXIuIFdlIGJlZ2luIHdpdGggdGhlIG1vc3QgZ2VuZXJhbCBraW5kIG9mIGxvb3AgLS0gdGhlICoqZm9yIGxvb3AqKi4NCg0KDQojIFN5bnRheA0KDQpJbiBSIGEgKipmb3IgbG9vcCoqIGhhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZToNCg0KDQp8ICoqZm9yKiogKCp2YXJpYWJsZV9uYW1lKiAqKmluKiogKnNvbWVfa2luZF9vZl9zZXF1ZW5jZSopDQp8IHsNCnwgICAgICpDb2RlIGJsb2NrIHRvIGJlIHJlcGVhdGVkLiBDYW4gYmUgYXMgbG9uZyBhcyByZXF1aXJlZC4qDQp8IH0NCg0KXA0KDQpUaGUga2V5d29yZHMgKipmb3IqKiBhbmQgKippbioqIGFyZSByZXF1aXJlZCwgYXMgYXJlIHRoZSByb3VuZCBicmFja2V0cyBpbiB0aGUgKipsb29wIGhlYWRlcioqLCBhbmQgdGhlIGN1cmx5IGJyYWNrZXRzIHRoYXQgZGVsaW5lYXRlIHRoZSBjb2RlIGJvZHkuDQoNClRoZSAqc29tZV9raW5kX29mIHNlcXVlbmNlKiBpcyB1c3VhbGx5IGEgdmVjdG9yLiBUaGUgY29kZSBib2R5IGlzIGV4ZWN1dGVkIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3IuDQoNCldlIHdpbGwgZGlzY3VzcyB0aGUgcm9sZSBvZiB0aGUgKnZhcmlhYmxlX25hbWUqIGVsZW1lbnQgbGF0ZXIgaW4gdGhlIG1vZHVsZS4NCg0KKEl0IGlzIGFsc28gc3ludGFjdGljYWxseSBhY2NlcHRhYmxlIHRvIHBsYWNlIHRoZSBvcGVuaW5nIGN1cmx5IGJyYWNrZXQgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgZm9yIGxvb3AgaGVhZGVyLCBhZnRlciB0aGUgY2xvc2luZyByb3VuZCBicmFja2V0LCBzZXBhcmF0ZWQgYnkgYSBzcGFjZS4pDQoNCg0KIyBCYXNpYyBmb3IgbG9vcA0KDQpBIHBvcHVsYXIgY2hlZXIgaW4gQXVzdHJhbGlhbiBzcG9ydHMgaXMgIkF1c3NpZSEsIEF1c3NpZSEsIEF1c3NpZSEiLiBBc3N1bWUgdGhhdCAoZm9yIHNvbWUgaW5leHBsaWNhYmxlIHJlYXNvbikgeW91IHdpc2hlZCB0byBwcmludCB0aGlzIGNoZWVyLiBUaGF0IGlzLCB5b3Ugd2FudCB0byBwcmludCAiQXVzc2llISIgdG8gdGhlIGNvbnNvbGUgdGhyZWUgdGltZXMuIFVzaW5nIG9ubHkgc2VxdWVudGlhbCBjb2RlIHlvdSB3b3VsZCB3cml0ZToNCg0KYGBge3Igc2VxdWVudGlhbCwgZXZhbD1GQUxTRX0NCnByaW50KCJBdXNzaWUhIikNCnByaW50KCJBdXNzaWUhIikNCnByaW50KCJBdXNzaWUhIikNCmBgYA0KDQpZb3UgYXJlIGV4ZWN1dGluZyB0aGUgaWRlbnRpY2FsIGxpbmUgb2YgY29kZSB0aHJlZSB0aW1lcy4gSGF2aW5nIHRvIHR5cGUgdGhlIHNhbWUgbGluZSBvZiBjb2RlIG11bHRpcGxlIHRpbWVzIGlzIGJvcmluZywgYW5kIGluY3JlYXNlcyB0aGUgbnVtYmVyIG9mIG9wcG9ydHVuaXRpZXMgZm9yIHR5cG9zIGFuZCBidWdzIHRvIHNuZWFrIGluLiAoSW4gdGhpcyB0b3kgZXhhbXBsZSwgd2UgYXJlIG9ubHkgcmVwZWF0aW5nIG9uZSBsaW5lIG9mIGNvZGUgdGhyZWUgdGltZXM7IGluIGEgcmVhbCBjb21wdXRhdGlvbmFsIHNpdHVhdGlvbiB3ZSBtaWdodCBuZWVkIHRvIHJlcGVhdCBkb3plbnMgb2YgbGluZXMgb2YgY29kZSBodW5kcmVkcyBvZiB0aW1lcy4pIFVzaW5nIGEgKipmb3IgbG9vcCoqLCB3ZSBjYW4gYWNoaWV2ZSB0aGUgc2FtZSBvdXRwdXQgd2hpbGUgb25seSB0eXBpbmcgdGhlIGNvbW1hbmQgb25jZS4NCg0KYGBge3IgYmFzaWMgbG9vcH0NCmZvciAoY2hlZXIgaW4gYygxLDIsMykpDQp7DQogIHByaW50KCJBdXNzaWUiKQ0KfQ0KYGBgDQoNCk1hdGNoIHRoZSBwYXJ0cyBvZiB0aGlzIGxvb3AgdG8gdGhlIHNjaGVtYXRpYywgbm90aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUga2V5d29yZHMgKipmb3IqKiBhbmQgKippbioqLCB0aGUgcm91bmQgYnJhY2tldHMsIGFuZCB0aGUgY3VybHkgYnJhY2tldHMuIE5vdGUgdGhlICpzb21lX2tpbmRfb2Zfc2VxdWVuY2UqIGVsZW1lbnQgd2hpY2gsIGluIHRoaXMgY2FzZSwgaXMgdGhlIHZlY3RvciBjcmVhdGVkIGJ5IGBjKDEsMiwzKWAuIFNpbmNlIHRoZXJlIGFyZSB0aHJlZSBlbGVtZW50cyBpbiB0aGUgdmVjdG9yLCB0aGUgY29kZSBib2R5IGlzIGV4ZWN1dGVkIHRocmVlIHRpbWVzLiANCg0KIyMgVmVjdG9yIHNlcXVlbmNlcw0KDQpJZiB3ZSB3YW50ZWQgdG8gcHJpbnQgIkF1c3NpZSEiIDUgdGltZXMsIHdlIGNvdWxkIGluY3JlYXNlIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciB0byA1LiBJZiB3ZSB3YW50ZWQgdG8gcHJpbnQgaXQgMTAwIHRpbWVzIChjb3VsZCBoYXBwZW4pIHdlIGNvdWxkIGluY3JlYXNlIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciB0byAxMDAsIGJ1dCB1c2luZyBmdW5jdGlvbiBgYygpYCBmb3IgdGhpcyBpcyB0b28gY3VtYmVyc29tZS4gSW4gUiwgd2UgaGF2ZSBhbiBhbHRlcm5hdGl2ZSBmb3IgZ2VuZXJhdGluZyBhIHNlcXVlbmNlIG9mIG51bWJlcnMgLS0gdGhlIGA6YCBvcGVyYXRvci4NCg0KYGBge3Igc2VxIH0NCnNtYWxsX3NlcSA8LSAxOjUNCnNtYWxsX3NlcQ0KDQpiaWdfc2VxIDwtIDE6NTANCmJpZ19zZXENCmBgYA0KDQpUaGVyZSBhcmUgbW9yZSBwb3dlcmZ1bCBSIGZ1bmN0aW9ucyBmb3IgZ2VuZXJhdGluZyBzZXF1ZW5jZXMgKHNlZSwgZm9yIGV4YW1wbGUgYHNlcWAgYW5kIGByZXBgKSBidXQgZm9yIGJhc2ljIGZvciBsb29wcywgdGhlIGA6YCBvcGVyYXRvciBpcyBzdWZmaWNpZW50LiBXZSBjYW4gZXh0ZW5kIG91ciBjaGVlci1wcmludGluZyBmb3IgbG9vcDoNCg0KYGBge3IgbG9uZyBjaGVlcn0NCmZvciAoY2hlZXIgaW4gMToxMCkNCnsNCiAgcHJpbnQoIkF1c3NpZSIpDQp9DQpgYGANCg0KXA0KDQojIFRoZSBMb29wIERyaXZlcg0KDQpSZWNhbGwgdGhlIHNjaGVtYXRpYyBmb3IgYSBmb3IgbG9vcCBpbiBSOg0KDQp8ICoqZm9yKiogKCp2YXJpYWJsZV9uYW1lKiAqKmluKiogKnNvbWVfa2luZF9vZl9zZXF1ZW5jZSopDQp8IHsNCnwgICAgICpDb2RlIHRvIGJlIHJlcGVhdGVkLiBDYW4gYmUgYXMgbG9uZyBhcyByZXF1aXJlZC4qDQp8IH0NCg0KXA0KVGhlICp2YXJpYWJsZV9uYW1lKiBlbGVtZW50IGNhbiBiZSBhbnkgbGVnYWwgUiB2YXJpYWJsZSBuYW1lLiBUaGlzIGVsZW1lbnQgaXMgY2FsbGVkIHRoZSAqKmxvb3AgZHJpdmVyKiouIEluc2lkZSB0aGUgY29kZSBib2R5IG9mIHRoZSBmb3IgbG9vcCwgdGhlIGxvb3AgZHJpdmVyIHZhcmlhYmxlICoqaXMgYWx3YXlzIGF2YWlsYWJsZSoqLiBGb3IgZXhhbXBsZSwgaW4gb3VyICJBdXNzaWUhLCBBdXNzaWUhIEF1c3NpZSEiIGV4YW1wbGUsIG91ciBsb29wIGRyaXZlciB3YXMgY2FsbGVkICpjaGVlciouIEluIG91ciBjb2RlIGJvZHkgd2UgY291bGQgaGF2ZSByZWZlcnJlZCB0byB2YXJpYWJsZSBgY2hlZXJgLiANCg0KQXMgZGlzY3Vzc2VkIGFib3ZlLCB0aGUgZm9yIGxvb3AgY29kZSBib2R5IGlzIGV4ZWN1dGVkIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSBzZXF1ZW5jZSBpbiB0aGUgaGVhZGVyLiBBdCBlYWNoIHBhc3MgdGhyb3VnaCB0aGUgbG9vcCwgdGhlIGxvb3AgZHJpdmVyIHZhcmlhYmxlIGF1dG9tYXRpY2FsbHkgdGFrZXMgb24gKip0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBvZiB0aGUgc2VxdWVuY2UqKi4gVGhhdCBpcywgaW4gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGxvb3AsIHRoZSBsb29wIGRyaXZlciBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHNlcXVlbmNlOyBpbiB0aGUgc2Vjb25kIHBhc3Mgb2YgdGhlIGxvb3AsIHRoZSBsb29wIGRyaXZlciBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBzZXF1ZW5jZSwgYW5kIHNvIG9uLg0KDQpXZSBpbGx1c3RyYXRlIHRoaXMgYnkgZXh0ZW5kaW5nIG91ciBwcmV2aW91cyBleGFtcGxlIHRvIHByaW50IHRoZSB2YWx1ZSBvZiBsb29wIGRyaXZlciBgY2hlZXJgIGluc2lkZSB0aGUgY29kZSBib2R5Og0KDQpgYGB7ciBsb25nIGNoZWVyIDJ9DQpmb3IgKGNoZWVyIGluIDE6MykNCnsNCiAgcHJpbnQoIkF1c3NpZSIpDQogIHByaW50KGNoZWVyKQ0KfQ0KYGBgDQoNCk5vdGUgdGhhdCB5b3UgKipuZXZlciBhc3NpZ24gYSB2YWx1ZSB0byB0aGUgbG9vcCBkcml2ZXIqKiAtLSBpdCB0YWtlcyBvbiBpdHMgdmFsdWVzIGF1dG9tYXRpY2FsbHkgYXMgdGhlIGZvciBsb29wIHJ1bnMuDQoNCkluIGFsbCBvdXIgZXhhbXBsZXMgc28gZmFyLCB0aGUgc2VxdWVuY2UgaW4gdGhlIGZvciBsb29wIGhlYWRlciBoYXMgYmVlbiBudW1iZXJzIGZyb20gMSB0byAqbiouIEluIFIsIHRoZSBzZXF1ZW5jZSBjYW4gYmUgYSB2ZWN0b3Igb2YgYW55IHR5cGUsIGFuZCB0aGUgbG9vcCBkcml2ZXIgd2lsbCB0YWtlIG9uIHdoYXRldmVyIHZhbHVlcyB0aGUgc2VxdWVuY2UgY29udGFpbnMuIEZvciBleGFtcGxlLCB3ZSBjYW4gZHJpdmUgYSBmb3IgbG9vcCB3aXRoIGEgdmVjdG9yIG9mIHN0cmluZzoNCg0KYGBge3Igc2VxIG9mIHN0cmluZ30NCnNwb3J0cyA8LSBjKCJSdWdieSIsICJDeWNsaW5nIiwgIkljZSBTa2F0aW5nIikNCmZvciAoY3VycmVudF9zcG9ydCBpbiBzcG9ydHMpDQp7DQogICMgUHJpbnQgdGhlIHNwb3J0IG5hbWUNCiAgcHJpbnQoY3VycmVudF9zcG9ydCkNCiAgDQogICMgQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIHNwb3J0IG5hbWUNCiAgcHJpbnQobmNoYXIoY3VycmVudF9zcG9ydCkpDQp9DQogIA0KYGBgDQoNClwNCg0KIyMgTG9vcCBkcml2ZXIgYXMgaW5kZXgNCg0KVGhyb3VnaG91dCB0aGUgY291cnNlIHdlIGhhdmUgc2VlbiB0aGF0IFIgcmVsaWVzIGhlYXZpbHkgb24gbWFuYWdpbmcgZGF0YSBpbiBvcmRlcmVkIGNvbGxlY3Rpb25zICh2ZWN0b3JzLCBsaXN0cywgYW5kIGRhdGEgZnJhbWVzKS4gV2Ugc2VsZWN0IGVsZW1lbnRzIGZyb20gdGhvc2UgY29sbGVjdGlvbnMgdXNpbmcgdGhlIHNlbGVjdGlvbiBvcGVyYXRvciBgW11gLCBwcm92aWRpbmcgdGhlIG9yZGluYWwgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgb2YgaW50ZXJlc3QuIFNpbmNlIGxvb3AgZHJpdmVyIHZhcmlhYmxlcyB0YWtlIG9uIGVhY2ggdmFsdWUgaW4gdGhlaXIgc2VxdWVuY2UsIHdlIGNhbiB1c2UgYSBmb3IgbG9vcCB0byBzdGVwIHRocm91Z2ggZWFjaCBlbGVtZW50IG9mIGEgY29sbGVjdGlvbiBpbiB0dXJuLg0KDQpGb3IgZXhhbXBsZSwgYXNzdW1lIHlvdSBoYXZlIGEgZGF0YSBmcmFtZSBjb250YWluaW5nIG9uZSBzdHVkZW50J3MgaW50ZXJuYWwgYW5kIGV4YW0gbWFya3MgZm9yIHRoZSBwYXBlcnMgdGFrZW4gaW4gb25lIHNlbWVzdGVyOiANCg0KYGBge3IgbWFrZSBkYXRhIGZyYW1lfQ0KcGFwZXJfY29kZXMgPC0gYygiSFVCUzE5MiIsICJFQ09MMjEyIiwgIlNUQVQyNjAiKQ0KaW50ZXJuYWxfbWFya3MgPC0gYyg4NywgODUsIDYyKQ0KZXhhbV9tYXJrcyA8LSBjKDkzLCA4NCwgODUpDQoNCm1hcmtzX2RmIDwtIGRhdGEuZnJhbWUoUGFwZXJDb2RlID0gcGFwZXJfY29kZXMsDQogICAgICAgICAgICAgICAgICAgICAgIEludGVybmFsTWFyayA9IGFzLm51bWVyaWMoaW50ZXJuYWxfbWFya3MpLA0KICAgICAgICAgICAgICAgICAgICAgICBFeGFtTWFyayA9IGFzLm51bWVyaWMoZXhhbV9tYXJrcykpDQoNCm1hcmtzX2RmDQoNCmBgYA0KDQpXZSBrbm93IHRoYXQgd2UgY2FuIHNlbGVjdCBhbGwgY29sdW1ucyBmcm9tIGEgc2luZ2xlIHJvdyBpbiB0aGF0IGRhdGEgZnJhbWUgdXNpbmcgdGhlIHN5bnRheCBbKnJvdyBudW1iZXIqLCAgXQ0KDQpgYGB7ciBzZWxlY3Qgcm93fQ0KIyBTZWxlY3QgYW5kIHByaW50IHJvdyAyDQpzZWxlY3RlZF9yb3cgPC0gbWFya3NfZGZbMiwgXQ0KcHJpbnQoc2VsZWN0ZWRfcm93KQ0KDQpgYGANCg0KV2l0aCBhIGZvciBsb29wLCB3ZSBjYW4gdXNlIHRoZSBsb29wIGRyaXZlciB0byBpdGVyYXRlIG92ZXIgYWxsIHRoZSByb3dzLCBwcm9jZXNzaW5nIGVhY2ggaW4gdHVybjoNCg0KYGBge3Igc2ltcGxlIGRyaXZlciBhcyBpbmRleH0NCmZvciAoaW5kZXggaW4gMTozKQ0Kew0KICAjIFVzZSB0aGUgbG9vcCBkcml2ZXIgdG8gc2VsZWN0IGEgcm93IGZyb20gdGhlIGRhdGEgZnJhbWUNCiAgc2VsZWN0ZWRfcm93IDwtIG1hcmtzX2RmW2luZGV4LCBdDQogIA0KICAjIFByb2Nlc3MgdGhlIHJvdyAoanVzdCBwcmludGluZyBpbiB0aGlzIGV4YW1wbGUpDQogIHByaW50KHNlbGVjdGVkX3JvdykNCn0NCg0KYGBgDQoNCk5vdGUgdGhhdCBpZiB3ZSBtYWRlIG91ciBkYXRhIGZyYW1lIGxvbmdlciB0aGFuIHRocmVlIHJvd3MgYnkgYWRkaW5nIG1vcmUgcGFwZXJzIHRvIGl0LCB0aGUgcHJlY2VkaW5nIGZvciBsb29wICoqd291bGQgbm90KiogcHJpbnQgYWxsIHRoZSByb3dzOyB0aGUgc2VxdWVuY2UgaW4gdGhhdCBleGFtcGxlIGlzIGFsd2F5cyBgMSwgMiwgM2Agc28gd2Ugc2VlIG9ubHkgcm93cyAxLCAyLCBhbmQgMy4gV2UgY2FuIG1ha2UgdGhlIGxvb3AgbW9yZSBnZW5lcmFsIGJ5IGRldGVybWluaW5nIHRoZSBmb3IgbG9vcCBzZXF1ZW5jZSAqKmR5bmFtaWNhbGx5KiogdXNpbmcgZnVuY3Rpb24gYG5yb3dgLCB3aGljaCBhY2NlcHRzIGEgZGF0YSBmcmFtZSBhcyBhbiBhcmd1bWVudCwgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBkYXRhIGZyYW1lOg0KDQpgYGB7ciB1c2luZyBucm93fQ0KIyBEaXNwbGF5IGFsbCByb3dzDQpmb3IgKGluZGV4IGluIDE6bnJvdyhtYXJrc19kZikpDQp7DQogICMgVXNlIHRoZSBsb29wIGRyaXZlciB0byBpbmRleCBpbnRvIHRoZSBkYXRhIGZyYW1lDQogIHNlbGVjdGVkX3JvdyA8LSBtYXJrc19kZltpbmRleCwgXQ0KICBwcmludChzZWxlY3RlZF9yb3cpDQp9DQoNCiMgQWRkIGEgcm93IHRvIHRoZSBkYXRhIGZyYW1lDQptYXJrc19kZiA8LSByYmluZChtYXJrc19kZiwgZGF0YS5mcmFtZShQYXBlckNvZGUgPSAiWk9PTDMxNiIsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW50ZXJuYWxNYXJrID0gODMsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXhhbU1hcmsgPSA5MCkpDQoNCg0KIyBSZXBlYXQgdGhlIGxvb3AgLS0gc2VlIGZvdXIgcm93cw0KZm9yIChpbmRleCBpbiAxOm5yb3cobWFya3NfZGYpKQ0Kew0KICAjIFVzZSB0aGUgbG9vcCBkcml2ZXIgdG8gaW5kZXggaW50byB0aGUgZGF0YSBmcmFtZQ0KICBzZWxlY3RlZF9yb3cgPC0gbWFya3NfZGZbaW5kZXgsIF0NCiAgcHJpbnQoc2VsZWN0ZWRfcm93KQ0KfQ0KYGBgDQoNClwNCg0KIyBFeGVyY2lzZQ0KDQoxLiBXcml0ZSBhIGZvciBsb29wIHRoYXQgaXRlcmF0ZXMgb3ZlciBtYXJrc19kZiBwcmludGluZyAqKmVhY2ggY29sdW1uKiogaW4gdHVybi4NCjIuIFlvdXIgZmluYWwgbWFyayBpbiBlYWNoIHBhcGVyIGlzIGNvbXB1dGVkIGFzIDQwJSBvZiB5b3VyIGludGVybmFsIG1hcmsgcGx1cyA2MCUgb2YgeW91ciBleGFtIG1hcmsuIFVzaW5nIHRoZSB0ZWNobmlxdWUgb2YgeW91ciBjaG9pY2UsIGFkZCBhIG5ldyBjb2x1bW4gdG8gZGF0YSBmcmFtZSBtYXJrc19kZiB3aGljaCBjb250YWlucyB0aGUgY29tcHV0ZWQgZmluYWwgbWFyayBmb3IgZWFjaCBwYXBlci4NCjMuIFJ1biB5b3VyIGZvciBsb29wIGFnYWluIGFuZCBjb25maXJtIHRoYXQgaXQgZGlzcGxheXMgKmFsbCogdGhlIGNvbHVtbnMsIGluY2x1ZGluZyB0aGUgbmV3IG9uZS4NCg0KYGBge3IgZXggMSBzb2x1dGlvbn0NCiMgRGlzcGxheSBhbGwgY29sdW1ucw0KZm9yIChpbmRleCBpbiAxOm5jb2wobWFya3NfZGYpKQ0Kew0KICAjIFVzZSB0aGUgbG9vcCBkcml2ZXIgdG8gaW5kZXggaW50byB0aGUgZGF0YSBmcmFtZQ0KICBzZWxlY3RlZF9jb2wgPC0gbWFya3NfZGZbICwgaW5kZXhdDQogIHByaW50KHNlbGVjdGVkX2NvbCkNCn0NCg0KDQojIEFkZCBhIG5ldyBjb2x1bW4NCm1hcmtzX2RmJFRvdGFsTWFyayA8LSAoMC40MCAqIG1hcmtzX2RmJEludGVybmFsTWFyaykgKyAoMC42MCAqIG1hcmtzX2RmJEV4YW1NYXJrKSANCg0KDQojIENvbmZpcm0gdGhhdCB3ZSBkaXNwbGF5IGFsbCBmb3VyIGNvbHVtbnMNCmZvciAoaW5kZXggaW4gMTpuY29sKG1hcmtzX2RmKSkNCnsNCiAgIyBVc2UgdGhlIGxvb3AgZHJpdmVyIHRvIGluZGV4IGludG8gdGhlIGRhdGEgZnJhbWUNCiAgc2VsZWN0ZWRfY29sIDwtIG1hcmtzX2RmWyAsIGluZGV4XQ0KICBwcmludChzZWxlY3RlZF9jb2wpDQp9DQpgYGANCg0KXA0KDQojIE5lc3RlZCBmb3IgbG9vcHMNCg0KSW4gdGhlIHByZWNlZGluZyBleGFtcGxlcywgd2UgaGF2ZSBpdGVyYXRlZCBvdmVyIGEgZGF0YSBmcmFtZSBwcm9jZXNzaW5nIGNvbXBsZXRlIHJvd3MsIG9yIGNvbXBsZXRlIGNvbHVtbnMuIEZyZXF1ZW50bHksIGl0IGlzIG5lY2Vzc2FyeSB0byBpdGVyYXRlIG92ZXIgYSBkYXRhIGZyYW1lIChvciBtYXRyaXgpIHByb2Nlc3NpbmcgZWFjaCAqaW5kaXZpZHVhbCBjZWxsKiBpbiB0dXJuLiBUaGF0IGlzLCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgWywgY29sXWAgb3IgYFtyb3csIF1gIGZvcm1zIG9mIHNlbGVjdGlvbiwgd2UgbmVlZCB0byBzcGVjaWZ5IGJvdGggYSByb3cgaW5kZXggYW5kIGEgY29sdW1uIGluZGV4IChpLmUuIGBbcm93LCBjb2xdYCkuIFRoaXMgaXMgdmVyeSBjb21tb24gcHJvY2Vzc2luZyB0ZWNobmlxdWUgaW4gc2ltdWxhdGlvbiwgY29tcHV0ZXIgZ3JhcGhpY3MsIGFydGlmaWNpYWwgaW50ZWxsaWdlbmNlLCBhbmQgY29tcHV0YXRpb25hbCBwcm9ibGVtcyByZXF1aXJpbmcgbWF0cml4IGFsZ2VicmEuDQoNCldlIGl0ZXJhdGUgb3ZlciB0YWJ1bGFyIGRhdGUgaW4gYW4gb3JkZXJseSBmYXNoaW9uLiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZSBhIDN4MyBtYXRyaXggb3IgZGF0YSBmcmFtZSB3ZSB3b3VsZCBwcm9jZXNzIHRoZSBjZWxscyBpbiB0aGUgZmlyc3Qgcm93IGZyb20gbGVmdCB0byByaWdodCAoWzEsMV0sIFsxLDJdLCBbMSwzXSksIHRoZW4gdGhlIGNlbGxzIGluIHRoZSBzZWNvbmQgcm93IChbMiwxXSwgWzIsMl0sIFsyLDNdKSwgYW5kIGZpbmFsbHkgdGhlIGNlbGxzIGluIHRoZSB0aGlyZCByb3cgKFszLDFdLCBbMywxXSwgWzMsM10pLiBZb3UgY2FuIHZpZXcgdGhpcyBwYXR0ZXJuIGFzIHVzaW5nICoqdHdvIGxvb3AgZHJpdmVycyoqLCBvbmUgZm9yIHRoZSByb3cgaW5kZXggYW5kIG9uZSBmb3IgdGhlIGNvbHVtbiBpbmRleC4gV2hpbGUgdGhlIHJvdyBkcml2ZXIgaXMgMSwgd2Ugd2FudCB0aGUgY29sdW1uIGRyaXZlciB0byBsb29wIHRocm91Z2ggdmFsdWVzIDEsIDIsIGFuZCAzLiBUaGVuLCB3ZSB3YW50IHRoZSByb3cgZHJpdmVyIHRvIHRha2Ugb24gMiwgYW5kIGFnYWluIHdhbnQgdGhlIGNvbHVtbiBkcml2ZXIgdG8gbG9vcCB0aHJvdWdoIDEsIDIsIGFuZCAzLiBGaW5hbGx5IHdlIHdhbnQgdGhlIHJvdyBkcml2ZXIgdG8gYmUgMywgYW5kIHRoZSBjb2x1bW4gZHJpdmVyIHRvIGxvb3AgYWdhaW4uIFdlIGNhbiBhY2hpZXZlIHRoaXMgYnkgKipuZXN0aW5nKiogYSBmb3IgbG9vcCBmb3IgY29sdW1ucyAqKmluc2lkZSoqIGEgZm9yIGxvb3AgZm9yIHJvd3MsIGFzIHNob3duIGJlbG93LiBOb3RlIHRoYXQgZWFjaCBmb3IgbG9vcCBoYXMgaXRzIG93biBsb29wIGRyaXZlciwgaXRzIG93biBzZXF1ZW5jZSBhbmQgaXRzIG93biByb3VuZCBhbmQgY3VybHkgYnJhY2tldHMuIFRoZSBzdHlsZSBvZiBpbmRlbnRpbmcgdGhlICoqaW5uZXIgZm9yIGxvb3AqKiBpcyBpbXBvcnRhbnQgZm9yIG1haW50YWluaW5nIGNvZGUgcmVhZGFiaWxpdHkuDQoNCmBgYHtyIG5lc3RlZCBmb3Igcm93LXdpc2V9DQojIE91dGVyIGxvb3AuDQpmb3IgKHJvd19pbmRleCBpbiAxOm5yb3cobWFya3NfZGYpKQ0Kew0KICAjIElubmVyIGxvb3AgLS0gbWFrZXMgYWxsIGl0ZXJhdGlvbnMgZm9yIGVhY2ggcGFzcyB0aHJvdWdoIG91dGVyIGxvb3ANCiAgZm9yIChjb2xfaW5kZXggaW4gMTpuY29sKG1hcmtzX2RmKSkNCiAgew0KICAgICMgVXNlIGJvdGggbG9vcCBkcml2ZXJzIHRvIHNlbGVjdA0KICAgIGNlbGxfdmFsdWUgPC0gbWFya3NfZGZbcm93X2luZGV4LCBjb2xfaW5kZXhdDQogICAgcHJpbnQoY2VsbF92YWx1ZSkNCiAgfQ0KfQ0KYGBgDQoNClwNCg0KIyMgRXhlcmNpc2UNClRoZSBwcmVjZWRpbmcgZXhhbXBsZSBwcmludHMgKnJvdy13aXNlKi4gVGhhdCBpcywgaXQgcHJpbnRzIGFsbCB0aGUgdmFsdWVzIGZvciBlYWNoIHJvdyAoaS5lLiBmb3IgYSBzaW5nbGUgcGFwZXIpIGJlZm9yZSBtb3ZpbmcgdG8gdGhlIG5leHQgcm93IChwYXBlcikuIE1vZGlmeSB0aGUgY29kZSB0byBwcmludCAqY29sdW1uLXdpc2UqLiBUaGF0IGlzLCBwcmludCBkb3duIHRoZSBjb2x1bW5zOiBhbGwgdGhlIHBhcGVyIG5hbWVzLCB0aGVuIGFsbCB0aGUgaW50ZXJuYWwgbWFya3MsIHRoZW4gYWxsIHRoZSBleGFtIG1hcmtzLCB0aGVuIGFsbCB0aGUgZmluYWwgbWFya3MuDQoNCmBgYHtyIG5lc3RlZCBmb3IgY29sLXdpc2V9DQojIE91dGVyIGxvb3AuDQpmb3IgKGNvbF9pbmRleCBpbiAxOm5jb2wobWFya3NfZGYpKQ0Kew0KICAjIElubmVyIGxvb3AgLS0gbWFrZXMgYWxsIGl0ZXJhdGlvbnMgZm9yIGVhY2ggcGFzcyB0aHJvdWdoIG91dGVyIGxvb3ANCiAgZm9yIChyb3dfaW5kZXggaW4gMTpucm93KG1hcmtzX2RmKSkNCiAgew0KICAgICMgVXNlIGJvdGggbG9vcCBkcml2ZXJzIHRvIHNlbGVjdA0KICAgIGNlbGxfdmFsdWUgPC0gbWFya3NfZGZbcm93X2luZGV4LCBjb2xfaW5kZXhdDQogICAgcHJpbnQoY2VsbF92YWx1ZSkNCiAgfQ0KfQ0KYGBgDQoNClwNCg0KIyMjIENBVVRJT04NCg0KVXNpbmcgYSBuZXN0ZWQgZm9yIGxvb3AgdG8gdmlzaXQgZXZlcnkgY2VsbCBpbiBhIHRhYmxlIGlzIGEgdmVyeSBjb21tb24sIGFuZCB2ZXJ5IHBvd2VyZnVsIGNvZGUgcGF0dGVybi4gSG93ZXZlciwgYmUgYXdhcmUgdGhhdCBpdCBjYW4gYmUgY29tcHV0YXRpb25hbGx5IGV4cGVuc2l2ZSAoaS5lLiBpdCBjYW4gdGFrZSBhIGxvbmcgdGltZSB0byBydW4pLiBJZiB5b3VyIG91dGVyIGxvb3AgcnVucyBgbmAgcGFzc2VzIGFuZCB5b3VyIGlubmVyIGxvb3AgcnVucyBgbWAgcGFzc2VzLCB5b3UgbWFrZSBhIHRvdGFsIG9mIGBuICogbWAgcGFzc2VzLiBXaGVuIHByb2Nlc3NpbmcgYSAxMDAwIHJvdyB4IDEwMDAgY29sdW1uIHRhYmxlIHdpdGggYSBuZXN0ZWQgZm9yIGxvb3AsIHRoZSBjb2RlIGJvZHkgb2YgdGhlIGlubmVyIGxvb3AgaXMgZXhlY3V0ZWQgb25lIG1pbGxpb24gdGltZXMsIHdoaWNoIG1heSBiZSBpbnRyYWN0YWJsZS4gSWYgeW91IGhhdmUgbGFyZ2UgdGFidWxhciBkYXRhIHNldHMgdGhhdCB0YWtlIGEgbG9uZyB0aW1lIHRvIHByb2Nlc3MsIHlvdSBzaG91bGQgY29uc2lkZXIgbGV2ZXJhZ2luZyBSJ3MgYWR2YW5jZWQgdmVjdG9yIHByb2Nlc3NpbmcgdGVjaG5pcXVlcyB0aGF0IGNhbiBiZSBtb3JlIGVmZmljaWVudCB0aGFuIGFuIGludGVyaW9yIGZvciBsb29wLiBTZWUsIGZvciBleGFtcGxlLCBodHRwczovL3JzdHVkaW8tcHVicy1zdGF0aWMuczMuYW1hem9uYXdzLmNvbS83MjI5NV82OTI3MzdiNjY3NjE0ZDM2OWJkODdjYjBmNTFjOWE0Yi5odG1sIG9yIGh0dHA6Ly93d3cuam9obi1yb3MuY29tL1Jjb3Vyc2UvbWVtb3J5Lmh0bWwgZm9yIGRpc2N1c3Npb25zLg0KDQojIFdoaWxlIGxvb3ANCg0KVGhlICoqZm9yIGxvb3AqKiBpcyB1c2VkIHdoZW4geW91IHdhbnQgdG8gZXhlY3V0ZSBhIGNvZGUgYm9keSBhIHNwZWNpZmljIG51bWJlciBvZiB0aW1lcywgb3IgaXRlcmF0ZSBvdmVyIGEgc3BlY2lmaWMgc2VxdWVuY2Ugb2YgdmFsdWVzLiBBbiBhbHRlcm5hdGl2ZSBsb29wIHN0cnVjdHVyZSAtLSB0aGUgKip3aGlsZSBsb29wKiogcmVwZWF0cyBhcyBsb25nIGFzIGEgZ2l2ZW4gY29uZGl0aW9uIGV2YWx1YXRlcyB0byB0cnVlLg0KDQpUaGUgc2NoZW1hdGljIGZvciBhIGB3aGlsZWAgbG9vcCBpcyBhcyBmb2xsb3dzOg0KDQpgYGB7ciwgZXZhbCA9IEZBTFNFfQ0Kd2hpbGUgKGNvbmRpdGlvbikgDQp7DQogICMgTG9vcCBib2R5DQp9DQpgYGANCg0KSW4gYW4gZWFybGllciBtb2R1bGUsIHdlIHVzZWQgZnVuY3Rpb24gYHJub3JtYCB0byByYW5kb21seSBzZWxlY3QgYSB2YWx1ZSBmcm9tIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiB3aXRoIGEga25vd24gbWVhbiBhbmQgc3RhbmRhcmQgZGV2aWF0aW9uLiBJbWFnaW5lIHRoYXQgeW91IHdhbnQgdG8gZXhwbG9yZSB0aGUgcHJvYmFiaWxpdHkgb2YgcmFuZG9tbHkgc2VsZWN0aW5nIGEgbnVtYmVyIGZyb20gc3VjaCBhIGRpc3RyaWJ1dGlvbiB0aGF0IGlzIG1vcmUgdGhhbiB0d28gc3RhbmRhcmQgZGV2aWF0aW9ucyBhYm92ZSB0aGUgbWVhbiAoaS5lLiBoYXMgYSB6LXNjb3JlIG9mIDIgb3IgbW9yZSkuIFlvdSBjb3VsZCBlc3RpbWF0ZSB0aGlzIGJ5IHJlcGVhdGVkbHkgc2VsZWN0aW5nIGEgbnVtYmVyIHVudGlsIHlvdSBhY2hpZXZlZCB0aGUgY3JpdGVyaW9uLCBhbmQgY291bnRpbmcgdGhlIG51bWJlciBvZiB0aW1lcyB5b3UgaGFkIHRvIHNlbGVjdC4gV2Ugd2lzaCB0byBsb29wIHJlcGVhdGVkbHkgb3ZlciBzb21lIGxvZ2ljIChzZWxlY3RpbmcgYW5kIGNvdW50aW5nKSwgYnV0IHdlIGRvbid0IGtub3cgZXhhY3RseSBob3cgbWFueSB0aW1lcyB0aGUgbG9vcCBzaG91bGQgcnVuLCBzbyBhIGZvciBsb29wIGlzIG5vdCBhcHByb3ByaWF0ZS4gSW4gdGhpcyBzaXR1YXRpb24sIHdlIHVzZSBhICoqd2hpbGUgbG9vcCoqLg0KDQoqKkJlZm9yZSBsb29raW5nIGF0IHRoZSBjb2RlIHNhbXBsZSBiZWxvdywgdHJ5IHRvIHdvcmsgb3V0IHdoYXQgdGhlIHdoaWxlIGxvb3AgY29uZGl0aW9uIHdpbGwgYmUuKioNCg0KDQpgYGB7ciB3aGlsZSBsb29vcCB3aXRoIHJub3JtfQ0KIyBEZWZpbmUgdGhlIHBhcmFtZXRlcnMNCmRpc3RyaWJ1dGlvbl9tZWFuIDwtIDEwMA0KZGlzdHJpYnV0aW9uX3NkIDwtIDEwDQoNCiMgUHJlcGFyZSBhIHZhcmlhYmxlIHRvIGNvdW50IHRoZSBwYXNzZXMNCmNvdW50IDwtIDANCg0KIyBNYWtlIHlvdXIgZmlyc3Qgc2VsZWN0aW9uIHNvIHRoZSBsb29wIGNvbmRpdGlvbiB0byBiZSBldmFsdWF0ZWQgDQojIG9uIHRoZSBmaXJzdCBwYXNzDQpyYW5kX3ZhbHVlIDwtIHJub3JtKDEsIGRpc3RyaWJ1dGlvbl9tZWFuLCBkaXN0cmlidXRpb25fc2QpDQoNCiMgVGhlIGxvb3AuIE5vdGUgdGhlIGNvbmRpdGlvbi4gV2UgY29udGludWUgcnVubmluZyB0aGUgbG9vcA0KIyBhcyBsb25nIGFzIG91ciBzZWxlY3RlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gbWVhbiArIDIqc2QuDQojIFdoaWxlIGxvb3BzIHJ1biBhcyBsb25nIGFzIHRoZSBsb29wIGNvbmRpdGlvbiBpcyB0cnVlLg0Kd2hpbGUgKHJhbmRfdmFsdWUgPCBkaXN0cmlidXRpb25fbWVhbiArICgyICogZGlzdHJpYnV0aW9uX3NkKSkNCnsNCiAgIyBpbmNyZW1lbnQgdGhlIGNvdW50IGJlY2F1c2UgdGhlIGxvb3AgY29uZGl0aW9uIHdhcyB0cnVlDQogIGNvdW50IDwtIGNvdW50ICsgMQ0KICANCiAgIyBTZWxlY3QgYWdhaW4NCiAgcmFuZF92YWx1ZSA8LSBybm9ybSgxLCBkaXN0cmlidXRpb25fbWVhbiwgZGlzdHJpYnV0aW9uX3NkKQ0KICANCn0gIyBlbmQgb2Ygd2hpbGUgbG9vcA0KDQojIERpc3BsYXkgdGhlIHJlc3VsdA0Kb3V0cHV0IDwtIHBhc3RlKGNvdW50LCAidmFsdWVzIHdlcmUgY2hvc2VuIGJlZm9yZSB6LXNjb3JlID4gMSIpDQpwcmludChvdXRwdXQpDQoNCmBgYA0KDQpIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBgd2hpbGVgIGxvb3AgdG8gY291bnQgaG93IG1hbnkgaXRlcmF0aW9ucyBpdCB0YWtlcyB0byBvYnRhaW4gMyBoZWFkcyBpbiBhIHJvdzoNCg0KYGBge3IsIGVjaG8gPSBUUlVFLCBldmFsID0gVFJVRX0NCiMjIEV4YW1wbGUgZnJvbSBSIGZvciBEYXRhIFNjaWVuY2UgLSAyMS4zLjQgIyMNCg0KIyBGdW5jdGlvbiB0byBzaW11bGF0ZSBoZWFkIG9yIHRhaWwgYXMgdGhlIHJlc3VsdCBvZiBhIGNvaW4gZmxpcA0KZmxpcCA8LSBmdW5jdGlvbigpew0KICBzYW1wbGUoYygiVCIsICJIIiksIDEpDQp9DQoNCiMgdmFyaWFibGVzIHRvIGtlZXAgdHJhY2sgb2Yga2V5IHJlc3VsdHMNCmZsaXBzIDwtIDANCm5oZWFkcyA8LSAwDQoNCiMgZmxpcCBhIGNvaW4gdW50aWwgdGhlcmUgYXJlIHRocmVlIGhlYWRzIGFuZCBjb3VudCBob3cgbWFueSBmbGlwcyB3ZXJlIHBlcmZvcm1lZC4NCndoaWxlIChuaGVhZHMgPCAzKSB7DQogIGlmIChmbGlwKCkgPT0gIkgiKSB7DQogICAgbmhlYWRzIDwtIG5oZWFkcyArIDENCiAgfSBlbHNlIHsNCiAgICBuaGVhZHMgPC0gMA0KICB9DQogIGZsaXBzIDwtIGZsaXBzICsgMQ0KfQ0KZmxpcHMNCg0KYGBgDQoNClwNCg0KIyMgSW5maW5pdGUgd2hpbGUgbG9vcHMNCg0KTkI6IEl0IGlzIGVzc2VudGlhbCB0aGF0IHlvdXIgd2hpbGUgbG9vcCBjb25kaXRpb24gd2lsbCAqKmV2ZW50dWFsbHkgZXZhbHVhdGUgdG8gZmFsc2UqKi4gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBjb2RlIHNhbXBsZSAod2hpY2ggd2Ugd2lsbCAqbm90KiBydW4pLg0KDQpgYGB7ciBpbmZpbml0ZSBsb29wLCBldmFsID0gRkFMU0V9DQojIFNldCBhIHN0YXJ0aW5nIHZhbHVlIHNvIHdlIGNhbiBjaGVjayB0aGUgY29uZGl0aW9uIG9uIHRoZSBmaXJzdCBwYXNzDQp4IDwtIDEwDQoNCiMgVGhlIGxvb3ANCndoaWxlICh4ID4gMCkNCnsNCiAgIyBUaGUgY29kZSBib2R5DQogIHggPC0geCArIDENCn0NCg0KYGBgDQoNClRoZSB2YXJpYWJsZSB4IGlzIGluaXRpYWxpc2VkIHRvIDEwLCBhbmQgaW5jcmVtZW50ZWQgYXQgZWFjaCBwYXNzIHRocm91Z2ggdGhlIGNvZGUgYm9keS4gSXRzIHZhbHVlIHdpbGwgdGhlcmVmb3JlIGFsd2F5cyBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMTAuIFRoZSBsb29wIGNvbmRpdGlvbiBpcyBgeCA+IDBgLiBTaW5jZSB4IHN0YXJ0cyBhdCAxMCBhbmQgaW5jcmVhc2VzIGF0IGVhY2ggcGFzcywgaXQgd2lsbCBhbHdheXMgYmUgZ3JlYXRlciB0aGFuIDAsIHNvIHRoZSBsb29wIGNvbmRpdGlvbiB3aWxsIGFsd2F5cyBiZSB0cnVlLCBhbmQgdGhlIGxvb3Agd2lsbCBuZXZlciBzdG9wLiBUaGlzIGlzIGFuICoqaW5maW5pdGUgbG9vcCoqLiBXaGVuIHlvdXIgY29kZSBpcyBpbiBhbiBpbmZpbml0ZSBsb29wLCB0aGUgb25seSB3YXkgdG8gc3RvcCBpdCBpcyB0byBmb3JjaWJseSB0ZXJtaW5hdGUgdGhlIHByb2dyYW0gKGFzc3VtaW5nIHlvdSByZWNvZ25pc2Ugd2hhdCBoYXMgb2NjdXJyZWQpLiBJbiBSIHlvdSBjYW4gdXN1YWxseSBkbyB0aGlzIGJ5IGNsaWNraW5nIHRoZSByZWQgc3RvcCBzaWduIGluIHRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBjb25zb2xlIHdpbmRvdy4gQW4gaW5maW5pdGUgbG9vcCB0aGF0IHByb2R1Y2VzIGEgbG90IG9mIHZhcmlhYmxlcyBjYW4gY29uc3VtZSBtZW1vcnkgdG8gdGhlIHBvaW50IHdoZXJlIHRoZSBtYWNoaW5lIHdpbGwgY3Jhc2guIFRoaXMgaXMgYmFkLiBBbHdheXMgY2hlY2sgdGhhdCB5b3VyIGxvb3AgY29uZGl0aW9uIGlzIGd1YXJhbnRlZWQgdG8gZXZlbnR1YWxseSBldmFsdWF0ZSB0byBmYWxzZSBiZWZvcmUgcnVubmluZyBjb2RlIHdpdGggYSB3aGlsZSBsb29wLg0KDQojIE1hcA0KDQpJbiB0aGUgcGFja2FnZSBgcHVycnJgIChwYXJ0IG9mIHBhY2thZ2UgdGlkeXZlcnNlKSwgdGhlcmUgYXJlIGEgY29sbGVjdGlvbiBvZiBgbWFwYCBmdW5jdGlvbnMgd2hpY2ggaXRlcmF0ZSBvdmVyIGEgdmVjdG9yIG9yIGxpc3QsIGFwcGx5aW5nIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50LiBUaGlzIGlzIGEgdmVyeSBzdWNjaW5jdCBzeW50YXgsIHdoaWNoIGFjaGlldmVzIHRoZSBzYW1lIHJlc3VsdCBhcyBjYWxsaW5nIHRoZSBmdW5jdGlvbiBpbnNpZGUgYSBmb3IgbG9vcCwgd2l0aG91dCB0aGUgb3ZlcmhlYWQgb2Ygd3JpdGluZyBvdXQgdGhlIGxvb3Agc3RydWN0dXJlLg0KDQpgYGB7ciBzaW1wbGUgbWFwfQ0KbGlicmFyeShwdXJycikNCg0KZmFyZW5oZWl0X3RvX2NlbGNpdXMgPC0gZnVuY3Rpb24odGVtcF9mKXsNCiAgdGVtcF9jIDwtICh0ZW1wX2YgLSAzMikgKiA1LzkNCiAgcmV0dXJuKHRlbXBfYykNCn0NCg0KbXlfdGVtcHNfZiA8LSBjKDkwLCA3OCwgODgsIDg5LCA3NykNCg0KIyBtYXAgYXBwbGllcyB0aGUgZnVuY3Rpb24gKDJuZCBhcmd1bWVudCkgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgKDFzdCBhcmd1bWVudCkgDQojIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgbGlzdC4gDQpteV90ZW1wc19jX2xpc3QgPC0gbWFwKG15X3RlbXBzX2YsIGZhcmVuaGVpdF90b19jZWxjaXVzKQ0KbXlfdGVtcHNfY19saXN0DQoNCmBgYA0KDQpUaGUgYG1hcGAgYXJndW1lbnQgbmFtZXMgYXJlIGAueGAgYW5kIGAuZmAsIHNvIHRoZSBjYWxsIHRvIGBtYXBgIGFib3ZlIGNvdWxkIGFsc28gYmUgd3JpdHRlbiBhcyBgbXlfdGVtcHNfY19saXN0IDwtIG1hcCgueCA9IG15X3RlbXBzX2YsIC5mID0gZmFyZW5oZWl0X3RvX2NlbGNpdXMpYA0KDQpOb3RlIHRoYXQgd2hlbiBwcm92aWRpbmcgYSBmdW5jdGlvbiBhcyBhbiBhcmd1bWVudCwgZ2l2ZSAqKm9ubHkgdGhlIGZ1bmN0aW9uIG5hbWUqKi4gRG8gbm90IGZvbGxvdyB0aGUgZnVuY3Rpb24gbmFtZSB3aXRoICgpIGFzIGZvciBhIGZ1bmN0aW9uIGNhbGwuDQoNCg0KIyMgTWFwIGFuZCBmcmllbmRzDQoNClRoZSBiYXNpYyBmb3JtIG9mIGBtYXBgIGFib3ZlLCByZXR1cm5zIHRoZSByZXN1bHRzIGluIGEgbGlzdC4gVGhlcmUgYXJlIHN1ZmZpeCB2ZXJzaW9ucyBvZiBgbWFwYCB0aGF0IHJldHVybiB0aGUgcmVzdWx0cyBhcyBhIHNwZWNpZmljIGRhdGEgdHlwZS4NCg0KLSBgbWFwKClgIG1ha2VzIGEgbGlzdC4NCi0gYG1hcF9sZ2woKWAgbWFrZXMgYSBsb2dpY2FsIHZlY3Rvci4NCi0gYG1hcF9pbnQoKWAgbWFrZXMgYW4gaW50ZWdlciB2ZWN0b3IuDQotIGBtYXBfZGJsKClgIG1ha2VzIGEgZG91YmxlIHZlY3Rvci4NCi0gYG1hcF9jaHIoKWAgbWFrZXMgYSBjaGFyYWN0ZXIgdmVjdG9yLg0KDQpUaGVzZSBzdWZmaXggdmVyc2lvbnMgd2lsbCBnaXZlIGFuIGVycm9yIGlmIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHJlc3VsdHMgZG9lc24ndCBtYXRjaCB0aGUgaW50ZW5kZWQgcmV0dXJuIHR5cGUuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiB3cml0ZSBjb2RlIHRvIHByb2Nlc3MgdGhlIHJlc3VsdHMgZnVydGhlciwgY29uZmlkZW50IHRoYXQgdGhleSBhcmUgb2YgYSBzcGVjaWZpYyBkYXRhIHR5cGUuIA0KDQojIEFwcGx5DQoNCkJhc2UgUiBoYXMgYSBzZXQgb2YgYnVpbHQgaW4gZnVuY3Rpb25zIHRoYXQgZHVwbGljYXRlIHRoZSBiZWhhdmlvdXIgb2YgYHB1cnJyOjptYXBgIGFuZCBpdHMgc3VmZml4IGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHRoZSAqKmFwcGx5IGZhbWlseSoqOiBgYXBwbHlgLCBgbGFwcGx5YCwgYHNhcHBseWAsIGBtYXBwbHlgLCBhbmQgYHRhcHBseWAuIFRoZSBmdW5jdGlvbnMgZGlmZmVyIHByaW1hcmlseSBpbiB0aGUgc3RydWN0dXJlIG9mIHRoZSBkYXRhIHRoZXkgcmV0dXJuLiBTZWUsIGZvciBleGFtcGxlLCBodHRwOi8vYWR2LXIuaGFkLmNvLm56L0Z1bmN0aW9uYWxzLmh0bWwgZm9yIG1vcmUgZGV0YWlsLg0KDQpGdW5jdGlvbiBgbGFwcGx5YCBpcyBhbmFsb2dvdXMgdG8gYHB1cnJyOjptYXAoKWA6DQoNCmBgYHtyfQ0KZmFyZW5oZWl0X3RvX2NlbGNpdXMgPC0gZnVuY3Rpb24odGVtcF9mKXsNCiAgdGVtcF9jIDwtICh0ZW1wX2YgLTMyKSAqIDUvOQ0KICByZXR1cm4odGVtcF9jKQ0KfQ0KDQpteV90ZW1wc19mIDwtIGMoOTAsIDc4LCA4OCwgODksIDc3KQ0KDQojIGxhcHBseSBleGFtcGxlDQpsYXBwbHlfbXlfdGVtcHNfYyA8LSBsYXBwbHkoWCA9IG15X3RlbXBzX2YsIEZVTiA9IGZhcmVuaGVpdF90b19jZWxjaXVzKQ0KbGFwcGx5X215X3RlbXBzX2MNCg0KYGBgDQoNCk5vdGUgdGhhdCBzb21lIG9mIHRoZSBhcHBseSBmYW1pbHkgcmV0dXJuIGRpZmZlcmVudCBkYXRhIHN0cnVjdHVyZXMgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSBpbnB1dCBkYXRhLiBUaGlzIGNhbiBtYWtlIGl0IGNoYWxsZW5naW5nIHRvIGtub3cgYmVmb3JlaGFuZCB3aGF0IHRoZSBvdXRwdXQgaXMgZ29pbmcgdG8gbG9vayBsaWtlIC0gdW5saWtlIHRoZSBzdWZmaXggdmVyc2lvbnMgb2YgYHB1cnJyOjptYXBgDQoNCiMgQ29uY2x1c2lvbg0KDQpJbiB0aGlzIG1vZHVsZSB3ZSBjb3ZlcmVkIHVzaW5nIGZvciBhbmQgd2hpbGUgbG9vcHMgdG8gcmVwZWF0IGNvZGUgZnJhZ21lbnRzIGVmZmljaWVudGx5LiBXZSBzYXcgdGhhdCBmdW5jdGlvbnMgaW4gdGhlIG1hcCBhbmQgYXBwbHkgZmFtaWxpZXMgcHJvdmlkZSBhbiBlcXVpdmFsZW50LCB5ZXQgbW9yZSBzdWNjaW5jdCBzeW50YXgsIHdoZW4gdGhlIHJlcGVhdGVkIGNvZGUgaXMgYSBzaW5nbGUgZnVuY3Rpb24uIENvbWJpbmluZyBsb29wcyB3aXRoIGZ1bmN0aW9ucyBhbmQgY29uZGl0aW9uYWwgZmxvdyBvZiBjb250cm9sIGZyb20gbGFzdCB3ZWVrJ3Mgc2Vzc2lvbiwgeW91IGNhbiBjcmVhdGUgY29kZSB0aGF0IGlzIG1vZHVsYXIsIHJldXNhYmxlLCBhbmQgbWFpbnRhaW5hYmxlLiANCg0KIyBXaGF0J3MgTmV4dA0KTmV4dCB3ZWVrIHdlIGNvbmNsdWRlIHRoZSBmb3JtYWwgY29udGVudCBvZiBSNFNTUCB3aXRoIGEgZGlzY3Vzc2lvbiBvZiBSIHdvcmtmbG93cywgaW5jbHVkaW5nIHByb2plY3Qgc3RydWN0dXJlLCBpbmNyZW1lbnRhbCBkZXZlbG9wbWVudCwgYW5kIGVmZmVjdGl2ZSBkZWJ1Z2dpbmcgdGVjaG5pcXVlcy4NCg0KDQpQbGVhc2UgZmlsbCBpbiB0aGUgbW9kdWxlIGZlZWRiYWNrIGZvcm0gW2h0dHBzOi8vdGlueXVybC5jb20vcjRzc3AtbW9kdWxlLWZiXShodHRwczovL3Rpbnl1cmwuY29tL3I0c3NwLW1vZHVsZS1mYikuDQoNCiANCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("08-iterate.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

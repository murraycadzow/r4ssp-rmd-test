---
title: "Functions and Choices"
date: "Semester 1, 2022"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    code_download: true
    code_folding: show
---

```{r setup, include=FALSE}
library(knitr)

knitr::opts_chunk$set(
  comment = "#>",
  fig.path = "figures/07/", # use only for single Rmd files
  collapse = TRUE,
  echo = TRUE
)


```

> #### Associated Material
>
> Zoom notes: [Zoom notes 07 - Functions and Choices](zoom_notes_07.html)
> 
> Readings:
>
> - [R for Data Science - Chapter 19](https://r4ds.had.co.nz/functions.html)

\

# Introduction

As the work you do in R becomes more complex, your R scripts will get longer, and may become difficult to manage. You may find that it is difficult to locate particular bits of code, or that you seem to be writing the same, or very similar bits of code, over and over again. If you want to modify those bits, there are multiple place in the script you have to edit, typos start to creep in, and the whole process becomes unpleasant.

To prevent this, large programs need to be organised into **logical modules**. Sections of code that perform a clearly delineated task can be enacapsulated and named. The encapsulated code can be invoked simply by typing the name -- no need to cut and paste, no need to modify multiple copies. Scripts are shorter and easier to manage. Code that is organised this way is said to be **modular**. Modular code is better code.

In R, the main code module is the **function**. We have already used many functions, like `read.csv` and `sqrt' and `ggplot`. We invoke them in our code as single commands, but each of these commands actually ecapsulates many, many (add another "many" for ggplot) lines of code. We call the function by name, and all the associated code is executed.

### Exercise

Many functions in R will display their code in the console. Type the function name **without the engine ()** into the console, and the encapsulated command will be shown. Look at the code for function `filter`.

To make our own code modular, we can define our own functions. We write the code for a function somewhere in our script file. We can then **call** the function by name anywhere else in our script file and all the code is executed. Just as with functions like `read-csv` we can pass data into our function so it know what to operate on. Just like `sqrt` we can arrange for our function to return a result that we can store in a variable. 


# Function Declaration Syntax

A function in R is comprised of four parts:

1. a name
2. the body (the code that does something)
3. (optionally) inputs
4. (optionally) output


## Defining a function

We will begin with the simplest function, one that accepts no input data, and returns no result. We **declare** the function using keyword `function`:

*name_of_function* <- **function()**
{
  *Code body*
}

Subesquently we **call** the function as:

*name_of_function*()

At that point, all the commands in the code body are executed.

For example, in the current public health situation, we often see discussions of normal body temperature (for detection of fever). We might want to be able to translate the normal temperature from Celsius to Fahreneit (as used in the North American literature). This is a logically well-delineated computation, so it makes sense to encapsulate it in a function.

```{r declare a function}

# Declare/define the function
fever_in_fahrenheit <- function()
{
  fever_in_celsius <- 37.5
  converted_to_fahrenheit <-(fever_in_celsius*9/5) + 32
  print(converted_to_fahrenheit)
}
```

```{r call}
# Call a user-defined function by name
fever_in_fahrenheit()
```

Some things to note:

-  Typing out the function declaration is not actually enough to make the function available for calling. The declaration code (from the start of the name to the closing curly bracket) **must first be executed**. Execute this code in a script as we always do, by selecting all the code (with the mouse) and typing ctrl-Enter (Windows) or cmd-Enter (Mac).
- When you execute a function declaration, **nothing happens**. In our example, you will not see the output of the print statement when you execute the declaration code. Executing a declaration **does not run the code body**. It simply parses the code body and, if there are no errors, stores it in the environment. Effectively, it informs RStudio that a function with this name exists, and defines the code which it encapsulates, so it can be called later.
- To execute the code body, state the name of the function followed by (), with no intervening spaces. This **calls** the function; we think of () as the **call operator**. Whether the code body contains 1 line or 1,000 lines or more, simply calling the function by name runs all the encapsulated code.


In R a function cannot be called until after the function declaration has been executed, as described above. Consider the following example:

```{r clear, echo=FALSE}
rm(list = ls())
```

```{r wrong order}

# If you try to call the function before it is declared....
fever_in_fahrenheit()

fever_in_fahrenheit <- function()
{
  fever_in_celsius <- 37.5
  converted_to_fahrenheit <-(fever_in_celsius*9/5) + 32
  print(converted_to_fahrenheit)
}

```

There are more advanced techniques that allow us to call functions contained in other script files where we cannot directly select and execute the declaration code. See the reading for discussion.


# Providing data to a function

Consider the following function, which demonstrated how to compute BMI (body mass index) in R, using the given values for height (in metres) and weight (in kg):

```{r calc BMI}

# Declare function calc_BMI
calc_BMI <- function()
{
  weight <- 73
  height <- 1.68
  bmi <- weight/height^2 # ^ is the exponentiation operator
  
  print(bmi)
}

# Call function calc_BMI
calc_BMI()

```
This function contains nice tidy code and is mathematically correct, but unless we happen to want the BMI of a person with exactly this height and weight, it is of no use to us. A useful function describes the computation (in this case taking the ratio or weight to height squared), and **accepts the data values** when it is called.

We have seen this many times when writing R code, when we call a function repeatedly on different input values:

```{r inputs}

sqrt(14)

sqrt(820)

sqrt(0.65)

```

To declare a function that can accept input arguments, perform these steps:

1. Between the round brackets that follow the keyword `function`, place a **variable name** for each piece of data you wish to input when the function is called.
2. In the function body refer to the input variables **by the name you placed between the round brackets**. You DO NOT need to initialise the variables inside the code body -- in fact you MUST NOT do so. Variables with those names are automatically created for you when the function is called. 
3. When calling the function, provide **a value** for each input variable. You do not need to repeat the variable name, just provide values, separated by commas, in the same order as the variables are listed in the declatration.
4. When the function is called, the system creates the input variables, assigns them the corresponding values from the call statement, and executes the code body, using those variables.

We can modify our calc_BMI function to accept weight and height as input variables, as shown. Compare this version to the earlier version. Note that we *do not* declare and initialise weight and height inside the code body.

```{r inputs}

# Declare function calc_BMI
calc_BMI <- function(weight, height)
{
  bmi <- weight/height^2 # ^ is the exponentiation operator
  
  print(bmi)
}

# Call function calc_BMI
calc_BMI(73, 1.68)

```

## Following the rules

Declaring a function with inputs defines the required **interface** of the function. That is, it defines what you have to provide if you want to call the function. If the caller violates the interface, the code is not guaranteed to work. For example:

```{r bad args 1}
calc_BMI()
```

```{r bad_args 2}
calc_BMI(16)
```

```{r bad args 3}
calc_BMI(73, 168, 42)
```

In some programming languages, one is required to specify the data type (e.g. number, string, data frame, etc.) of each input argument. Code that tries to pass in the wrong type of data will not compile. In R this is not required. R will try to run your code no matter what sort of data it gets. However, if it tries to operate on the wrong type of data, it will throw an error:


```{r bad args 4}
calc_BMI(42, "fred")
```

Naturally, R doesn't understand how to apply the exponentiation operator to "fred", and it is telling you so.



## More on the rules

Consider the following code:

```{r args 2, eval = false}

# Declare the function
compute_area <- function(width)
{
  area <- width * height
  print(area)
}

# Call the function
compute_area(35)
```


The function `compute_area` is defined with one argument, named **width**. When it is called, we must provide one value between the round brackets. In the call, we have correctly provided one argument, of the correct data type. Will the call `compute_area(35)` work correctly, or will it throw an error? What error will it throw?

When `compute_area(35)` is executed, it produces an error message: `Error in compute_area(35) : object 'height' not found`. In the code body of compute_area, we refer to an entity `height`. Since that entity is not surrounded by double-quotes, R expects to find a variable named **height** existing in the environment, and no such variable exists, because we have neither created one directly (with an assignment statement) nor passed one in as an argument to the function. 

In the same line of code, we also refer to an entity `weight`. Note that R does not complain about being unable to find `weight`. That is because we defined an input argument called **weight**. 

1. How would you modify function `compute_area` to eliminate the error?
2. How would this change the form of the call to `compute_area`.


## Taking your time with argument passing

Traditionally, new programmers find the syntax of argument passing *extremely* confusing. There are too many interacting parts: we have variable names in the declaration, variables used in the code body, and values passed in the call. At first exposure, it can be unclear how all these parts work. If this is the first time you have seen this syntax, it is worth taking some time to experiment with it to solidify your understanding. You might like to make up some simple user defined functions of your own to practice managing input data.










We can also have multiple arguments for our functions:

```{r, eval = TRUE, echo = TRUE}
# Calculates BMI on a supplied height (m) and weight (kg)
calcBMI <- function(height, weight){
  weight / height ^ 2
}


calcBMI(height = 1.68, weight = 73)
```

**NB:** Variables declared only inside a function don't exist outside of the function -- see the _Scope_ section.

We'll now go into some more explanation about the each part of the function composition. 

### Naming

Naming things is really hard. A helpful tip for naming of functions is the name should give the user an idea of what the function *does*, so should contain a verb. Try not to choose a name of a variable or function that already exists, as this will prevent you from being able to call upon the other version by using it's short name that you'll be used to e.g. `filter()`, `mean()` and instead you'll have to access the other versions with their full name which looks like this _package::function_name()_ e.g. `dplyr::filter()` or `base::mean()`. This full name method is also how you can refer exact functions from particular packages if packages have functions of the same name and you have loaded them with `library`.

### Defining arguments

Usually there are two categories of variables for a function. The first category are *data* and is often called `x`. A nice practice is to define your arguments for your input data first. The second category is *behaviour modifiers*, i.e. they control the details of the computation. A common behaviour modifier is what to do with `NA`'s e.g. `na.rm`.

At the time of declaring your arguments, you can also assign defaults. It is a good idea to set the defaults of your behaviour modifying arguments to something sensible. When the function is called by the user if they don't supply a value for the argument the value provided by the default is used.

Here is an example function that could be used if you wanted to duplicate your data:
```{r}
# duplicates a vector n times
duplicate <- function(x, n = 2) {
 rep(x, n)
}

my_nums <- c(1,2,3)

# duplicates twice (default)
duplicate(my_nums)

# duplicates 4 times
duplicate(my_nums, n = 4)
```

Something that you may have noticed is the use of the argument name is not required for the function to run. This is because R will fill in the values of the arguments based on position. You can run arguments in any order, so long as the names are provided. Best practice is to use the names when calling functions because it provides better readability of code, especially for the behaviour modifying ones.

Another important thing to note is that we haven't explicitly covered is the use of `=` rather than `<-` when defining arguments. Technically `=` can be used for assignment of variables and you may have already seen this being done:

```{r}
# using '=' for assignment to a variable
a = 3

a
```

However, the key difference between `=` and `<-` comes to the use of defining arguments to a function. `=` will pass the value to the argument without creating a variable in your global environment, `<-` can be used (but strongly recommended against) as it will pass the value to the argument, but also create a variable in the global environment of the same name:

```{r, error = TRUE}
mean(x = 3)
# x shouldn't exist so gives an error
x

# don't do this:
mean(x <- 3)
# x now exists
x
```


**NB:** For more on environments see the __Scope__ section.

### Outputs

Usually the reason for calling a function is to have it provide some output, however, providing an output isn't necessary. The last line of the function is usually what gets returned back to the user but it is possible to be explicit about what is returned by using `return()`, or to exit from the body earlier than the final line -- this situation usually arises when using control statements (explained later in this handout).

Here is an example of using the last line:

```{r}
double <- function( num ){
  # the result of the next line will be automatically returned
  num * 2
}

double(4)
```

And using `return()`:

```{r}
double <- function( num ){
  # the result of the next line will be automatically returned
  result <- num * 2
  return(result)
}

double(5)
```

This particular example of using return does create extra steps such as making and assigning to a local variable. The most useful time to use `return()` is in the body of a control flow statement to exit out the function early if a condition is met -- see the **If and Else** section.


## Scope

When you specify a variable in R it will start trying to find something with that name within the global environment (displayed in the _Environment_ tab in RStudio). In the case of functions, any variable defined in the function (including through its arguments) stays within the function (a separate local environment specific to the function). If however in the body of the function you refer to a variable that hasn't been defined in the function, R will start looking at the global environment and if it finds a variable of the same name you've created outside of the function, it will use the value that is stored within it. This behaviour can cause issues.


Here is an example, where the function needs a value for `n` but it hasn't been supplied as an argument and there is no default value.

```{r, error=TRUE}
# multiplies the number x by the number n
multiply_by_n <- function(x){
  x * n
}

multiply_by_n(x = 3)
```

In the function body we referred to `n` which wasn't defined anywhere so we got an error.


Let's use the same function again but define `n` outside the function:
```{r}
# multiplies the number x by the number n
multiply_by_n <- function(x){
  x * n
}

# define n in the global environment 
n <- 10

multiply_by_n(x = 3)
```
This time R looks for `n` inside the body but doesn't find it and when it looks into the global environment it finds a variable named `n` and so uses that value.
 
 This time we're going to modify the function to take a second argument called `n`, and also have `n` defined in the global environment:
```{r}
# multiplies the number x by the number n
multiply_by_n <- function(x, n){
  x * n
}

# define n in the global environment
n <- 10

multiply_by_n(x = 3, n = 2)
```
 
The value of `n` that was used was the value supplied as the argument, rather than the version that was defined in the global environment. What this tells us is that functions will use a locally defined variable, but if it can't find one, it will start to look wider.

Another example that demonstrates that functions operate locally (inside the body) is trying to modify variables that exist in the global environment:

```{r}
# assign the value provided to x to the variable a
modify_a <- function(x){
  a <- x
}
```

This function looks like it should assign the value of `x` into `a`. To demonstrate that the function is only working on the _function_ version of `a`, we'll define `a` globally, run the function, then see what the value in `a` is afterwards:

```{r}
# define a global version of a
a <- 12

# we want a to become 5
modify_a(x = 5)


# output the value of a
a
```

The value of `a` has remained `r a` rather than `5` like we had hoped. This shows again that the function is creating variables that only exist inside the function, and isn't modifying the global environment.

# Control Statements

Control statements allow us to use conditions to execute particular pieces of code based on the input. In the context of functions, often if we are creating a behaviour modifying argument, we want certain blocks of code to run depending on the value supplied to the argument. These statements rely on a test (condition/comparison) that results in a boolean (`TRUE`/`FALSE`) to determine what gets run. Boolean logic operators can be used in to modify or combine tests to result in a single `TRUE` or `FALSE`.


Boolean Operation | Symbol in R
---|---
NOT | !
OR | \|
AND | &

These can be combined with the comparison operators you saw in Module 3 (`==`, `!=`, `<`, `<=`, `>`, `>=`) to combine statements together into more complex logic statements. The result of the NOT, AND, and OR can be seen in the below logic table:

Statement | Becomes
---|---|---|---
  !TRUE | `r !TRUE`
 !FALSE | `r !FALSE` 
TRUE & TRUE | `r TRUE & TRUE`
TRUE & FALSE | `r TRUE & FALSE`
FALSE & TRUE | `r FALSE & TRUE`
FALSE & FALSE | `r FALSE & FALSE`
TRUE \| TRUE | `r TRUE | TRUE`
TRUE \| FALSE | `r TRUE | FALSE`
FALSE \| TRUE | `r FALSE | TRUE`
FALSE \| FALSE | `r FALSE | FALSE`



## If and Else

We use the results of logic statements in **if()** to determine if a block of code should run. The format of an `if` statement is:

```{r, eval = FALSE}
if (condition) {
  # code here is only run if condition was TRUE
}
```

Similar to a function, the `{}`'s denote the body of code belonging to `if`. This code is **only** run when the `if` condition is TRUE, otherwise it gets skipped. If we want another block of code to run when only when the condition is FALSE, we can use `else` at the end of the code block to create this second block.

```{r, eval = FALSE}
if (condition) {
  # code here is only run if condition was TRUE
} else {
  # code here is only run if condition was FALSE
}


```

The following example shows how you can create a series of conditions, where the conditions are run one at a time from the top and the first condition that evaluates to `TRUE` is the only code block that gets run.


```{r}
bmi <- 21
if(bmi > 30){
  print("obese")
} else if (bmi > 25){
  print("overweight")
} else if (bmi > 20){
  print("healthy")
} else {
  print("underweight")
}
```


## Improving functions

Now that we have looked at control statements and how they operate, we're going to look at how we can use them to make our functions better.

### Failing

One of the saying in programming is "if it's going to fail, it's best to fail early". What this means in practice is that if we know that our function can only handle a specific input or it will cause issues i.e. `1 + 2` is fine but `1 + "a"` causes an error, we want to program **defensively** so that our function "fails" before it encounters the error. R also provides notoriously difficult error messages to understand. As part of our defensive programming we can provide some messages that are user friendly instead.

- data type check functions
- stop()
Here is an example of how we can check that the data coming into our function is the correct data type:


```{r, error=TRUE}
# Returns the provided number doubled
double_number <- function(x) {
  if( !is.numeric(x) ){
    stop("x needs to be a number.")
  }
  x * 2
}


double_number(4)

double_number("a")
```

N.B. Check the appendix for more on data types.

Following the principles of fail fast and early, we want to have our checks as some of the very first code in the function body, so that if the wrong input is given we 'fail' out of the function without any further code running. We can do this using the control statement `if` to check the condition. First we're checking if `x` is a `numeric` type, `is.numeric` returns `TRUE` if it is and `FALSE` if it isn't. But we want to enter the `if` body when `x` is not numeric so perform a boolean `NOT` using the `!`.

Once we have determined that `x` isn't numeric we want the function to exit but also provide a message to the user as to why. This is done using `stop()` which causes the function to exit and provides the error message that is provided - ideally something useful for the user.





# Conclusion

This document has presented an introduction to creating your own functions and implementing control flow into your code. We covered concepts such as 'failing fast and early', and scoping of variables. If you would like to take your understanding of functions further then some good places to refer to are the free online books [Advanced R](https://adv-r.hadley.nz) and [R packages](https://r-pkgs.org).


## What's Next

Fill in the module feedback form [https://tinyurl.com/r4ssp-module-fb](https://tinyurl.com/r4ssp-module-fb).

Next move onto [R for Data Science Chapter 21 - Iteration (https://r4ds.had.co.nz/iteration.html)](https://r4ds.had.co.nz/iteration.html) to learn about how we can start to reduce code duplication, and start to repeat what we do efficiently through iteration or 'loops'. As always, if you run into trouble, let us know.

# Appendix

## Data types

Not all data is created equal, in R this concept is captured by _data types_. For a vector, all values must be of a single data type.

The main data types that you will encounter in R are:

- _Logical_ ( `c(TRUE, FALSE)`)
- _Numeric_ - also called _Real_ or _Double_ (Numbers that have a floating point (decimal) representation e.g. `c(1, 3.6, 1e3)`)
- _Character_ - also called _String_ (anything inside matching opening and closing quotes (single or double) e.g. `c("a", "some words", "animal"`))

There are 3 other less common:

- _Integer_ (integers `c(1L, 4L, -3L)`)
- _Complex_ (Complex numbers e.g. `c(0+3i, 4i, -2-5i)`)
- _Raw_ (the bytes of a file)


Each data type is known in R as an _atomic_ vector. R has built in functions to be able to determine the data type of a vector, `typeof()` is the best one to use, but others such as `str()` and `class()` can be used.

There is also a series of functions that let us do explicit checking for a data type which will return `TRUE` or `FALSE`:

- `is.logical()`
- `is.numeric()` or `is.double()`
- `is.character()`
- `is.integer()`
- `is.complex()`
- `is.raw()`



### Data Type Coercion

In R, when doing operations on multiple vectors, they all need to be the same data type - but how can this work if we have for example a numeric vector and a character vector? _Coercion_ is how R deals with trying to operate on two vectors of different data types. What this means in practice is that R will convert the data type of a vector in a defined manner such that we end up will all of the same type and follows a "lowest common data type"
 approach. Using the 3 main data types from above, the following is the order in which they will be coerced into the next data type: _logical_ -> _numeric_ -> _character_.
 
This principle applies when you try to create a vector of mixed data types too, R will coerce everything until it is a single data type.
 

See if you can predict what data type the result will be (you can check by using `typeof()`: 
```{r, eval = FALSE}
# logical and numeric
c(4, TRUE, 5)

# numeric and character
c(1, 3, "A")

# logical and character
c(FALSE, "cat","frog")

# mixed
c("see", TRUE, 4.8)

# tricky
c("1.3", "4", TRUE)
```

We can also explicitly force coercion into a particular data type by using the following:

- `as.logical()`
- `as.numeric()`
- `as.character()`

The other data types also have similarly named functions. When going against the normal direction of coercion, it is important to realise that if your data doesn't have a representation in that data type, it will become _NA_ (missing).
